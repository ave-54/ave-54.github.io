//------------------------------------------77-01.cpp
// Преобразование строки - прямое накопление результата
#include <stdio.h>
#include <string.h>
#include <math.h>

char s[100],min[100]="";		// текущая и оптимальная строка операций
int kmin=-1;					// минимальное количество операций
// A,B - указатели на текущие символы строк
// n - номер шага (глубина рекурсии)
// k - накопленное количество операций
// m - счетчик вариантов
void F(char *A, char *B,int n,int k,int &m){
s[n]=0;	m++;					// Обе строки закончились
if (*A==0 && *B==0) {			// Проверить очередной вариант на минимум 
	if (kmin==-1 || k < kmin) strcpy(min,s),kmin=k;
	return; }					// и завершить рекурсию
// Одна из строк закончилась - удалять из противоположной
if (*A==0) { s[n]='+'; F(A,B+1,n+1,k+1,m); return; }
if (*B==0) { s[n]='-'; F(A+1,B,n+1,k+1,m); return; }
// Три варианта решения задачи
if (*A==*B)						// Подзадача 1: Символы одинаковые - взаимное уничтожение
	{ s[n]='x'; F(A+1,B+1,n+1,k,m); }
else							// Не одинаковые - замена
	{ s[n]='c'; F(A+1,B+1,n+1,k+1,m); }
s[n]='-'; F(A+1,B,n+1,k+1,m);	// Подзадача 2: Удалить символ из исходной
s[n]='+'; F(A,B+1,n+1,k+1,m);	// Подзадача 3: Добавить символ в исходную 
}								// (удалить из результирующей)

void main(){
	char *s=new char[100],c1[]="ptslddf",c2[]="tsgldds";
	int n=0;
	F(c1,c2,0,0,n);
	printf("T=%d(%d) k=%d =>%s\n",n,(int)pow(3,1.5*strlen(c1)),kmin,min);
	}