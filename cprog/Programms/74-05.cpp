#include <stdio.h>
//----------------------------------------------------74-05.cpp
// Головоломка: с помощью банок 3 и 5 литров получить 4 литра
#define P1 3				// Емкости банок
#define P2 5
#define EX 4				// Искомый результат
#define N 1000

struct var{
	int nmax;				// Количество операций
	int V[N][2];			// Сохранение вариантов "разлива"
	int D[N];				// Очередное действие
	} VAR,OPT={-1};
int cnt=0;					// Счетчик рекурсивных вызовов

void F(int v1,int v2, int n){// v1,v2 - текущее заполнение "банок"
VAR.V[n][0]=v1;				// Сохранение нового варианта "разлива"
VAR.V[n][1]=v2;
VAR.D[n]=0;
if (v2==EX) {
	if (OPT.nmax==-1 || n < OPT.nmax)
		OPT=VAR, OPT.nmax=n;
	return;	}				// Найдено требуемое заполнение
if (OPT.nmax!=-1 && n>=OPT.nmax) 
	return;					// Есть уже более оптимальное решение
cnt++;
for (int i=0;i<n;i++)		// Проверка на повторение "разлива"
	if (VAR.V[i][0]==v1 && VAR.V[i][1]==v2) return;
// Возможные подзадачи - заполнение и опустошение каждой "банки"
VAR.D[n]++; F(P1,v2,n+1);
VAR.D[n]++; F(v1,P2,n+1);
VAR.D[n]++; F( 0,v2,n+1);
VAR.D[n]++; F(v1, 0,n+1);
// Возможные подзадачи - переливание из одной "банки" в другую
// Объем переливаемой жидкости - 
// Минимум из остатка в первой и свободного места во второй
int dv=(v1 < P2-v2 ? v1 : P2-v2);	
VAR.D[n]++; if (dv!=0) F(v1-dv, v2+dv,n+1);
dv=(P1-v1 < v2 ? P1-v1 : v2);
VAR.D[n]++; if (dv!=0) F(v1+dv, v2-dv,n+1);
}

void main(){ F(0,0,0); 
for (int i=0;i<=OPT.nmax;i++)
	printf("[%d:%d] %d\n",OPT.V[i][0],OPT.V[i][1],OPT.D[i]);
printf("cnt=%d\n",cnt);
}
