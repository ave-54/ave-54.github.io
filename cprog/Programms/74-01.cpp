//  омбинаторный перебор - рекурсивный генератор вариантов
#include <stdio.h>

//----------------------------------------------------------74-01
// ћножество всех подмножеств
// R - исходное множество
// W - результирующее множество (последовательность)
// n - номер шага в глубину - индекс выбираемого элементв из R
// k - количество выбранных элементов
// N - размерность задачи
// cnt - счетчик вариантов
void F1(int W[],int R[],int n,int k,int N, int &cnt){
int i;
if (n==N){
	cnt++; printf("\n");		// достигнута требуема€ размерность
    for (i=0;i<k;i++) printf("%d ",W[i]);
	return; }					// подсчет и вывод полученного вариаета
F1(W,R,n+1,k,N,cnt);			// очередной не включаетс€
W[k]=R[n];
F1(W,R,n+1,k+1,N,cnt);			// очередной включаетс€
}
//----------------------------------------------------------
// —очетаний из n по m
// m - размерность подмножества
void F2(int W[],int R[],int n,int k,int N, int m, int &cnt){
int i;
if (n>N) return;				// превышена размерность множества
if (k==m){						// выбрано m из n
	cnt++; printf("\n");		
    for (i=0;i<k;i++) printf("%d ",W[i]);
	return; }					// подсчет и вывод полученного вариаета
F2(W,R,n+1,k,N,m,cnt);			// очередной не включаетс€
W[k]=R[n];
F2(W,R,n+1,k+1,N,m,cnt);			// очередной включаетс€
}
//----------------------------------------------------------
// ѕоследовательноть без повторений
void F3(int W[],int R[],int n, int N, int &cnt){
int i;
if (n==N){					
	cnt++; printf("\n");
    for (i=0;i<n;i++) printf("%d ",W[i]);
	return; }
for (i=0;i<N;i++){				// цикл по всем оставшимс€
	if (R[i]==0) continue;		// пропуск уже выбранного
	W[n]=R[i];					// выбор оставшегос€
   	R[i]=0;						// исключение из исходного
	F3(W,R,n+1,N,cnt);			
	R[i]=W[n];					// возвращение выбранного
   }}
//----------------------------------------------------------
// ѕоследовательноть с повторени€ми - обмен с оставшимис€
void F4(int R[],int n,int N, int &cnt){
int i,c;
if (n==N){
	cnt++; printf("\n");
    for (i=0;i<n;i++) printf("%d ",R[i]);
	return; }
F4(R,n+1,N,cnt);				// очередной на своем месте
for (i=n+1;i<N;i++){	
	c=R[n]; R[n]=R[i]; R[i]=c;	// обмен очередного с оставшимис€
	F4(R,n+1,N,cnt);
	c=R[n]; R[n]=R[i]; R[i]=c;	// возвращение очередного
   }}
//----------------------------------------------------------
// ѕоследовательноть c повторени€ми
void F5(int W[],int R[],int n, int N, int &cnt){
int i;
if (n==N){					
	cnt++; printf("\n");
    for (i=0;i<n;i++) printf("%d ",W[i]);
	return; }
for (i=0;i<N;i++){				// цикл по всем оставшимс€
	W[n]=R[i];					// выбор оставшегос€
	F5(W,R,n+1,N,cnt);			
   }}

#define N 5
#define M 3
// ћассив элементов комбинации (варианта)
int W[N];
// ћассив элементов исходного множества
int R[N];

void main(){
int cnt,i;
for (i=0;i<N;i++) R[i]=i+1;
puts("SubSets: 2^N");
cnt=0;
F1(W,R,0,0,N,cnt);
printf("\ncnt=%d\n",cnt);
puts("SubSets m(n): n!/(m!(n-m)!)");
cnt=0;
F2(W,R,0,0,N,M,cnt);
printf("\ncnt=%d\n",cnt);
puts("\nSequences: N!");
cnt=0;
F3(W,R,0,N-1,cnt);
printf("\ncnt=%d\n",cnt);
puts("\nSequences: N!");
cnt=0;
F4(R,0,N-1,cnt);
printf("\ncnt=%d\n",cnt);
puts("\nTotals: N^N");
cnt=0;
F5(W,R,0,N-2,cnt);
printf("\ncnt=%d\n",cnt);
while(1);
}
