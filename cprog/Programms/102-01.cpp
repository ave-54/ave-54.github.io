//-----------------------------------------------102-01.cpp
// Класс степенного полинома - конструктор копирования
#include <stdio.h>
class poly{
int n;					// степень полинома
double *pd;				// динамический массив коэффициентов
void load(int n0, double p[]){
	n=n0;				// закрытый метод загрузки массива
	pd=new double[n+1];	// - не всегда корректно вызывается
	for(int i=0;i<=n;i++)
		pd[i]=p[i]; }
void extend(int n1){		// увеличение размерности полинома
	int i;
	if (n1<=n) return;
	double *pd1=new double[n1+1];
	for (i=0;i<=n;i++) pd1[i]=pd[i];
	for (;i<=n1;i++) pd1[i]=0;
	n=n1;
	delete []pd;		// удалить старый массив
	pd=pd1;				// считать новый за старый
	}
void normalize(){			// нормализация - удаление лишних 0
	while(n>0 && pd[n]==0) n--;
	}					// память не перераспределяется
public:
poly(){					// "пустой" полином - нулевой степени
	n=0;				// с нулевым коэффициентом
	pd=new double[1];
	pd[0]=0;}
poly(int m){				// полином заданной степени
	n=m;				// с нулевыми коэффициентами
	pd=new double[n+1];
	for(int i=0;i<=n;i++)
		pd[i]=0; }
poly(int n0,double p[]){	// конструктор из массива коэффициентов
	load(n0,p); }
poly(poly &T){			// конструктор "объект из объекта"
	load(T.n, T.pd);		// Адреса объектов
	printf("copy %x->%x\n",&T,this);
	}					// (конструктор копирования)
~poly(){					// деструктор
	delete []pd; }
//----------------------------------------------------------
double &get(int k){		// ссылка на коэффициент полинома
	static double foo=0;	// вне пределов массива - ссылка
	if (k<0 || k>n) return foo;
	return pd[k];		// на "левую" статическую переменную
	}
void show(){			// вывод в "удобочитаемом" виде
	for (int i=n,k=0; i>=0; i--){
		if (pd[i]==0) continue;
		if (k++!=0 && pd[i]>0) printf("+");
		printf("%3.1lf",pd[i]);
		if (i>0) printf("*X");
		if (i>1) printf("^%d",i);
		}
	printf("\n");
	}
void add(poly &T){		// Сложение - добавление второго к текущему
	extend(T.n);			// Увеличить до размерности второго
	for (int i=0;i<=T.n;i++) pd[i]+=T.pd[i];
	normalize();
	}
void mul(poly &T){		// Умножение 
	poly R(n+T.n+1);		// Вспомогательный объект - сумма размерностей
	for (int i=0;i<=n;i++)// Добавление частичных произведений всех пар
	for (int j=0;j<=T.n;j++)
		R.pd[i+j]+=pd[i]*T.pd[j];
	int c; double *d;	// Обмен содержимым текущего и вспомогательного
	c=n; n=R.n; R.n=c;
	d=pd; pd=R.pd; R.pd=d;
	}
void diff(){				// Производная от полинома (k*x^n)' = k*n*x^(n-1)
	for (int i=0;i<n;i++)
		pd[i]=pd[i+1]*(i+1);
	n--;
	}
int compare(poly &T){		// Сравнение полиномов
	int k=0;
	poly R(*this);		// Копия текущего
	for (int i=R.n;i>=0;i--) 
		R.pd[i]=-R.pd[i];	// Инвертирование коэффициентов
	R.add(T);			// Вычитание из второго - текущего
	R.normalize();
	if (R.n==0 && R.pd[0]==0)
		return 0;		// Результат - нулевой полином = равны
	if (R.pd[R.n]<0) return 1;
	return -1;			// Иначе - знак старшего коэффициента
	}
};

poly copy(poly X)			// Вызов КК при входе и выходе
	{ return X; }

void main(){
	double A[]={1,-2,3,-4},B[]={5,3,6};
	poly a1(3,A),a2(2,B);
	poly a3=a1;			// Синтаксис КК - определение с инициализаторм
	poly a4(a2);			// Явный вызов КК
	copy(a1).show();		// Вывод полинома - результата
}