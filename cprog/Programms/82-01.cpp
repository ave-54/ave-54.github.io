#include <stdio.h>
//------------------------------------------------------82-01.cpp
// Алгоритмы, основанные на полном обходе дерева

struct tree1{
	int val;
	int n;
	tree1 *ch[10];
	};		

tree1	a2={4,0},
		b2={5,0},
		c2={3,2,&b2,&a2},		
		d2={12,0},
		e2={7,1,&c2},
		f2={1,2,&d2,&e2},	
		g2={5,1,&f2},
		*ph3 = &g2;
//----------------------------------------------------------
// Количество вершин в дереве
int F1(tree1 *p){
	int s=1;
	for (int i=0;i < p->n; i++)
		s+=F1(p->ch[i]);	
	return s;}
//----------------------------------------------------------
// Сумма значений в вершине дерева
int F2(tree1 *p){
	int s=p->val;
	for (int i=0;i < p->n; i++)
		s+=F2(p->ch[i]);	
	return s;}
//----------------------------------------------------------
// Максимальное значение в вершине дерева
int F3(tree1 *p){
	int s=p->val;
	for (int i=0;i < p->n; i++)
		{ int vv=F3(p->ch[i]);	if (vv > s)  s=vv; }
	return s;}
//----------------------------------------------------------
// Максимальная длина ветви дерева
int F4(tree1 *p){
	int s=0;
	for (int i=0;i < p->n; i++)
		{ int vv=F4(p->ch[i]);	if (vv > s)  s=vv; }
	return s+1;
	}
//----------------------------------------------------------
// Суммарное расстояние до корня - степень сбалансированности
int F6(tree1 *p, int l){
	int s=l;
	for (int i=0;i < p->n; i++)
		s+=F6(p->ch[i],l+1);	
	return s;
	}
double main6(tree1 *p){
	return ((double)F6(p,1))/F1(p);
	}
//----------------------------------------------------------
// Поиск первого значения, удовлятворяющего условию
tree1 *F7(tree1 *p,int vv){
	if (p->val==vv) return p;
	for (int i=0;i < p->n; i++){
		tree1 *q=F7(p->ch[i],vv);
		if (q!=NULL) return q; }
	return NULL;
	}

void main(){
	printf("F1=%d\n",F1(ph3));
	printf("F1=%d\n",F2(ph3));
	printf("F3=%d\n",F3(ph3));
	printf("F4=%d\n",F4(ph3));
	printf("F6=%3.1lf\n",main6(ph3));
	printf("F7=%d\n",F7(ph3,4)->val);
	}


