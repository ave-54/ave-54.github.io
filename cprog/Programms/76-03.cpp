#include <stdio.h>
//------------------------------------------------------76-03.cpp
char	str[100];		// Правила грамматики
char	*GR[]={ "E:TM", "M:-E", "M:+E", "M:", "T:FG", "G:*T", "G:/T", "G:",
"F:c", "F:iX", "X:[E]","X:", "F:(E)", NULL};

int isNT(char c) {			// Является ли заданный символ нетерминальным
for (int i=0; GR[i]!=NULL; i++) if (GR[i][0]==c) return i;
return -1; }

int Step(char sym, int s){	// Вывод для нетерминала sym и 
int i,j,k;					// незакрытой части цепочки s
for (i=0; GR[i]!=NULL; i++)	// Просмотр всех правил
if (GR[i][0]==sym){			// Левая часть правила совпадает с sym
        for (j=2,k=s; GR[i][j]!=0; j++){ // Посимвольный просмотр правила
                if (isNT(GR[i][j])==-1){   // Нетерминальный символ
	if (GR[i][j]==str[k])	// совпадает с символом строки 
k++;						// перейти в строке к следующему
else break;					// иначе - неверное правило
				}
			else 	{		// Нетерминал - рекурсивный вызов
                        	int l=Step(GR[i][j],k);
                        	if (l==-1) break;	// Нельзя вывести - неверное правило
k=l;						// Иначе - пропустить закрытую часть
printf("*%s\n",GR[i]);
			 }
}
	// Разбор правила удалось провести до конца
if (GR[i][j]==0) { printf("%s__%s\n",GR[i],&str[k]);  return k; }
} 
return -1; }				// Ни одного правила не найдено

void main(){
printf("=>"); gets(str);
int k=Step('E',0); if (k!=-1 && str[k]==0) puts("O.K.");}
