<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data
href="023%20Очевидность,%20убеждение,%20доказательство.files/editdata.mso">
<title>2.3. Очевиднось, убеждение, доказательство</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Comp</o:Author>
  <o:Template>Книга.dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>225</o:TotalTime>
  <o:Created>2008-05-24T07:17:00Z</o:Created>
  <o:LastSaved>2008-05-24T07:17:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1633</o:Words>
  <o:Characters>9312</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>77</o:Lines>
  <o:Paragraphs>21</o:Paragraphs>
  <o:CharactersWithSpaces>10924</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
pre
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Courier New";
	color:black;}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") fs;
	mso-footnote-continuation-separator:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") fcs;
	mso-endnote-separator:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") es;
	mso-endnote-continuation-separator:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-header:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") h1;
	mso-even-footer:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") ef1;
	mso-footer:url("023%20Очевидность\,%20убеждение\,%20доказательство.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:256139526;
	mso-list-type:hybrid;
	mso-list-template-ids:-248195270 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:1333678059;
	mso-list-type:hybrid;
	mso-list-template-ids:1098292564 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
  <o:rules v:ext="edit">
   <o:r id="V:Rule5" type="callout" idref="#_x0000_s1062"/>
   <o:r id="V:Rule6" type="callout" idref="#_x0000_s1063"/>
  </o:rules>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2><span style='font-style:normal;mso-bidi-font-style:italic'>2.3.
Очевидность, убеждение, доказательство<o:p></o:p></span></h2>

<p class=a3 style='margin-top:0cm;margin-right:32.9pt;margin-bottom:0cm;
margin-left:5.0cm;margin-bottom:.0001pt;text-indent:-4.0cm'><span lang=EN-US
style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a3 align=right style='margin-top:0cm;margin-right:9.35pt;margin-bottom:
0cm;margin-left:5.0cm;margin-bottom:.0001pt;text-align:right;text-indent:-4.0cm'>Учитель:<span
style='mso-spacerun:yes'>  </span>«Гоги, докажи, что треугольник
равнобэдренный».</p>

<p class=a3 align=right style='margin-top:0cm;margin-right:9.35pt;margin-bottom:
0cm;margin-left:5.0cm;margin-bottom:.0001pt;text-align:right;text-indent:-4.0cm'>Ученик:
«Мамой клянусь, равнобэдрэнный».</p>

<p class=a3 align=right style='margin-top:0cm;margin-right:9.35pt;margin-bottom:
0cm;margin-left:5.0cm;margin-bottom:.0001pt;text-align:right;text-indent:-4.0cm'>Анекдот.</p>

<p class=a4>
<img border="0" src="Images/yan-in.jpg" width="34" height="31" align="left">Прежде всего, уясним, а
что, собственно говоря, мы будем доказывать и кому. То, что программа работает
правильно на данном примере, или что она будет всегда работать правильно.
Самому себе, если мы не окончательно уверены в ее правильности, или другому? В
70-е годы появилась область науки и технологии, которая называлась <b><a name="m1">верификация
программ.</b> Верификация состоит в формальном доказательстве того, что
программа работает правильно. Под понятием правильно понимается то, что при
любых входных данных, удовлетворяющих заданным условиям, программа производит
результат, также удовлетворяющий выходным условиям. Например, программа
сортировки из исходных данных создает упорядоченные. Условие упорядоченности
можно сформулировать формально в виде утверждения (предиката). Каждый оператор
программы преобразует такие утверждения. Таким образом, программа представляет
собой систему преобразований предикатов (систему логических уравнений). Решая
ее, получаем требуемое доказательство правильности. Проблема состояла только в
том, что само доказательство многократно превосходит по затратам написание
самой программы.</p>

<p class=a>На самом деле идей, заложенные в верификации, полезны в
проектировании программы. Программист, разрабатывая программу, никогда не пишет
ее сразу, целиком. Каждая более-менее независимая часть программы имеет свои
входные данные и свой результат – содержательный «смысл» соответствующих
переменных в программе. Программист имеет право <b><a name="m2">доверять самому себе, </b>используя
результат выполнения еще не написанной (или давно уже написанной и позабытой
части программы). Поэтому нет необходимости (на самом деле и физической
возможности)<span style='mso-spacerun:yes'>  </span>держать в голове всю
программу. Разрабатывая, отлаживая или анализируя один из фрагментов,
программист использует все остальные только в виде касающегося их набора
условий и утверждений.</p>

<p class=a><span style='mso-spacerun:yes'> </span>Кроме закрепления «смысла» за
каждой переменной<span style='mso-spacerun:yes'>  </span>в процессе проектирования
имеет место еще один момент, связанный с формулировкой условий. <b><a name="m3">Инвариантом </b>повторяющегося
в процессе выполнения фрагмента программы (цикла или рекурсивного вызова)
называется условие или утверждение, сохраняющееся от начала любого шага до
начала следующего за ним. Формулировка и доказательство сохранения инвариантов
являются важной составляющей правильного программирования таких конструкций.</p>

<p class=a>Второй вопрос в том, какими методами мы будем пользоваться. Любое
доказательство – это доведение до уровня <b><a name="m4">очевидности. </b><span
style='mso-spacerun:yes'> </span>Слово «доказать» имеет один корень с
«показать», буквально «<b><a name="m5">до</b>-того-чтобы-<b><a name="m6">показать</b>». Поскольку мы не
собираемся заниматься формальной верификацией программ, к строгости
доказательства можно относиться лояльно. На практике используется сочетание
различных методов:</p>

<p class=a1 style='margin-left:1.0cm;text-indent:-18.0pt;mso-list:l0 level1 lfo2;
tab-stops:list 1.0cm'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>формальные математические методы: например, уже
упомянутые инварианты циклов и рекурсивных вызовов позволяют обосновать
результат выполнения цикла на основе <b><a name="m7">метода математической индукции. </b>Можно
также привести пример преобразования сложных логических утверждений с
использованием законов преобразования из булевой алгебры;</p>

<p class=a1 style='margin-left:1.0cm;text-indent:-18.0pt;mso-list:l0 level1 lfo2;
tab-stops:list 1.0cm'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>полуформальная логика. В повседневной жизни мы
не пользуемся исчислением предикатов или преобразованием логических выражений,
когда решаем математические задачи или доказываем теоремы. И делаем это
интуитивно верно. (Даже Шерлок Холмс, хотя и не изучал таких наук, всегда
рассуждал логически безупречно). Поэтому тот уровень логики и доказательности,
который используется в математике и других точных науках, вполне достаточен и в
программировании. Здесь еще одна точка пересечения программирования и
математики – в способе мышления и организации умственной деятельности;</p>

<p class=a1 style='margin-left:1.0cm;text-indent:-18.0pt;mso-list:l0 level1 lfo2;
tab-stops:list 1.0cm'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>содержательное (образное) представление.
Некоторые результаты работы программы можно принимать без доказательств, если
они очевидны (буквально<b><a name="m8"> оче-видны</b>). Графическая схема (рисунок,
иллюстрация), либо пример работы программы тоже могут быть доводами в
доказательстве правильности работы программы (поскольку и так все видно).
Здесь, правда, есть один большой недостаток: рисунок, схема или пример отражают
поведение программы для <b><a name="m9">конкретных </b>данных, т.е. это доказательство для <b><a name="m10">частного</b>
случая. Поэтому необходимо рассматривать все возможные комбинации исходных
данных (имеется в виду различные варианты и крайние случаи вида: пустой массив,
массив из одинаковых элементов, массив без повторяющихся элементов,
произвольный массив и т.п.).</p>

<p class=a>Конечно, предъявление образного доказательства не везде принимается
всерьез. Например, в геометрии не принято отвечать: «Отрезки равны, потому что
это и так видно». Обычно образное представление используется при проведении
доказательства – для того, чтобы «увидеть» в задаче элементы, подпадающие под
известные теоремы или аксиомы. Аналогично, образная модель работы программы
используется для того, чтобы «увидеть» в ней стандартные фрагменты.<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a>И последнее. Доказательство, к сожалению, не дает нового знания.
Доказать можно только то, что уже знаешь. Это имеет к анализу программ. При
анализе нужно сначала догадаться, что делает или что может делать фрагмент, а
потом уже убедиться (доказать). Если не знаешь, что делает программа, то и
никакие доказательства здесь не помогут. Получается замкнутый круг. Выход из
него основан на других формах умственной деятельности: интуиции, догадке,
опыте.</p>

<h3>Метод математической индукции (ММИ)</h3>

<p class=a4>
<img border="0" src="Images/science.jpg" width="43" height="33" align="left">Утверждение справедливо
для любого <b><a name="m11"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>, </b>если
оно справедливо при <b><a name="m12"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0,
</b>а из справедливости его при любом произвольном <b><a name="m13"><span lang=EN-US
style='mso-ansi-language:EN-US'>k</span><span lang=EN-US> </span></b>можно
доказать его справедливость при <b><a name="m14"><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>+1. </b>Иначе говоря, некоторое условие выполняется на
последовательности (возможно бесконечной) шагов, если оно выполняется на первом
шаге, а из его выполнения на произвольном текущем шаге следует аналогичное его
выполнение на следующем. </p>

<p class=a>ММИ применяется, в основном, для доказательства правильности
циклических и рекурсивных программ (см. 3.7, 7.3). В самом методе есть одна
тонкость. Утверждается справедливость условия на бесконечной последовательности
<b><a name="m15">частных (конкретных) </b>шагов. И доказывается это путем сохранения
справедливости утверждения от начала до конца одного <b><a name="m16">общего (абстрактного) </b>шага.
А в этом и заключается один из элементов методики проектирования циклов.
Процесс выполнения цикла – это последовательность его конкретных шагов, а
описание тела цикла в программе – описание произвольного (абстрактного) шага.
Поэтому при разработке тела цикла используются индуктивные утверждения:
«Допустим, программа выполнила некоторое количество шагов цикла, сохранив
утверждение <b><a name="m17"><span lang=EN-US style='mso-ansi-language:EN-US'>A</span><span
lang=EN-US> </span></b>(вычислив значение <b><a name="m18"><span lang=EN-US style='mso-ansi-language:
EN-US'>B</span></b> для <b><a name="m19"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span><span
lang=EN-US> </span></b>элементов). Необходимо так спроектировать тело цикла,
чтобы это утверждение по окончании тела цикла сохранилось с учетом того, что
шагов цикла стало на 1 больше (значение <b><a name="m20"><span lang=EN-US style='mso-ansi-language:
EN-US'>B</span></b> вычислилось<span style='mso-spacerun:yes'>   </span>для <b><a name="m21"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>+1 </b>элементов)».</p>

<p class=a>Рассмотрим ММИ как инструмент доказательства.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=1, s=A[0];
i&lt;n; i++) if (A[i]&gt;s) s=A[i];<o:p></o:p></span></p>

<p class=a>Почему приведенный фрагмент находит максимум? Согласно ММИ, если
утверждение, что <b><a name="m22"><span lang=EN-US style='mso-ansi-language:EN-US'>s</span></b>
- это максимальное значение, справедливо в начале<span
style='mso-spacerun:yes'>  </span><b><a name="m23"><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span></b>-го шага цикла, т.е. для <b><a name="m24"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>-1 </b>элементов массива, то следует
доказать, что в конце шага оно будет справедливо уже для <b><a name="m25"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span><span lang=EN-US> </span></b>элементов.
На самом деле доказывать ничего и не надо, поскольку фраза<span
style='mso-spacerun:yes'>  </span><b><a name="m26"><span lang=EN-US style='mso-ansi-language:
EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>) <span lang=EN-US
style='mso-ansi-language:EN-US'>s</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>];</b> сохраняет свойство переменной <b><a name="m27"><span
lang=EN-US style='mso-ansi-language:EN-US'>s</span> быть максимумом: </b>если
очередной элемент больше, чем максимальный из предыдущих элементов, то он и
становится новым максимумом, иначе сохраняется старый. Обратите внимание на
различную интерпретацию значения переменной <b><a name="m28"><span lang=EN-US
style='mso-ansi-language:EN-US'>s</span>: </b>при сравнении это – «старый»
максимум, а при присваивании – «новый». Само же свойство «быть максимумом»<b><a name="m29"> </b>является
<b><a name="m30">инвариантом </b>цикла: условный оператор в теле цикла сохраняет его от
начала шага до конца с учетом текущего элемента массива.</p>

<h3>Программные соглашения и инварианты</h3>

<p class=a><b><a name="m31">Инвариант цикла. </b>Особенность цикла состоит в том, что во
время выполнения он представляет собой последовательность однотипных шагов, а
при проектировании рассматривается как единое целое. Точнее, программист видит
«<b><a name="m32">очередной шаг цикла</b>». Для его проектирования не следует «заглядывать» в
предыдущий и последующий<span style='mso-tab-count:1'>          </span>шаги,
во-первых, потому что там будет то же самое, что и на текущем, а во-вторых,
потому что это потребует аналогичного перехода назад и вперед и т.д. до
бесконечности. Поэтому следует мыслить <b><a name="m33">индуктивно, </b>рассматривая текущий
шаг как элемент процесса, сохраняющего определенное свойство – <b><a name="m34">инвариант
цикла. </b>При этом тело цикла при любых условиях его выполнения должна
сохранять этот инвариант.</p>

<p class=a>Самый простой пример: пусть программа просматривает строку по
словам. Тогда, если очередной шаг цикла получает начало слова, то закончиться
он должен на начале следующего. В более сложных случаях, когда цикл выполняется
с неравномерным шагом, либо меняет исходные данные, с которыми работает
инвариантом является фрагмент, который обрабатывается за один шаг. Например,
программа, которая заменяет в строке последовательности одинаковых символов на
один такой символ, предваренный числом его повторений (например <b><a name="m35"><span
lang=EN-US style='mso-ansi-language:EN-US'>srkkkkkkkttttttmk</span> – <span
lang=EN-US style='mso-ansi-language:EN-US'>sr</span>7<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>6<span lang=EN-US
style='mso-ansi-language:EN-US'>tmk</span></b>) за одни шаг обрабатывает либо
одиночный символ, либо цепочку одинаковых. В любом случае после всех
преобразований в конце текущего шага цикл должен находиться на начале
следующего фрагмента.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----------------------------------------------------------------------23-01.cpp</p>

<p class=a0>// &quot;Склеивание&quot; повторяющихся символов</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void F(char c[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i=0,k; <o:p></o:p></span></p>

<p class=a0>while (c[i]!='\0'){<span style='mso-tab-count:5'>                                                  </span>//
1 шаг цикла - 1 символ или цепочка одинаковых</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (c[i]!=c[i+1]) i++;<span style='mso-tab-count:
3'>                                 </span>// </span>единичный символ</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>else<span style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>for(k=2;
c[i]==c[i+k];k++);<span style='mso-tab-count:1'>           </span>// k - </span>длина<span
style='mso-ansi-language:EN-US'> </span>цепочки<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>int j=i+k;<span
style='mso-tab-count:3'>                                   </span>// Начало
сдвигаемого хвоста</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(k&gt;=10) c[i++]=k/10+'0';<span style='mso-tab-count:1'>           </span>//
Запись цифры десятков</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>c[i++]=k%10+'0';<span
style='mso-tab-count:2'>                        </span>// Запись цифры единиц</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>i++;<span
style='mso-tab-count:4'>                                          </span>//
Оставить один символ из цепочки</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>int
m=i;<span style='mso-tab-count:4'>                                     </span>//
i остается как начало сдвинутого хвоста</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>do {
c[m++]=c[j]; }<span style='mso-tab-count:2'>                      </span>//
Сдвинуть &quot;хвост&quot;<span style='mso-spacerun:yes'>  </span></p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>while(c[j++]!=0);<span
style='mso-tab-count:3'>                         </span>//<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>}}}</p>

<p class=a4>Обратите внимание, что после записи двух цифр счетчика и пропуска
одного символа текущей цепочки повторений мы оказываемся в начале следующего
фрагмента строки, но только после того, как остаток фрагмента повторений будет
удален путем переноса на его место последующей части строки («хвоста»).<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a>В более широком смысле понятие инварианта можно рассматривать как <b
style='mso-bidi-font-weight:normal'>программное соглашение. </b>Это может быть соглашение
о допустимых значениях данных, смысловая интерпретация переменных, свойство,
сохраняемое программой в рамках определенного фрагмента. При таком взгляде на
программу процесс ее разработки может и не быть «непрерывным», она распадается
на отдельные фрагменты, которые связаны между собой программными соглашениями. Действительно,
в процессе разработки программы программист не держит ее в голове целиком. Он
актуализирует только некоторую ее <span style='mso-spacerun:yes'> </span>часть,
а в ней обеспечивает соблюдение указанных соглашений, устанавливаемых другими
частями. Кстати, эти части могут быть еще не написаны (будут написаны позднее).</p>

<p class=a><img border="0" src="Images/023-01.gif" width="552" height="293"></p>

<p class=a4 align=center style='text-align:center'><b><a name="m36">рис 23.1. Соглашения и
инварианты при проектировании программы<o:p></o:p></b></p>

<p class=a4 align=center style='text-align:center'><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
