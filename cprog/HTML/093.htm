<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="093.files/editdata.mso">
<title>9.3. Указатель на функцию</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>www.PHILka.RU</o:Author>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>221</o:TotalTime>
  <o:Created>2008-05-26T18:51:00Z</o:Created>
  <o:LastSaved>2008-05-26T18:51:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>2423</o:Words>
  <o:Characters>13812</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>115</o:Lines>
  <o:Paragraphs>32</o:Paragraphs>
  <o:CharactersWithSpaces>16203</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:64.35pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:-18.0pt;
	mso-pagination:widow-orphan;
	mso-list:l0 level1 lfo1;
	tab-stops:42.55pt list 64.35pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:0cm;
	margin-right:32.9pt;
	margin-bottom:0cm;
	margin-left:5.0cm;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{mso-style-name:стихи;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.1, li.1, div.1
	{mso-style-name:эпиграф1;
	mso-style-parent:эпиграф;
	margin-top:0cm;
	margin-right:9.35pt;
	margin-bottom:0cm;
	margin-left:9.0cm;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("093.files/header.htm") fs;
	mso-footnote-continuation-separator:url("093.files/header.htm") fcs;
	mso-endnote-separator:url("093.files/header.htm") es;
	mso-endnote-continuation-separator:url("093.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-even-header:url("093.files/header.htm") eh1;
	mso-header:url("093.files/header.htm") h1;
	mso-even-footer:url("093.files/header.htm") ef1;
	mso-footer:url("093.files/header.htm") f1;
	mso-first-header:url("093.files/header.htm") fh1;
	mso-first-footer:url("093.files/header.htm") ff1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:1628194852;
	mso-list-type:hybrid;
	mso-list-template-ids:-964799380 -1450833310 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-style-link:список;
	mso-level-text:\F0B7;
	mso-level-tab-stop:64.35pt;
	mso-level-number-position:left;
	margin-left:64.35pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Сетка таблицы";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
  <o:regrouptable v:ext="edit">
   <o:entry new="1" old="0"/>
   <o:entry new="2" old="1"/>
   <o:entry new="3" old="0"/>
  </o:regrouptable>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2>9.3. Указатель на функцию. Динамическое связывание </h2>

<p class=a>Указатель на функцию - переменная, которая содержит адрес некоторой
функции. Соответственно, косвенное обращение по этому указателю представляет
собой вызов функции. </p>

<p class=a>Определение указателя на функцию имеет вид: </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>int<span style='mso-tab-count:1'>         </span>(*pf)();<span
style='mso-tab-count:1'>   </span><span style='mso-tab-count:2'>                        </span>//
без контроля параметров вызова</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int</span><span
style='mso-tab-count:1'>         </span>(*<span lang=EN-US style='mso-ansi-language:
EN-US'>pf</span>)(<span lang=EN-US style='mso-ansi-language:EN-US'>void</span>);<span
style='mso-tab-count:2'>                      </span>// без параметров, с
контролем по прототипу</p>

<p class=a0>int<span style='mso-tab-count:1'>         </span>(*pf)(int, char*);<span
style='mso-tab-count:2'>              </span>// с контролем по прототипу</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>В соответствии с принципом контекстного определения типа данных эту
конструкцию следует понимать так: <b style='mso-bidi-font-weight:normal'><a name="m1">pf</b>
- переменная, при косвенном обращении к которой получается функция с
соответствующим прототипом, например <b style='mso-bidi-font-weight:normal'><a name="m2">int_F(int,
char*)</b>, то есть <b style='mso-bidi-font-weight:normal'><a name="m3">pf</b> содержит
адрес функции или указатель на функцию. Следует обратить внимание на то, что в
определении указателя присутствует прототип - указатель ссылается не на
произвольную функцию, а только на одну из функций с заданной схемой формальных
параметров и результата.</p>

<p class=a>Перед началом работы с указателем его необходимо назначить на
соответствующий объект, в данном случае - на функцию. В синтаксисе Си выражение
вида <b style='mso-bidi-font-weight:normal'><a name="m4">&amp;имя_функции</b> имеет смысл -
начальный адрес функции или указатель на функцию. Кроме того, по аналогии с
именем массива использование имени функции без скобок также интерпретируется
как указатель на эту функцию. Указатель может быть инициализирован и при
определении. </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int<span
style='mso-tab-count:1'>         </span>INC(int </span>а<span lang=EN-US
style='mso-ansi-language:EN-US'>) { return a+1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>extern<span
style='mso-tab-count:1'>   </span>int<span style='mso-spacerun:yes'> 
</span>DEC(int);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int<span
style='mso-tab-count:1'>         </span>(*pf)(int);<o:p></o:p></span></p>

<p class=a0>pf = &amp;INC;</p>

<p class=a0>pf = INC;<span style='mso-tab-count:3'>                                   </span>//
присваивание указателя</p>

<p class=a0>int<span style='mso-tab-count:1'>         </span>(*pp)(int) =
&amp;DEC; <span style='mso-tab-count:1'>         </span>// инициализация
указателя</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Естественно, что функция, на которую формируется указатель, должна
быть известна транслятору - определена или объявлена как внешняя. Синтаксис
вызова функции по указателю совпадает с синтаксисом ее определения.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>n = (*pf)(1) + (*pp)(n);<span style='mso-tab-count:2'>                 </span>//
эквивалентно</p>

<p class=a0>n = INC(1) + DEC(n);</p>

<p class=a>Как и обычный указатель, указатель на функцию имеет размерность
адреса, т.е. на уровне архитектуры является машинным словом, содержащим адрес
функции в соответствии с системой формирования адресов процессором (системой
адресации памяти). Это позволяет, в свою очередь, опускаться до таких
машинно-зависимых действий как вызов функции по заданному адресу памяти,
преобразуя целую константу к указателю на функцию.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span> (*<span
lang=EN-US style='mso-ansi-language:EN-US'>pf</span>)(<span lang=EN-US
style='mso-ansi-language:EN-US'>void</span>) = (<b style='mso-bidi-font-weight:
normal'><a name="m5"><span lang=EN-US style='mso-ansi-language:EN-US'>void</span>(*)(</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>void</span>)</b>)0<span lang=EN-US style='mso-ansi-language:EN-US'>x</span>1000;<span
style='mso-tab-count:1'>    </span>// Константа 1000 – шестнадцатеричный адрес</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>main</span>()
{ (*<span lang=EN-US style='mso-ansi-language:EN-US'>pf</span>)(); }<span
style='mso-tab-count:3'>                               </span>// функции,
которую вызывает <span lang=EN-US style='mso-ansi-language:EN-US'>main<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:5; mso-ansi-language:EN-US' lang="EN-US">                                                            </span>//
<b style='mso-bidi-font-weight:normal'><a name="m6"><span lang=EN-US style='mso-ansi-language:
EN-US'>void</span>(*)(<span
lang=EN-US style='mso-ansi-language:EN-US'>void</span>) –</b>абстрактный тип
данных –</p>

<p class=a0><span style='mso-tab-count:5'>                                                            </span><span
lang=EN-US style='mso-ansi-language:EN-US'>// указатель на функцию </span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a4>
<img border="0" src="Images/science.jpg" width="43" height="33" align="left">Указатель
на функцию прежде всего имеет отношение к системному программированию.
Достаточно сказать, что кроме Си в явном виде он встречается только в Паскале
(процедурный тип), но во многих случаях входит в скрытые механизмы управления
программной средой, известные как <b style='mso-bidi-font-weight:normal'><a name="m7">динамическое
связывание функций. </b>Динамическое и статическое связывание мы уже обсуждали
в 5.6., но там это относилось к переменным. По отношению к функции термин
динамическое связывание следует понимать как установление соответствия между
именем функции и ее адресом. Если рассматривать этот вопрос по отношению
обычным функциям на Си, то можно выделить три этапа связывания:</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>если определение функции и ее вызов находятся в
одном модуле (файле), то транслятору ничего не мешает вычислить относительный
адрес функций внутри объектного модуля во время трансляции – <b
style='mso-bidi-font-weight:normal'>статическое связывание;</b></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>при вызове внешней функции, определение которой
находится в другом файле (а программный код – в другом объектном модуле), адрес
функции становится известен при компоновке программного файла<span
style='mso-spacerun:yes'>  </span>из объектных модулей. Хотя процедура
компоновки выполняется после трансляции, данное связывание также называется <b
style='mso-bidi-font-weight:normal'>статическим</b>;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>набор внешних функций (объектный модуль целиком)
может быть оформлен в виде динамически связываемой библиотеки – DLL<span
style='mso-spacerun:yes'>  </span>(dynamic linking library). Она загружается в
память одновременно с программным модулем и связывание имени внешней функции с
ее адресом в адресном пространстве DLL происходит при загрузке. Это связывание
уже считается <b style='mso-bidi-font-weight:normal'><a name="m8">динамическим. </b>При
наличии в каждом приложении отображаемого адресного пространства (виртуальной
памяти) программный код DLL<span style='mso-spacerun:yes'>  </span>может
одновременно использоваться (разделяться) несколькими приложениями.</p>

<p class=a>Если на уровне среды программирования или непосредственно в
Си-программах имеет место элемент динамического связывания, то с уверенностью
можно сказать, что в том или ином виде (явно или неявно) используется указатель
на функцию: </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>уже упомянутые нами DLL, а также все возможные
виды динамической загрузки внутреннего (исполняемого) программного кода;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>виртуальные функции в Си++ (см.<b
style='mso-bidi-font-weight:normal'>12.4</b>.) – при конструировании объекта
производного класса в базовый класс помещается указатель на таблицу виртуальных
функций для производного класса (массив указателей на функции);</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>функции, работающие с произвольными типами
данных – для настройки на конкретный тип данных в качестве «довеска» получают
указатель на функцию, которая «знает», как с ним работать. В результате
основной алгоритм изолируется от типа данных, с которым работает.</p>

<h3>Таблицы функций, вызов по имени</h3>

<p class=a>Тип данных вида <b style='mso-bidi-font-weight:normal'><a name="m9">void
(*pp[])() </b>расшифровывается в соответствии с контекстным определением типа
данных как массив указателей на функции с общим прототипом (схемой передачи
параметров и результата) – последовательность операций в контексте – массив –
указатель – вызов функции. Образно, хотя и не совсем точно этот тип можно
назвать <b style='mso-bidi-font-weight:normal'><a name="m10">таблицей функций, </b>вызов
которых может производиться по номеру (индексу). </p>

<p class=a>В самом простом примере наличие таблицы функций позволяет сделать
вызов функции по заданному символьному имени регулярным (циклическим). В
принципе, то же самое можно сделать с помощью обычного переключателя (<span
lang=EN-US style='mso-ansi-language:EN-US'>switch</span>), но для этого
придется еа каждую новую функцию добавлять фрагмент программного кода. Здесь же
достаточно внести в массивы символьное имя и ее адрес.</p>

<p class=a0><span style='font-size:14.0pt;mso-bidi-font-size:10.0pt;font-family:
"Times New Roman CYR";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>extern double
sin(double);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>extern double
cos(double);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>extern double
tan(double);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>char</span><span
style='mso-tab-count:1'>      </span>*<span lang=EN-US style='mso-ansi-language:
EN-US'>names</span>[] = { &quot;sin&quot;,&quot;cos&quot;,&quot;tan&quot;,NULL};<span
style='mso-tab-count:1'>       </span>// Массив имен (указатели на строки)</p>

<p class=a0>double<span style='mso-tab-count:1'>   </span>(*pf[])(double) = {
sin, cos, tan};<span style='mso-tab-count:2'>               </span>// Таблица
функций (адреса функций)</p>

<p class=a0>//-----------------------------------------------------<span
lang=EN-US style='mso-ansi-language:EN-US'>-------------------------------</span>-<span
lang=EN-US style='mso-ansi-language:EN-US'>9</span>3-01.<span lang=EN-US
style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//---- Вызов функции по имени из заданного списка</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>double call_by_name(char *pn, double arg) {<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for ( int i=0; names[i]!=NULL; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'>  
</span>if (strcmp(names[i],pn) == 0) {<span style='mso-spacerun:yes'>          
</span><span style='mso-tab-count:1'>   </span>// Имя найдено -<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>return</span> ((*<span lang=EN-US
style='mso-ansi-language:EN-US'>pf</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>])(<span lang=EN-US style='mso-ansi-language:EN-US'>arg</span>));<span
style='mso-spacerun:yes'>                 </span><span style='mso-tab-count:
2'>                      </span>// вызов функции по <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>-му</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}<span
style='mso-spacerun:yes'>                                     </span><span style='mso-tab-count:
3'>                            </span>// указателю в массиве <span lang=EN-US
style='mso-ansi-language:EN-US'>pf</span></p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>return</span> 0.;}</p>

<p class=a>В принципе, используя технику работы с двоичными файлами и
динамические массивы, можно было бы выполнить динамическую загрузку функций из
программных файлов. Однако эта задача является архитектурно зависимой и требует
учета особенностей перемещения программного кода и защиты памяти программы в
операционной системе.</p>

<h3>Указатель на функцию как средство параметризации алгоритма</h3>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m11"><span
style='mso-spacerun:yes'> </span></b>Оригинальность и обособленность указателя
на функцию заключается в том, что указуемым объектом является не переменная
(компонента данных программы), а функция (компонента алгоритма). Но сущность
указателя при этом не меняется: если обычный указатель позволяет
параметризовать алгоритм обработки данных, то указатель на функцию позволяет
параметризовать сам алгоритм. Это значит, что некоторая его часть может быть
заранее неизвестна (не определена, произвольна) и будет подключаться к
основному алгоритму только в момент его выполнения (динамическое связывание).</p>

<p class=a0 style='text-indent:36.0pt'><o:p>&nbsp;</o:p></p>

<p class=a0><img border="0" src="Images/093-01.gif" width="560" height="281"><br
style='mso-ignore:vglayout' clear=ALL>
</p>

<p class=a align=center style='text-align:center'><b><a name="m12">рис. 93-1. Параметризация
алгоритма <o:p></o:p></b></p>

<p class=a>Для реализации указанного принципа основная функция должна получать
необходимый для ее работы «довесок» в виде формального параметра – указателя на
функцию. В качестве примера приведем функцию вычисления определенного
интеграла, в которой подынтегральная функция (в математическом смысле)
передается в виде вычисляющей ее функции (в «программистском» смысле), которая
передается формальным параметром - указателем на функцию.</p>

<p class=a4>
<img border="0" src="Images/smile.jpg" width="40" height="41" align="left">«Функция,
вычисляющая функцию, предается в виде указателя на функцию»</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>&nbsp;</p>
<p class=a0>//------------------------------------------------------------------93-02.cpp</p>

<p class=a0>//------Численное интегрирование произвольной функции</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>double INTEG(double a, double b, int n,
double(*pf)(double))<o:p></o:p></span></p>

<p class=a0>// a,b - границы интегрирования, n - число точек</p>

<p class=a0>// pf - подынтегральная функция</p>

<p class=a0><span style='mso-spacerun:yes'> </span>{ double s,h,x;</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (s=0., x=a, h = (b-a)/n; x &lt;=b; x+=h) s
+= (*pf)(x) * h;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return s; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>extern double sin(double);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main() {
printf(&quot;sin(0..pi/2)=%lf\n&quot;,INTEG(0.,M_PI/2,40,sin)); }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>Другой частный пример подобного рода – сортировка одной и той же
структуры данных по разным критериям. В массиве структур типа <b
style='mso-bidi-font-weight:normal'>user</b> для задания способа сравнения
используется указатель на внешнюю функцию сравнения, которая в качестве
параметров получает две ссылки на сравниваемые структуры.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------93-03.cpp</p>

<p class=a0>//------Сортировка массива структур по разным критериям</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>struct
user{<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>char name[20];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>int account;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>double time;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>}<span
style='mso-tab-count:1'>     </span>S[]={</span>…<span lang=EN-US
style='mso-ansi-language:EN-US'>};<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//--------
</span>Вставка<span style='mso-ansi-language:EN-US'> </span>погружением<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>// cmp - указатель на функцию сравнения двух struct user</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void
sort(user A[], int (*cmp)(user&amp;,user&amp;)){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>for (int i=1;A[i].name[0]!=0;i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>            </span>for(int j=i; j&gt;0 &amp;&amp;
(*cmp)(A[j],A[j-1])&lt;0; j--)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>            </span>{ user c=A[j];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>            </span>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>j</span>]=<span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>j</span>-1];<span
style='mso-tab-count:2'>            </span>// Обмен элементов массива - </p>

<p class=a0><span style='mso-tab-count:2'>            </span>A[j-1]=c;
}<span style='mso-tab-count:3'>             </span>// структурированных переменных</p>

<p class=a0><span style='mso-tab-count:1'>      </span>}</p>

<p class=a0>//--------- функция сравнения по имени</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int
cmp_name(user &amp;u1, user &amp;u2){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>return strcmp(u1.name,u2.name); }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//---------
</span>функция<span style='mso-ansi-language:EN-US'> </span>сравнения<span
style='mso-ansi-language:EN-US'> </span>по<span lang=EN-US style='mso-ansi-language:
EN-US'> account<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int
cmp_account(user &amp;u1, user &amp;u2){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>return u1.account - u2.account; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//---------
</span>функция<span style='mso-ansi-language:EN-US'> </span>сравнения<span
style='mso-ansi-language:EN-US'> </span>по<span lang=EN-US style='mso-ansi-language:
EN-US'> time<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int
cmp_time(user &amp;u1, user &amp;u2){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>return u1.time - u2.time; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void
main(){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>sort(S,cmp_name);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>sort(S,cmp_account);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>      </span>sort</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>S</span>,<span lang=EN-US style='mso-ansi-language:
EN-US'>cmp</span>_<span lang=EN-US style='mso-ansi-language:EN-US'>time</span>);
}</p>

<p class=a>Этот пример можно обобщить на случай использования данных любого
типа. В Си отсутствует понятие произвольный (неопределенный) тип, но понятие
указатель на неопределенный (произвольный) тип<span style='mso-spacerun:yes'> 
</span>существует – это <b style='mso-bidi-font-weight:normal'><a name="m13">void*. </b>Однако
прямое использование этого указателя невозможно. Какой же здесь выход?</p>

<p class=a style='text-indent:0cm'>
<span style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>Если существуют
несколько идентичных структур данных, отличающихся типом хранимых данных, то
один и тот же алгоритм будет отличаться только отдельными операциями,
касающимися переменных этого типа. Например, при сортировке массива указателей
на строки сравнение реализуется выражением вида <b style='mso-bidi-font-weight:
normal'><a name="m14">strcmp(p[</b><b style='mso-bidi-font-weight:normal'><a name="m15"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>],</b><b style='mso-bidi-font-weight:
normal'><a name="m16"><span lang=EN-US style='mso-ansi-language:EN-US'>p</span>[</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>-1]), </b>а в массиве указателей на целые используется непосредственное
сравнение <b style='mso-bidi-font-weight:normal'><a name="m17">*</b><b style='mso-bidi-font-weight:
normal'><a name="m18"><span lang=EN-US style='mso-ansi-language:EN-US'>p</span>[</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]&lt;*<span
lang=EN-US style='mso-ansi-language:EN-US'>p</span>[</b><b style='mso-bidi-font-weight:
normal'><a name="m19"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>-1].</b> Если
эту операцию вынести за пределы алгоритма, реализовать отдельной функцией, а
указатель на нее передавать в качестве параметра, то мы получим универсальную
функцию сортировки массивов указателей на переменные любого типа данных. Можно
назвать ее условно (хотя и не совсем точно) <b style='mso-bidi-font-weight:
normal'><a name="m20">итератором</b>. </p>

<p class=a style='text-indent:0cm'>Типичными итераторами являются: </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>итератор обхода (<b style='mso-bidi-font-weight:
normal'><a name="m21">foreach</b>), выполняющий для каждой переменной в структуре данных
указанную функцию; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>итераторы проверки и поиска по условию (<b
style='mso-bidi-font-weight:normal'>firstthat</b>), возвращающие указатель на
первую (последнюю, очередную) переменную, которая удовлетворяет условию,
проверяемому в функции; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>итераторы, работающие на упорядоченных данных,
использующие сравнение: сортировка, поиск минимального, двоичный поиск,
включение с сохранением порядка. </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a style="text-align: center">
<img border="0" src="Images/093-02.jpg" width="401" height="356"><p class="a" style="text-align: center"><br
style='mso-ignore:vglayout' clear=ALL>
<b><a name="m22">Рис. 93-2. Структура итератора</b></p>
<p>Итератор являет собой пример универсализации алгоритма, основанный на
разделении «компетенций» между различенными его частями: </p>
</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>структура данных, обрабатываемая итератором,
содержит в своих элементах указатели на переменные произвольного (неизвестного
для итератора) типа<b style='mso-bidi-font-weight:normal'><a name="m23"> void*, </b>но
одинакового в каждом экземпляре структуры данных. Структура данных «знает», где
хранятся переменные, но «не знает», как их обработать; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>итератор получает в качестве параметров
указатель на структуру данных и указатель на функцию обработки. Эта функция
«знает», как обработать переменные, но «не знает», где их взять; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>итератор выполняет алгоритм обработки структуры
данных в соответствии со своим назначением: <b style='mso-bidi-font-weight:
normal'><a name="m24">foreach</b> -<span style='font-family:"Times New Roman"'> </span>обходит
все переменные, <b style='mso-bidi-font-weight:normal'><a name="m25">firstthat</b> -<span
style='font-family:"Times New Roman"'> </span>обходит и проверяет все
переменные, итератор сортировки -сортирует указатели на хранимые объекты (или
соответствующие элементы структуры данных, например, элементы списка); </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>действие, которое надлежит выполнить над хранимыми
объектами произвольного типа, реализуется вызовом внешней функции через
указатель. Итератор извлекает из структуры данных указатели <b
style='mso-bidi-font-weight:normal'>void* </b>на хранимые данные и передает их
внешней функции.<span style='font-family:Arial;mso-bidi-font-family:"Times New Roman"'><o:p></o:p></span></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>прототип (схема формальных параметров и
результата) внешней функции различна для разных типов итераторов. Для <b
style='mso-bidi-font-weight:normal'>foreach</b> – указатель имеет вид <b
style='mso-bidi-font-weight:normal'><span style='mso-spacerun:yes'> </span>void
(*<span lang=EN-US style='mso-ansi-language:
EN-US'>pf</span>)(<span lang=EN-US
style='mso-ansi-language:EN-US'>void</span>*), </b>для<b style='mso-bidi-font-weight:
normal'><a name="m26"> firstthat</b> – <b style='mso-bidi-font-weight:normal'><a name="m27">int (*<span lang=EN-US style='mso-ansi-language:
EN-US'>pf</span>)(<span lang=EN-US
style='mso-ansi-language:EN-US'>void</span>*)</b>, для итераторов, использующих
сравнение – <b style='mso-bidi-font-weight:normal'><a name="m28">int (*<span lang=EN-US style='mso-ansi-language:
EN-US'>cmp</span>)(<span lang=EN-US
style='mso-ansi-language:EN-US'>void</span>*,</b><b style='mso-bidi-font-weight:
normal'><a name="m29"><span lang=EN-US style='mso-ansi-language:EN-US'>void</span>*)</b>. </p>

<p class=a0><span lang=EN-US style='font-size:12.0pt;mso-bidi-font-size:10.0pt;
font-family:"Times New Roman CYR";mso-bidi-font-family:"Times New Roman";
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//------------------------------------------------------93-04.cpp</p>

<p class=a0>//----- Итераторы foreach, firstthat и поиска минимального для
списка</p>

<p class=a0><span style='mso-spacerun:yes'> </span>struct list { list
*next;<span style='mso-spacerun:yes'>                   </span><span
style='mso-tab-count:1'>          </span>// Указатель на следующий</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void *pdata; };<span
style='mso-spacerun:yes'>                               </span><span
style='mso-tab-count:1'>        </span>// Указатель на данные</p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Итератор: для
каждого элемента списка</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void ForEach(list *pv, void (*pf)(void*) ) {<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (; pv !=NULL; pv = pv-&gt;next)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>(*pf)(pv-&gt;pdata);</p>

<p class=a0><span style='mso-spacerun:yes'> </span>}</p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Итератор: поиск
первого в списке по условию</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void *FirstThat(list *pv, int (*pf)(void*)) {<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (; pv !=NULL; pv = pv-&gt;next)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>if
((*pf)(pv-&gt;pdata)) return pv -&gt;pdata;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>return NULL; }</p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Итератор: поиск
минимального в списке</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void *FindMin(list *pv, int (*pf)(void*
,void*))<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ list *pmin;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for ( pmin=pv; pv !=NULL; pv = pv-&gt;next)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>if ((*pf)(pv-&gt;pdata ,pmin-&gt;pdata)
&lt;0) pmin=pv;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>return pmin; }</p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Примеры
использования итератора ------------------</p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Функция вывода
строки</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void print(void *p) {
puts((char*)p); }</p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Функция проверки :
длины строки &gt;5</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int bigstr(void *p) { return strlen((char*)p )
&gt; 5; }<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>//----- Функция сравнения строк по
длине</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int scmp(void *p1, void *p2)</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>{ return strlen((char*)p1)- strlen((char*)p2);
}<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>//----- Вызов итераторов для
статического списка,</p>

<p class=a0><span style='mso-spacerun:yes'> </span>// содержащего указатели на
строки</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>list a1={NULL,&quot;aaaa&quot;},
a2={&amp;a1,&quot;bbbbbb&quot;}, a3={&amp;a2,&quot;ccccc&quot;}, *PH=&amp;a3;</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span style='mso-spacerun:yes'> </span>//----- Итератор сортировки
для массива указателей</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void Sort(void **pp, int
(*pf)(void*,void*))</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>{ int i,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>do<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (k=0,i=1; pp[i] !=NULL; i++)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>if (
(*pf)(pp[i-1],pp[i])&gt;=0)<span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:1'>           </span>// вызов функции сравнения</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>{ void *q;<span
style='mso-spacerun:yes'>                            </span><span
style='mso-tab-count:2'>              </span>// перестановка указателей</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>k++; q = pp[i-1];
pp[i-1] = pp[i]; pp[i] = q;</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}</p>

<p class=a0><span style='mso-spacerun:yes'> </span>while(k); }</p>

<p class=a0><span style='mso-spacerun:yes'> </span>// Пример вызова итератора
сортировки для массива</p>

<p class=a0><span style='mso-spacerun:yes'> </span>// указателей на целые
переменные</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int cmp_int(void *p1, void
*p2)</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>{ return *(int*)p1-*(int*)p2; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int b1=5, b2=6, b3=3, b4=2;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void *PP[] = {&amp;b1, &amp;b2, &amp;b3,
&amp;b4, NULL};<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main()<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ char *pp;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>ForEach(PH,print);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>pp = (char*) FirstThat(PH,bigstr);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (pp !=NULL) puts(pp);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>pp = (char*) FindMin(PH,scmp);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (pp !=NULL) puts(pp);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>Sort(PP,cmp_int);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (int i=0; PP[i]!=NULL;i++) printf(&quot;%d
&quot;,*(int*)PP[i]);<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>puts(&quot;&quot;);}</p>

<a name="lr13"><h3>Лабораторный практикум</h3>

<p class=a>Преобразовать функцию сортировки с использованием массивов (<b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>b</span></b>), списков (<b style='mso-bidi-font-weight:normal'><a name="m30">6.3</b>),
деревьев (<b style='mso-bidi-font-weight:normal'><a name="m31">8.4, 8.5</b>) в итератор.
Проверить его работу на двух структурах данных содержащих указатели на
различные типы (например, целые и строки). Массив преобразовать в массив
указателей.</p>

<h3>Головоломка</h3>

<p class=a>Результат здесь очевиден, потому что не может быть другим. Будет
выведена строка &quot;<span lang=EN-US style='mso-ansi-language:EN-US'>I</span>'<span
lang=EN-US style='mso-ansi-language:EN-US'>m</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>foo</span>&quot; или значение 6.
Значительно труднее объяснить<span lang=EN-US style='mso-ansi-language:EN-US'>:<o:p></o:p></span></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>что такое <b style='mso-bidi-font-weight:normal'><a name="m32"><span
lang=EN-US style='mso-ansi-language:EN-US'>P</span> - </b>функция,
указатель<span style='mso-spacerun:yes'>  </span>на функцию? Если функция, то
где у нее определения формальных параметров и результата и что она делает, если
указатель - то где обращение по нему;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>где находится операция, по которой на самом деле
производится вызов функции <b style='mso-bidi-font-weight:normal'><a name="m33"><span
lang=EN-US style='mso-ansi-language:EN-US'>foo</span></b><span lang=EN-US> </span>и
<b style='mso-bidi-font-weight:normal'><a name="m34"><span lang=EN-US style='mso-ansi-language:
EN-US'>inc</span></b>.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------93-05.cpp</p>

<p class=a0>//------------------------------------------------------- 1</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void (
*P1(void(*ff)(void)))(void) { return ff; }</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void foo1(void){ printf(&quot;I'm foo\n&quot;);
}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main1(){(*P1(foo1))();}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
2<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int ( *P2(int(*ff)(int)))(int) { return ff; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int inc2(int n){ return n+1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main2(){
printf(&quot;%d\n&quot;,(*P2(inc2))( 5 ));}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
3<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>typedef void (*PF3)(void);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>PF3 P3(PF3 ff) { return ff; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void foo3(void){ printf(&quot;I'm
foo\n&quot;);; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main3(){(*P3(foo3))();}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
4<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>typedef int (*PF4)(int);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>PF4 P4(PF4 ff) { return ff; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int inc4(int n){ return n+1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main4(){ printf(&quot;%d\n&quot;,(*P4(inc4))(
7 ));<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

</div>

</body>

</html>
