<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="091.files/editdata.mso">
<title>9.1. Биты, байты, слова</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>www.PHILka.RU</o:Author>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>268</o:TotalTime>
  <o:Created>2008-06-03T14:03:00Z</o:Created>
  <o:LastSaved>2008-06-03T14:03:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>5828</o:Words>
  <o:Characters>33226</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>276</o:Lines>
  <o:Paragraphs>77</o:Paragraphs>
  <o:CharactersWithSpaces>38977</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Courier New CYR";
	panose-1:2 7 3 9 2 2 5 2 4 4;
	mso-font-charset:204;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:64.35pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:-18.0pt;
	mso-pagination:widow-orphan;
	mso-list:l2 level1 lfo1;
	tab-stops:42.55pt list 64.35pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:0cm;
	margin-right:32.9pt;
	margin-bottom:0cm;
	margin-left:5.0cm;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{mso-style-name:стихи;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.1, li.1, div.1
	{mso-style-name:эпиграф1;
	mso-style-parent:эпиграф;
	margin-top:0cm;
	margin-right:9.35pt;
	margin-bottom:0cm;
	margin-left:9.0cm;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("091.files/header.htm") fs;
	mso-footnote-continuation-separator:url("091.files/header.htm") fcs;
	mso-endnote-separator:url("091.files/header.htm") es;
	mso-endnote-continuation-separator:url("091.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-even-header:url("091.files/header.htm") eh1;
	mso-header:url("091.files/header.htm") h1;
	mso-even-footer:url("091.files/header.htm") ef1;
	mso-footer:url("091.files/header.htm") f1;
	mso-first-header:url("091.files/header.htm") fh1;
	mso-first-footer:url("091.files/header.htm") ff1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:14771863;
	mso-list-type:simple;
	mso-list-template-ids:-55540120;}
@list l0:level1
	{mso-level-start-at:0;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:57.2pt;
	mso-level-number-position:left;
	margin-left:57.2pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";}
@list l1
	{mso-list-id:350301737;
	mso-list-template-ids:1141246422;}
@list l1:level1
	{mso-level-start-at:9;
	mso-level-tab-stop:26.25pt;
	mso-level-number-position:left;
	margin-left:26.25pt;
	text-indent:-26.25pt;}
@list l1:level2
	{mso-level-text:"%1\.%2\.";
	mso-level-tab-stop:26.25pt;
	mso-level-number-position:left;
	margin-left:26.25pt;
	text-indent:-26.25pt;}
@list l1:level3
	{mso-level-text:"%1\.%2\.%3\.";
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	margin-left:36.0pt;
	text-indent:-36.0pt;}
@list l1:level4
	{mso-level-text:"%1\.%2\.%3\.%4\.";
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	margin-left:36.0pt;
	text-indent:-36.0pt;}
@list l1:level5
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.";
	mso-level-tab-stop:54.0pt;
	mso-level-number-position:left;
	margin-left:54.0pt;
	text-indent:-54.0pt;}
@list l1:level6
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.";
	mso-level-tab-stop:54.0pt;
	mso-level-number-position:left;
	margin-left:54.0pt;
	text-indent:-54.0pt;}
@list l1:level7
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.";
	mso-level-tab-stop:54.0pt;
	mso-level-number-position:left;
	margin-left:54.0pt;
	text-indent:-54.0pt;}
@list l1:level8
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.";
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	margin-left:72.0pt;
	text-indent:-72.0pt;}
@list l1:level9
	{mso-level-text:"%1\.%2\.%3\.%4\.%5\.%6\.%7\.%8\.%9\.";
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	margin-left:72.0pt;
	text-indent:-72.0pt;}
@list l2
	{mso-list-id:1628194852;
	mso-list-type:hybrid;
	mso-list-template-ids:-964799380 -1450833310 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-style-link:список;
	mso-level-text:\F0B7;
	mso-level-tab-stop:64.35pt;
	mso-level-number-position:left;
	margin-left:64.35pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Сетка таблицы";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
  <o:regrouptable v:ext="edit">
   <o:entry new="1" old="0"/>
   <o:entry new="2" old="1"/>
   <o:entry new="3" old="0"/>
  </o:regrouptable>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2 style='margin-left:26.25pt;text-indent:-26.25pt;mso-list:l1 level2 lfo3;
tab-stops:list 26.25pt'><![if !supportLists]>
<span style='mso-list:Ignore; mso-fareast-font-family:Arial CYR; mso-bidi-font-family:Arial CYR'>9.1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><![endif]>Биты,
байты, машинные слова</h2>

<p class=a>Основы внутреннего представления данных в компьютере мы уже
проходили (см. <b style='mso-bidi-font-weight:normal'><a name="m1">1.3). </b>Единство этого
представления состоит в том, что все они строятся на основе машинных слов (или
байтов). Пока мы используем определенные в языке операции, присущие этим типам
данных (например, операцию сложения целых переменных или косвенное обращение по
указателю<span style='display:none;mso-hide:all'>ределенные в языке операции,
присущие этим типам данных ()ятся на основе машинных слов ()</span>),
внутренние представление данных нам безразлично. Но иногда нам приходится
«лезть внутрь» и работать с ними на уровне отдельных двоичных разрядов. Примеры
такого программирования:</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>упаковка данных, архивирование. Естественно
уплотнение данных производить с точностью не до байта, а до бита;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>алгоритмы сортировок и структуры данных,
использующие элементы внутреннего представления хранимых данных: поразрядные
сортировки, кодовые деревья;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>моделирование машинной арифметики. Если нас не
устраивает точность представления данных, принятая в компьютере, мы сможем
программно смоделировать данные более высокой точности. При этом можно
пользоваться разными формами их представления, в том числе принятыми двоичными
форматами данных;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>работа с растрами, битовыми картами (<b
style='mso-bidi-font-weight:normal'>bitmap</b>). Например, для контроля
свободного пространства на диске файловая система часто использует карту памяти
– массив байтов, каждый разряд которого определяется состояние отдельного
блока: 0 – свободен, 1 – занят.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m2">Машинные слова в Си. </b>Базовые
типы данных целых чисел реализованы в машинных словах различной размерности,
поэтому для задания в программе машинных слов нужно просто определить ту или
иную целую переменную. Тип данных <b style='mso-bidi-font-weight:normal'><a name="m3"><span
lang=EN-US style='mso-ansi-language:EN-US'>char</span><span lang=EN-US> </span></b>всегда
соответствует байту, <b style='mso-bidi-font-weight:normal'><a name="m4"><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span> – </b>стандартной размерности
машинного слова, обрабатываемого процессором, <b style='mso-bidi-font-weight:
normal'><a name="m5"><span lang=EN-US style='mso-ansi-language:EN-US'>long</span> – </b>машинному
слову увеличенной размерности по отношению к стандартному (обычно двойной).
Операция <b style='mso-bidi-font-weight:normal'><a name="m6"><span lang=EN-US
style='mso-ansi-language:EN-US'>sizeof</span>, </b>определяющая размерность
любого типа данных в байтах, может быть использована и для «измерения» машинных
слов, количество двоичных разрядов в машинном слове определяется выражением <b
style='mso-bidi-font-weight:normal'>8*sizeof(тип данных).</b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long</span><span
style='mso-tab-count:1'>      </span><span lang=EN-US style='mso-ansi-language:
EN-US'>vv</span>;<span style='mso-tab-count:5'>                                                         </span>//
Машинное слово двойной длины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for(int i=0;
i&lt;8*sizeof(long); i++)<span style='mso-tab-count:1'>   </span><span
style='mso-tab-count:2'>                        </span>// </span>Количество<span
style='mso-ansi-language:EN-US'> <span lang=EN-US>разрядов </span></span>в<span
style='mso-ansi-language:EN-US'> <span lang=EN-US>long<o:p></o:p></span></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>{ … <span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span> … }<span style='mso-tab-count:4'>                                             </span>//
Цикл поразрядной обработки слова</p>

<h3>Поразрядные операции и их интерпретация<span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></h3>

<p class=a>Операции, которые выполняют различные операции (в основном,
логические) над отдельными разрядами машинного слова, называются поразрядными. В
стандартной классификации операций по приоритетам они относятся к различным
группам. В качестве операндов у них часто используются константы, именуемые
масками.<b style='mso-bidi-font-weight:normal'><a name="m7"> Маска – это константа, с
определенной расстановкой единичных и нулевых разрядов. </b>Естественно, коль
скоро речь идет о двоичном представлении, то наиболее удобным является
использование эквивалента в виде шестнадцатеричных констант.</p>

<p class=a>Прежде всего, необходимо вспомнить основные отношения размерностей (<b
style='mso-bidi-font-weight:normal'>1.3</b>): одна шестнадцатеричная цифра
кодирует значения четырех двоичных разрядов (тетрада), байт представляется
двумя цифрами. Как правило, в маске устанавливаются в 1 отдельные разряды, либо
группы рядом стоящих разрядов (битовые поля):</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a5><span style='mso-ansi-language:RU'>0</span><span lang=EN-US>x</span><span
style='mso-ansi-language:RU'>1</span><span lang=EN-US>F</span><span
style='mso-ansi-language:RU'><span style='mso-tab-count:1'> </span> -<span
style='mso-spacerun:yes'>  </span>0000 0000 0001 1111 (разряды 0..5 в 1)<o:p></o:p></span></p>

<p class=a5><span style='mso-ansi-language:RU'>0</span><span lang=EN-US>x</span><span
style='mso-ansi-language:RU'>3</span><span lang=EN-US>C</span><span
style='mso-ansi-language:RU'>0 - 0000 0011 1100 0000 (разряды 6..9 в 1)<o:p></o:p></span></p>

<p class=a5><span style='mso-ansi-language:RU'>0</span><span lang=EN-US>x</span><span
style='mso-ansi-language:RU'>1<span style='mso-tab-count:1'> </span> -<span
style='mso-spacerun:yes'>  </span>0000 0000 0000 0001 (младший разряд)<o:p></o:p></span></p>

<p class=a4>Часто требуется, чтобы маска была программируемой, задаваемой во
время работы программы. В этом случае нужно организовать процесс «пробегания»
единичного бита по заданному полю.</p>

<p class=a>Образно говоря, машинное слово – это массив двоичных разрядов, и
алгоритмы работы с машинными словами в первом приближении аналогичны
алгоритмам, работающим с массивами. Но с точки зрения возможных операций все
обстоит с точностью до «наоборот». В «джентльменском наборе» команд процессора
отсутствую команды прямой адресации битов. Взамен их используются <b
style='mso-bidi-font-weight:normal'>поразрядные </b>операции, выполняющие одну
и ту же логическую операцию или операцию перемещения над всеми разрядами
машинного слова одновременно. Другое их название – <b style='mso-bidi-font-weight:
normal'><a name="m8">машинно-ориентированные операции </b>– отражает тот факт, что они
поддерживаются в любой системе команд и любом языке Ассемблера. К ним
относятся: </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><span style='mso-spacerun:yes'> </span>&quot;|&quot;
-поразрядная операция <b style='mso-bidi-font-weight:normal'><a name="m9">ИЛИ</b> </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><span style='mso-spacerun:yes'> </span>&quot;&amp;&quot;
-поразрядная операция <b style='mso-bidi-font-weight:normal'><a name="m10">И</b>; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><span style='mso-spacerun:yes'> </span>&quot;^&quot;
-поразрядная операция <b style='mso-bidi-font-weight:normal'><a name="m11">исключающее ИЛИ</b>;
</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><span style='mso-spacerun:yes'> </span>&quot;~&quot;
-поразрядная операция <b style='mso-bidi-font-weight:normal'><a name="m12">инверсия</b>; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><span style='mso-spacerun:yes'> </span>&quot;&gt;&gt;&quot;
-операция <b style='mso-bidi-font-weight:normal'><a name="m13">сдвига вправо</b>; </p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><span style='mso-spacerun:yes'> </span>&quot;&lt;&lt;&quot;
-операция <b style='mso-bidi-font-weight:normal'><a name="m14">сдвига влево</b>. </p>
<p class=a1>&nbsp;</p>

<p class=a0 align="center">
<img border="0" src="Images/091-01.gif" width="427" height="206"><p></p>

<p class=a align=center style='text-align:center;text-indent:0cm'><b
style='mso-bidi-font-weight:normal'>Рис.91-1. Схема выполнения поразрядных
операций<o:p></o:p></b></p>

<p class=a>Формальная сторона логических операций всем известна. Однако
программиста интересует содержательная интерпретация поразрядных операций,
которая позволяет выполнять различные действия с отдельными разрядами и их
диапазонами – <b style='mso-bidi-font-weight:normal'><a name="m15">битовыми полями –</b>
устанавливать, очищать, выделять, инвертировать. Для этого используют
поразрядные операции, в которых первый операнд является обрабатываемым машинным
словом. Второй операнд, как правило, определяет те разряды в первом операнде,
которые изменяются при выполнении операции и в этом случае называется <b
style='mso-bidi-font-weight:normal'>маской</b>. Если маска жестко задана в
программе, то является<span style='mso-spacerun:yes'>  </span>просто битовой
константой, представленной в шестнадцатеричной системе. </p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m16">Поразрядная операция И. </b>По
отношению ко второму операнду – маске логическая операция <b style='mso-bidi-font-weight:
normal'><a name="m17">И</b> сохраняет (выделяет) те разряды первого операнда, которые
соответствуют единичным разрядам маски, и безусловно сбрасывает в 0 разряды
результата, которые соответствуют в маске заполнены нулями. Операция так и
называется -<span style='mso-spacerun:yes'>  </span><b style='mso-bidi-font-weight:
normal'><a name="m18">выделение разрядов по маске.<o:p></o:p></b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a5><span lang=EN-US>x x x x x x x x<span style='mso-spacerun:yes'> 
</span>- операнд</span></p>

<p class=a5><span lang=EN-US>0 0 1 1 1 0 0 0<span style='mso-spacerun:yes'> 
</span>- маска</span></p>

<p class=a5><span lang=EN-US>0 0 x x x 0 0 0<span style='mso-spacerun:yes'> 
</span>- результат</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>b</span> = a
&amp;<span style='mso-spacerun:yes'>  </span>0x0861;<span style='mso-tab-count:
1'>            </span>// Выделить разряды 0,5,6,11</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>b</span> = a &amp;
<span style='mso-spacerun:yes'> </span>0x00F0;<span style='mso-tab-count:1'>            </span>//
Выделить разряды с 4 по 7 </p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>//
(разряды второй цифры справа)</p>

<p class=a4>Выделение разрядов по маске может сопровождаться проверкой их
значений.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if</span> ((<span
lang=EN-US style='mso-ansi-language:EN-US'>a</span> &amp; 0<span lang=EN-US
style='mso-ansi-language:EN-US'>x</span>100)!=0) …<span style='mso-tab-count:
1'>      </span>// Установлен ли 8-ой разряд –</p>

<p class=a0 style='margin-left:72.0pt;text-indent:36.0pt'>// (младший разряд
второго по счету байта)</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m19">Поразрядная операция ИЛИ. </b>По
отношению ко второму операнду – маске логическая операция <b style='mso-bidi-font-weight:
normal'><a name="m20">ИЛИ</b> сохраняет те разряды первого операнда, которые соответствуют
нулевым разрядам маски, и безусловно устанавливает в 1 разряды результата,
которые соответствуют единичным разряды маски. Операция так и называется -<span
style='mso-spacerun:yes'>  </span><b style='mso-bidi-font-weight:normal'><a name="m21">установка
разрядов по маске.<o:p></o:p></b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a5><span
style='mso-spacerun:yes; mso-ansi-language:RU'> </span><span lang=EN-US>x</span><span
lang=EN-US style='mso-ansi-language:RU'> </span><span lang=EN-US>x</span><span
lang=EN-US style='mso-ansi-language:RU'> </span><span lang=EN-US>x</span><span
lang=EN-US style='mso-ansi-language:RU'> </span><span lang=EN-US>x</span><span style='mso-spacerun:yes; mso-ansi-language:RU'>  </span><span
lang=EN-US>x</span><span lang=EN-US style='mso-ansi-language:RU'> </span><span
lang=EN-US>x</span><span lang=EN-US style='mso-ansi-language:RU'> </span><span
lang=EN-US>x</span><span lang=EN-US style='mso-ansi-language:RU'> </span><span
lang=EN-US>x</span><span style='mso-ansi-language:RU'><span style='mso-tab-count:
1'> </span><span style='mso-tab-count:1'>    </span>- операнд<o:p></o:p></span></p>

<p class=a5><span style='mso-ansi-language:RU'><span
style='mso-spacerun:yes'> </span>0 0 1 1<span style='mso-spacerun:yes'> 
</span>1 0 0 0<span style='mso-spacerun:yes'>  </span><span style='mso-tab-count:
1'>   </span>- маска<o:p></o:p></span></p>

<p class=a5><span
style='mso-spacerun:yes; mso-ansi-language:RU'> </span><span lang=EN-US>x</span><span
lang=EN-US style='mso-ansi-language:RU'> </span><span lang=EN-US>x</span><span
style='mso-ansi-language:RU'> 1 1<span style='mso-spacerun:yes'>  </span>1 </span><span
lang=EN-US>x</span><span lang=EN-US style='mso-ansi-language:RU'> </span><span
lang=EN-US>x</span><span lang=EN-US style='mso-ansi-language:RU'> </span><span
lang=EN-US>x</span><span style='mso-ansi-language:RU'><span style='mso-tab-count:
2'>     </span>- результат<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>a |= 0x0861;<span style='mso-tab-count:1'>      </span>//
Установить в 1 разряды 0,5,6,11</p>

<p class=a0>a |= 0x00F0;<span style='mso-tab-count:1'>      </span>//
Установить в 1 разряды с 4 по 7 </p>

<p class=a0><span style='mso-tab-count:2'>                        </span>//
(разряды второй цифры справа)</p>

<p class=a4>Операция <b style='mso-bidi-font-weight:normal'><a name="m22">ИЛИ</b> используется
также для объединения значений непересекающихся битовых полей (логическое
сложение), которые предварительно выделяются с помощью операции И.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int
a=0x5555,b=0x4444,c;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>c = a &amp; 0xFFF0
| b &amp; 0xF;<span style='mso-tab-count:1'>          </span>// c = «aaab»<o:p></o:p></span></p>

<p class=a4>В переменной <b style='mso-bidi-font-weight:normal'><a name="m23"><span
lang=EN-US style='mso-ansi-language:EN-US'>c</span><span lang=EN-US> </span></b>объединяются
битовые поля, выделенные из <b style='mso-bidi-font-weight:normal'><a name="m24"><span
lang=EN-US style='mso-ansi-language:EN-US'>a</span> – </b>три старшие
шестнадцатеричные цифры (12 разрядов) и из <b style='mso-bidi-font-weight:normal'><a name="m25"><span
lang=EN-US style='mso-ansi-language:EN-US'>b</span> – </b>младшая
шестнадцатеричная цифра (4 разряда).</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>c &lt;&lt;=1; <span lang=EN-US style='mso-ansi-language:EN-US'>c</span>
|= <span lang=EN-US style='mso-ansi-language:EN-US'>b</span> &amp; 1; <span
lang=EN-US style='mso-ansi-language:EN-US'>b</span> &gt;&gt;=1;</p>

<p class=a4>Содержимое слова <b style='mso-bidi-font-weight:normal'><a name="m26">с </b>сдвигается
влево, в результате чего «освобождается место» в самом правом его разряде. Затем
операция <b style='mso-bidi-font-weight:normal'><a name="m27">И</b> выделяет младший разряд
из машинного слова <b style='mso-bidi-font-weight:normal'><a name="m28"><span lang=EN-US
style='mso-ansi-language:EN-US'>b</span>, </b>который затем переносится в
освободившийся разряд <b style='mso-bidi-font-weight:normal'><a name="m29"><span lang=EN-US
style='mso-ansi-language:EN-US'>b</span><span lang=EN-US> </span></b>с помощью
операции ИЛИ.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m30">Операция поразрядной
ИНВЕРСИИ. </b>Поразрядная инверсия меняет значение каждого разряда машинного
слова на противоположное (инвертирует). Операция И в сочетании с
инвертированной маской-константой производит <b style='mso-bidi-font-weight:
normal'><a name="m31">очистку разрядов по маске.</b></p>

<p class=MsoNormal style='text-align:justify'><b style='mso-bidi-font-weight:
normal'><a name="m32"><span style='font-family:"Courier New CYR";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></b></p>

<p class=a0>a &amp;= ~0x0861;<span style='mso-tab-count:1'>   </span>//
Очистить разряды 0,5,6,11, остальные сохранить</p>

<p class=a0>a &amp;= ~0x00F0;<span style='mso-tab-count:1'>  </span>// Очистить
разряды с 4 по 7, остальные сохранить </p>

<p class=a0><span style='mso-tab-count:2'>                        </span>//
(разряды второй цифры справа)</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m33">Поразрядная операция
«исключающее ИЛИ».</b> Поразрядная операция «исключающее ИЛИ» выполняет над
парами разрядов в операндах логическую операцию <b style='mso-bidi-font-weight:
normal'><a name="m34">исключающее или</b>, называемую также <b style='mso-bidi-font-weight:
normal'><a name="m35">неравнозначность</b> или <b style='mso-bidi-font-weight:normal'><a name="m36">сложение
по модулю 2</b> - результат равен 1 при несовпадении значений битов. По
отношению ко второму операнду – маске логическая операция «исключающее ИЛИ»
сохраняет те разряды первого операнда, которые соответствуют нулевым разрядам
маски, и инвертирует те разряды результата, которые соответствуют единичным.
Операция так и называется -<span style='mso-spacerun:yes'>  </span><b
style='mso-bidi-font-weight:normal'>инвертирование разрядов по маске.<o:p></o:p></b></p>

<p class=MsoNormal style='text-align:justify'><span style='mso-tab-count:1'>                </span></p>

<p class=a0>a ^= 0x0861;<span style='mso-spacerun:yes'>   </span><span
style='mso-tab-count:1'>   </span>// Инвертировать разряды 0,5,6,11</p>

<p class=a0>a ^= 0x00F0;<span style='mso-spacerun:yes'>   </span><span
style='mso-tab-count:1'>  </span>// Инвертировать разряды с 4 по 7</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>         </span><span style='mso-tab-count:1'>   </span>//
(разряды второй цифры справа)<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m37">Операция СДВИГ ВЛЕВО.</b>
Поразрядная операция «сдвиг влево»<span style='mso-spacerun:yes'> 
</span>переносит содержимое каждого разряда первого операнда на то количество
разрядов влево, которое задано вторым операндом, освобождающиеся разряды справа
заполняются нулями. Результат операции содержит сдвинутое машинное слово, а
сами операнды не изменяется. Естественно, что от программиста не требуется
вручную интерпретировать перемещение разрядов машинного слова. Каждое
перемещение имеет свою содержательную интерпретацию.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>a &lt;&lt;= 4; <span style='mso-tab-count:1'>           </span>//
сдвиг влево на одну шестнадцатеричную цифру; </p>

<p class=a0>a = 1&lt;&lt;n; <span style='mso-tab-count:1'>         </span>//
установить 1 в n-й разряд машинного слова. </p>

<p class=a4>Операции сдвига часто используются для «подгонки» групп двоичных
разрядов к требуемому их местоположению в машинном слове. После чего в дело
вступают операции <b style='mso-bidi-font-weight:normal'><a name="m38">И, ИЛИ</b> для
выделения и изменения значений полей.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long</span><span
lang=EN-US> <span style='mso-spacerun:yes'> </span></span><span lang=EN-US
style='mso-ansi-language:EN-US'>a</span>=0<span lang=EN-US style='mso-ansi-language:
EN-US'>x</span>12345678;<span style='mso-tab-count:1'>                  </span>// Поменять местами две младшие
цифры</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long b = a &amp;
~0xFF | (a &gt;&gt;4) &amp; 0xF | (a &lt;&lt;4) &amp; 0xF0; <o:p></o:p></span></p>

<p class=a4>Первая операция <b style='mso-bidi-font-weight:normal'><a name="m39">И</b>
очищает две младшие шестнадцатеричные цифры (8 разрядов), вторая операция<span
style='mso-spacerun:yes'>  </span>перемещает первую цифру на место нулевой (и
выделяет), третья операция<span style='mso-spacerun:yes'>  </span>перемещает
нулевую цифру на место первой, после чего все поля объединяются по <b
style='mso-bidi-font-weight:normal'>ИЛИ</b>.</p>

<p class=a>У операции сдвига влево есть еще одна интерпретация. Если
рассматривать машинное слово как целое без знака, то однократный сдвиг
увеличивает его значение в 2 раза, двукратный - в 4 раза, n-кратный - в <span
style='mso-spacerun:yes'> </span><b style='mso-bidi-font-weight:normal'><a name="m40">2<sup>n</sup></b>.
В таком виде, например, умножение числа на 10 можно представить так: </p>

<p class=a0><span style='mso-tab-count:1'>                        </span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>a*10 ... a*(8+2)
... 8*a + 2*a ... (a&lt;&lt;3) + (a&lt;&lt;1)<o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m41">Операция<span style='mso-ansi-language:EN-US'> </span>СДВИГ<span style='mso-ansi-language:EN-US'> </span>ВПРАВО<span lang=EN-US style='mso-ansi-language:
EN-US'>.</span></b><span lang=EN-US style='mso-ansi-language:EN-US'> </span>Поразрядная
операция «сдвиг вправо»<span style='mso-spacerun:yes'>  </span>имеет некоторые
особенности выполнения. По аналогии со сдвигом влево операция сдвига вправо на
n разрядов интерпретируется как целочисленное деление на <b style='mso-bidi-font-weight:
normal'><a name="m42">2<sup>n</sup></b>. При этом заполнение освобождающихся старших разрядов
производится таким образом, чтобы сдвиг соответствовал операции деления с
учетом формы представления целого. Для беззнакового целого заполнение должно
производиться нулями (<b style='mso-bidi-font-weight:normal'><a name="m43">логический сдвиг</b>),
а для целого со знаком - сопровождаться дублированием значения старшего
знакового разряда (<b style='mso-bidi-font-weight:normal'><a name="m44">арифметический сдвиг</b>).
В последнем случае отрицательное число при сдвиге останется отрицательным: </p>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=a0>int<span style='mso-tab-count:1'>         </span><span
style='mso-spacerun:yes'>   </span><span style='mso-tab-count:1'>         </span>n=0xFF00;<span
style='mso-tab-count:1'>        </span>n&gt;&gt;=4;<span style='mso-tab-count:
1'>  </span>// n=0xFFF0;</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>unsigned<span
style='mso-tab-count:1'>           </span>u=0xFF00;<span style='mso-tab-count:
1'>        </span>u&gt;&gt;=4;<span style='mso-tab-count:1'>  </span>//
u=0x0FF0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m45">Формирование маски в заданном
диапазоне разрядов. </b>Функция возвращает машинное слово - маску, в котором разряды
в заданном диапазоне установлены в 1 (динамическая маска). Для этого она
прогоняет маску единичного разряда по всему диапазону и выполняет операцию
установки разряда по маске (ИЛИ).</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----------------------------------------------------------------91-01.cpp</p>

<p class=a0>//--- Формирование маски в заданном диапазоне разрядов</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>long set_mask(int r0, int dn){<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>long m,v;<span
style='mso-spacerun:yes'>              </span><span style='mso-tab-count:1'>        </span>//
m - &quot; бегущий&quot; единичный разряд, v - маска</p>

<p class=a0><span style='mso-spacerun:yes'> </span>m = 1 &lt;&lt; r0;<span
style='mso-spacerun:yes'>           </span><span style='mso-tab-count:1'>      </span>//
Сдвинуть единичный разряд на r0 разрядов влево</p>

<p class=a0><span style='mso-spacerun:yes'> </span>for (v=0; dn!=0; dn--){ <span
style='mso-tab-count:1'>    </span>// Повторять dn раз</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span style='mso-tab-count:
1'>           </span>v |= m;<span style='mso-tab-count:2'>              </span>//
Установить очередной разряд из m в v</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
1'>      </span>m &lt;&lt;=1;}<span style='mso-tab-count:1'>           </span>//
Переместить единичный бит в следу ющий разряд</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>return v;}</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m46">Определение разрядности
целого числа. </b>Простейший способ – сдвигать беззнаковое целое вправо, <b
style='mso-bidi-font-weight:normal'><span style='mso-spacerun:yes'> </span></b>пока
оно не станет равным 0. Количество сдвигов – и есть его разрядность.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------91-0<span
lang=EN-US style='mso-ansi-language:EN-US'>2</span>.<span lang=EN-US
style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//----- Определение разрядности числа</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>wordlen</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>unsigned</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>long</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>vv</span>){</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (int i=0; vv!=0; i++, vv&gt;&gt;=1);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>;}</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m47">Подсчет количества единичных
разрядов. </b>При сдвиге вправо все биты числа будут последовательно находиться
в младшем разряде, из которого их нужно выделять с использованием операции И с
единичной маской.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------91-03.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//------ Подсчет количества единичных разрядов</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int what_is_1( unsigned long n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int i,s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (i=0,s=0; i &lt; sizeof(long) * 8; i++)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>{ if (n &amp; 1) s++; n
&gt;&gt;=1; }<span style='mso-spacerun:yes'>  </span><span style='mso-tab-count:
1'>    </span><span style='mso-tab-count:1'>            </span>// Проверить
младший разряд и сдвинуть слово</p>

<p class=a0><span style='mso-spacerun:yes'> </span>return s; }</p>

<h3>Алгоритмы поразрядной сортировки</h3>

<p class=a>В смысле идей поразрядные сортировки не несут ничего нового, они
базируются на известных алгоритмах, основанных на разделении (распределении).
Только вот само разделение основано на использовании двоичного представления
целых чисел.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m48">Поразрядная сортировка
разделением. </b>В идее рекурсивного разделения центральным является понятие
медианы – границы разделения на части «больше-меньше» (см.<b style='mso-bidi-font-weight:
normal'><a name="m49">7.2</b>). Если сортируется множество положительных (или беззнаковых)
целых, то таким «водоразделом» может выступать очередной разряд машинного слова
(разряды берутся в порядке убывания весов, т.е. от старшего к младшему). На
первом шаге массив делится на две части по значению старшего разряда: в левую
часть попадаю значения, содержащие в этом разряде 0 , в правую – содержащие 1.
Затем алгоритм выполняется рекурсивно по отношению к полученным частям, но уже
по следующему разряду и т.д. до самого младшего. Сама идея разделения полностью
скопирована из <b style='mso-bidi-font-weight:normal'><a name="m50">7.2: </b>индексы <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>j</span><span lang=EN-US> </span></b>движутся с
двух концов интервала к центру, оставляя после себя значения с разрядом, равным
0 слева, и равным 1 – справа. Когда оба движка «упираются» в элементы с
противоположными значениями разрядов, они меняют их местами.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//----------------------------------------------------------91-04.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//--------------- </span>Поразрядная<span
style='mso-ansi-language:EN-US'> </span>сортировка<span style='mso-ansi-language:
EN-US'> </span>разделением<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void<span
style='mso-tab-count:1'>       </span>bitsort(int A[],int a,int b, unsigned m){<o:p></o:p></span></p>

<p class=a0>int i;</p>

<p class=a0>if (a<span style='mso-spacerun:yes'>   </span>&gt;= b) return; <span
style='mso-tab-count:2'>                     </span><span style='mso-tab-count:
1'>            </span>// Интервал сжался в точку</p>

<p class=a0>if (m<span style='mso-spacerun:yes'>   </span>== 0) return; <span
style='mso-tab-count:2'>                    </span><span style='mso-tab-count:
1'>            </span>// Проверяемые разряды закончились</p>

<p class=a0>// Разделить массив на две части по значению разряда,</p>

<p class=a0>// установленного в маске m</p>

<p class=a0>int j,vv;<span style='mso-tab-count:2'>              </span><span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:3'>                                  </span>//
Цикл разделения массива<span style='mso-spacerun:yes'>  </span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=a, j=b;
i&lt;=j; ){<span style='mso-tab-count:1'>        </span><span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:1'>          </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if ((A[i] &amp; m) ==0)<span
style='mso-tab-count:2'>                       </span>// </span>Слева<span
style='mso-ansi-language:EN-US'> </span>с<span style='mso-ansi-language:EN-US'>
</span>разрядом<span lang=EN-US style='mso-ansi-language:EN-US'> =0 <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>{ i++; continue;
}<span style='mso-tab-count:1'>            </span>// пропустить</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if ((A[j] &amp; m)
!=0)<span style='mso-tab-count:2'>                        </span>// Справа с
разрядом =1 </p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>{ j--; continue; }<span
style='mso-tab-count:1'>  </span></span><span style='mso-tab-count:1'>            </span><span
lang=EN-US style='mso-ansi-language:EN-US'>// </span>пропустить<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>vv = A[i]; A[i]=A[j]; A[j]=vv;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>i++, j--;<span
style='mso-tab-count:4'>                                      </span>// Обмен и
сдвиг границ</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>bitsort(A,a,j,m
&gt;&gt;1);<span style='mso-tab-count:3'>                               </span>//
</span>Рекурсивный<span style='mso-ansi-language:EN-US'> </span>вызов<span
lang=EN-US style='mso-ansi-language:EN-US'><span style='mso-tab-count:1'>   </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>bitsort(A,i,b,m
&gt;&gt;1); }<span style='mso-tab-count:3'>                             </span>//
</span>для<span style='mso-ansi-language:EN-US'> </span>следующего<span
style='mso-ansi-language:EN-US'> </span>разряда</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>Для самого первого вызова рекурсивной функции для всего исходного массива
необходимо определить старший значащий разряд в его элементах. Для этого ищется
максимальный элемент и для него определяется маска единичного разряда <b
style='mso-bidi-font-weight:normal'>m</b>, пробегающая последовательно все
разряды справа налево до тех пор, пока она не превысит значение этого
максимума.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void mainsort(int
B[], int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int max,i;
unsigned m;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for(max = 0, i=0;
i&lt; n; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (B[i] &gt; max) max = B[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>m</span>=1; <span lang=EN-US
style='mso-ansi-language:EN-US'>m</span> &lt; <span lang=EN-US
style='mso-ansi-language:EN-US'>max</span>; <span lang=EN-US style='mso-ansi-language:
EN-US'>m</span> &lt;&lt;= 1);<span style='mso-tab-count:2'>                 </span>//
Единичная маска, превышающая максимум</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>m</span>
&gt;&gt;=1;<span style='mso-tab-count:4'>                                                </span>//
Старший разряд разделения</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>bitsort</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>B</span>,0,<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>-1,<span lang=EN-US style='mso-ansi-language:
EN-US'>m</span>); }</p>

<p class=a>Замечание: отрицательные значения вносят свои коррективы в связи с
особенностью их форм представления. Ведь поразрядная сортировка фактически
работает в формате беззнакового представления. Дополнительный код (см.<b
style='mso-bidi-font-weight:normal'>1.3</b>) отображает отрицательные числа в
область больших беззнаковых (положительных), переворачивая диапазон
представления. В соответствии с этим отрицательные числа будут располагаться
после положительных, причем отсортированными в обратном порядке. И, наконец, в
качестве первого разряда разделения нужно брать старший (знаковый) разряд.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>m</span>=1,<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>=0; <span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>&lt;8*<span lang=EN-US style='mso-ansi-language:EN-US'>sizeof</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>int</span>)-1; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++; <span lang=EN-US style='mso-ansi-language:
EN-US'>m</span> &lt;&lt;= 1);<span style='mso-tab-count:1'>       </span>// Двигать
до старшего (знакового) разряда</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m51">Лексикографическая
поразрядная сортировка</b>. Любое распределение при использовании внутреннего
(двоичного) представления целых приводит к разделению данных по двум
направлениями в соответствии со значением очередного разряда. Поэтому идея
лексикографического распределения (по символам, по цифрам или другим
составляющим) может быть применена к разрядам числа: они ведь тоже являются
двоичными цифрами (см. <b style='mso-bidi-font-weight:normal'><a name="m52">7.7</b>).
Соответствующий алгоритм можно переписать «один в один».</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------------------91-05.cpp</p>

<p class=a0>//----- Поразрядная лексикографическая сортировка</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void sort(int in[], int n)</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>{int m,i,max,i0,i1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int</span> *<span lang=EN-US style='mso-ansi-language:
EN-US'>v</span>0=<span lang=EN-US style='mso-ansi-language:EN-US'>new</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>int</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>];<span style='mso-tab-count:
3'>                                 </span>// Создать 2 «кармана»</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int *v1=new int[n];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (i=0, max=0; i&lt;n; i++)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span><span style='mso-tab-count:1'>      </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (in[i] &gt; max) max=in[i];<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>for (m=1; m&lt;=max; m &lt;&lt;=1){<span
style='mso-tab-count:2'>                 </span>// для каждого разряда, начиная
с младшего</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for
(i=i0=i1=0;i&lt;n;i++)<span style='mso-tab-count:2'>                 </span>//
распределить в 2 кармана по значению</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if ((in[i] &amp; m)==0)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>v</span>0[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>0++]=<span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>];<span style='mso-tab-count:1'>    </span>// очередного разряда
(двоичной цифры)</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>else </span><span style='mso-tab-count:
1'>     </span><span lang=EN-US style='mso-ansi-language:EN-US'>v1[i1++]=in[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for(i=0;i&lt;i0;i++)<span
style='mso-tab-count:3'>                          </span>// </span>соединить<span
style='mso-ansi-language:EN-US'> </span>карманы<span style='mso-ansi-language:
EN-US'> </span>первый<span lang=EN-US style='mso-ansi-language:EN-US'> - </span>второй<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>in[i]=v0[i];<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>for(i0=0;i&lt;n;i++,i0++)<span
style='mso-tab-count:2'>                  </span>// соединить карманы первый -
второй</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>in[i]=v1[i0];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>delete []v0; delete []v1;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a4><b
style='mso-bidi-font-weight:normal'>
<img border="0" src="Images/smile.jpg" width="40" height="41" align="left">Поразрядная распределяющая сортировка</b>. Рецепт:
возьмите идеи распределения по карманам, использования на каждом шаге
очередного двоичного разряда, но от старшего к младшему и слияния
последовательностей, то получите поразрядную распределяющую сортировку.
Парадокс в том, что получаемые в карманах последовательности не являются
упорядоченными, тем не менее, к ним применяется классическое слияние как для упорядоченных
последовательностей. Интуитивное объяснение всего происходящего: при слиянии
меньшие значения постепенно перемещаются вперед.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//---------------------------------------------------------------------91-06.cpp</p>

<p class=a0>//----- Поразрядная распределяющая сортировка</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void sort(int in[], int n)</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>{int m,i,max,i0,i1;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>int *v0=new int[n];<span
style='mso-tab-count:3'>                                 </span>// Создать 2
&quot;кармана&quot;</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int *v1=new int[n];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (i=0, max=0; i&lt;n; i++)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>if (in[i] &gt; max) max=in[i];<span
style='mso-tab-count:1'>                   </span>//
Определение максимального</p>

<p class=a0><span style='mso-spacerun:yes'> </span>for (m=1; m &lt;=max; m
&lt;&lt;=1);<span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:1'>        </span>// значащего разряда</p>

<p class=a0><span style='mso-spacerun:yes'> </span>for (m &gt;&gt;=1; m !=0; m
&gt;&gt;=1){<span style='mso-tab-count:2'>                </span>// По всем
разрядам от старшего</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for (i0=i1=0;
i0+i1 &lt; n; )<span style='mso-spacerun:yes'>      </span><span
style='mso-tab-count:1'>        </span>// Распределение по значению</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if ((in[i0+i1] &amp; m) ==0)<span
style='mso-spacerun:yes'>    </span>// </span>очередного<span style='mso-ansi-language:
EN-US'> </span>разряда<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>v0[i0] =
in[i0+i1], i0++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>else<span
style='mso-tab-count:3'>                              </span>// </span>по<span
style='mso-ansi-language:EN-US'> </span>карманам<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>v1[i1] =
in[i0+i1], i1++;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>v0[i0] = v1[i1] =
max+1;<span style='mso-tab-count:1'>  </span>// В каждый карман -
&quot;затычка&quot;</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (i0=i1=0; i0+i1 &lt; n; )<span
style='mso-tab-count:3'>                         </span>// </span>Обычное<span
style='mso-ansi-language:EN-US'> </span>слияние<span lang=EN-US
style='mso-ansi-language:EN-US'> <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (v0[i0] &lt; v1[i1])<span
style='mso-tab-count:2'>             </span>// по сравнению значений </p>

<p class=a0><span style='mso-tab-count:2'>                        </span>in[i0+i1]
= v0[i0], i0++;<span style='mso-tab-count:1'>    </span>// в последовательности</p>

<p class=a0><span style='mso-spacerun:yes'>    </span><span lang=EN-US
style='mso-ansi-language:EN-US'>else<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>in[i0+i1] = v1[i1],
i1++;<span style='mso-tab-count:1'>    </span>// max+1 </span>играет<span
style='mso-ansi-language:EN-US'> </span>роль<span style='mso-ansi-language:
EN-US'> </span>ограничителя<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>    </span>} delete []v0; delete []v1;}<o:p></o:p></span></p>

<p class=a0><span style='font-family:"Courier New"'><o:p></o:p></span></p>

<h3>Упаковка данных полями переменной длины</h3>

<p class=a>Наибольшую плотность упаковки можно достичь,<b style='mso-bidi-font-weight:
normal'><a name="m53"> </b>если сделать границы слов (байтов) «прозрачными», представив
упакованные данные в виде неограниченной последовательности разрядов, «плотно»
уложенных в массиве машинных слов (байтов). Для того, чтобы вынести за скобки
часть программы, работающую с отдельными двоичными разрядами и их группами (полями),
и,<span style='mso-spacerun:yes'>  </span>учитывая тот факт, что разряды
записываются и извлекаются только последовательно, разработаем две функции
добавления и выделения очередного разряда по заданному номеру. Он будет
передаваться ссылкой на переменную – счетчик, которая увеличивается при каждом
вызове функции.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----<span lang=EN-US style='mso-ansi-language:EN-US'>------------------</span>--------------------------------------------------91-07.cpp</p>

<p class=a0>//-------- Извлечение и запись разряда (бита)</p>

<p class=a0><span style='mso-spacerun:yes'> </span>long getbit(char c[], int
&amp;n) { <span style='mso-tab-count:1'>      </span>// c[] - массив байтов, n
- номер разряда</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int nb = n/8;<span
style='mso-spacerun:yes'>                   </span><span style='mso-tab-count:
1'>           </span>// номер байта</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int ni = n%8;<span
style='mso-spacerun:yes'>                   </span><span style='mso-tab-count:
1'>          </span>// номер разряда в байте</p>

<p class=a0><span style='mso-spacerun:yes'> </span>n++;</p>

<p class=a0><span style='mso-spacerun:yes'> </span>return (c[nb]&gt;&gt;ni)
&amp; 1; }<span style='mso-spacerun:yes'>       </span><span style='mso-tab-count:
1'>      </span>//сдвинуть к младшему и выделить</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void putbit(char c[], int &amp;n, int v ){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>nb</span> = <span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>/8;<span style='mso-tab-count:3'>                              </span>//
Сформировать маску разряда ni </p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>ni</span> = <span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>%8;<span style='mso-tab-count:3'>                             </span>//
очистить старое по маске и установить </p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>++;<span style='mso-tab-count:4'>                                        </span>//
новый разряд, сдвинув его в позицию <span lang=EN-US style='mso-ansi-language:
EN-US'>ni</span></p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>nb</span>] = <span lang=EN-US style='mso-ansi-language:EN-US'>c</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>nb</span>] &amp; ~(1&lt;&lt;<span
lang=EN-US style='mso-ansi-language:EN-US'>ni</span>) | ( (<span lang=EN-US
style='mso-ansi-language:EN-US'>v</span>&amp;1) &lt;&lt; <span lang=EN-US
style='mso-ansi-language:EN-US'>ni</span>);}<span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a4>Функция, извлекающая последовательность разрядов числа (младшими
вперед), производит повторную сборку их в машинное слово заданной размерности с
использованием операций сдвига и поразрядного <b style='mso-bidi-font-weight:
normal'><a name="m54">ИЛИ</b>. Функция упаковки слова выделяет последовательность битов,
начиная с младшего, используя операцию сдвига, и вызывает функцию записи
разряда.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------------------------91-07.cpp</p>

<p class=a0>//------- Извлечение слова заданной размерности</p>

<p class=a0>unsigned long getword(char c[], int &amp;n, int sz) {</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>unsigned long v =
0;<span style='mso-tab-count:3'>                               </span>// int sz
- </span>количество<span style='mso-ansi-language:EN-US'> </span>разрядов<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for(int i = 0;
i&lt;sz; i++) v |= getbit(c, n)&lt;&lt;i;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return v; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void putword(char
c[], int &amp;n, int sz, long v){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>while(sz--!=0)<span
style='mso-tab-count:5'>                                                     </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>{ putbit(c, n, v&amp;1); v&gt;&gt;=1;}}<o:p></o:p></span></p>

<p class=a4>Последующие действия связаны уже с форматом представления данных –
наличием управляющих полей и полей данных взаимосвязанной размерности. В них
поразрядные операции могут вообще отсутствовать. Это видно на примере функций
упаковки и распаковки целых переменных различной размерности – 8, 16 и 32
разряда. перед каждым числом размещаются 2 бита, определяющие размерность числа
- <span style='font-family:"Times New Roman"'>00 - </span>конец
последовательности, <span style='font-family:"Times New Roman"'>01 - </span><span
lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:EN-US'>char</span><span
style='font-family:"Times New Roman"'>, 10 - </span><span lang=EN-US
style='font-family:"Times New Roman";mso-ansi-language:EN-US'>int</span><span
style='font-family:"Times New Roman"'>, 11 – </span><span lang=EN-US
style='font-family:"Times New Roman";mso-ansi-language:EN-US'>long</span><span
style='font-family:"Times New Roman"'>. После них размещаются разряды самого
числа.</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------------------------91-07.cpp</p>

<p class=a0>//---- Упаковка и распаковка переменных различной размерности</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void unpack(char c[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int n=0; int vv;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>while(1){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>mode</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>getword</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>,<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>,2);<span style='mso-tab-count:2'>                  </span>// Извлечение
2-разрядного кода</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>switch(mode){<span style='mso-tab-count:
3'>                         </span>// переключение по значению кода</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>case</span> 0: <span lang=EN-US
style='mso-ansi-language:EN-US'>return</span>;<span style='mso-tab-count:3'>                                 </span><span
lang=EN-US style='mso-ansi-language:EN-US'>// 00 – конец </span>последовательности</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>case</span> 1: <span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span>=<span lang=EN-US style='mso-ansi-language:
EN-US'>getword</span>(<span lang=EN-US style='mso-ansi-language:EN-US'>c</span>,<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>,8); <span lang=EN-US
style='mso-ansi-language:EN-US'>break</span>; <span style='mso-tab-count:1'>     </span>//
01 извлечь 8-разрядное (байт)</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>case</span> 2: <span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span>=<span lang=EN-US style='mso-ansi-language:
EN-US'>getword</span>(<span lang=EN-US style='mso-ansi-language:EN-US'>c</span>,<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>,16);<span lang=EN-US
style='mso-ansi-language:EN-US'>break</span>;<span style='mso-tab-count:1'>      </span>//
10 извлечь 16-разрядное</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>case</span> 3: <span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span>=<span lang=EN-US style='mso-ansi-language:
EN-US'>getword</span>(<span lang=EN-US style='mso-ansi-language:EN-US'>c</span>,<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>,32);<span lang=EN-US
style='mso-ansi-language:EN-US'>break</span>;<span style='mso-tab-count:1'>      </span>//
11 извлечь 32-разрядное<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'>  
</span>} printf(&quot;%d\n&quot;,vv);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>}}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void pack(char c[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int n=0; int vv;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>do { scanf(&quot;%d&quot;,&amp;vv);<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>if(vv==0) putword(c,n,2,0);<span
style='mso-tab-count:2'>                 </span>// запись 2-разрядного кода 00</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>else <span
style='mso-spacerun:yes'> </span>if (vv &lt; 256) {</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>putword(c,n,2,1);<span style='mso-tab-count:
2'>                     </span>// запись 2-разрядного кода 01</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>putword(c,n,8,vv);}<span style='mso-tab-count:
2'>                   </span>// запись 8-разрядного кода числа</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>else <span
style='mso-spacerun:yes'> </span>if (vv &lt; 32768) {</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>putword(c,n,2,2);<span style='mso-tab-count:
2'>                     </span>// запись 2-разрядного кода 10</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>putword(c,n,16,vv);}<span style='mso-tab-count:
2'>                 </span>// запись 16-разрядного кода числа</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>else {</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>putword(c,n,2,3);<span style='mso-tab-count:
2'>                     </span>// запись 2-разрядного кода 11</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>putword(c,n,32,vv);}<span style='mso-tab-count:
2'>                 </span>// запись 32-разрядного кода числа</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>} <span lang=EN-US
style='mso-ansi-language:EN-US'>while</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span>!=0); }</p>

<span style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:"Arial CYR";
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
mso-ansi-language:RU;mso-fareast-language:RU;mso-bidi-language:AR-SA'><br
clear=all style='page-break-before:always'>
</span>

<h3>Машинная арифметика произвольной точности</h3>

<p class=a>Для понимания ниже изложенного материала необходимо детально
проработать п. «1.3. Описание данных. Типы данных и переменные» в той его
части, которая касается двоичной и шестнадцатеричной систем счисления, машинных
слов и основ внутреннего представления данных.</p>

<p class=a>Поразрядные операции более примитивными, чем арифметические. Именно
потому на их основе можно запрограммировать алгоритмы выполнения арифметических
операций, использующих форматы внутреннего (двоичного) представления данных.
Естественно, это имеет смысл не для воспроизведения уже имеющегося, а, например,
для создания арифметики произвольной точности. В предлагаемом примере
программно моделируются <span style='mso-spacerun:yes'> </span>целые (со
знаком) произвольной размерности, представленные массивами беззнаковых байтов<span
style='font-family:"Times New Roman"'> </span>в форме, соответствующей их
внутреннему представлению в памяти (дополнительный код). </p>

<p class=a>Операция сложения выполняется побайтно. Возникающий при сложении
двух байтов перенос (8-й разряд, выделяемый маской 0x0100) используется в
операции сложения следующих двух байтов.</p>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=a0>//-------------------------------------------------------------91-08.cpp</p>

<p class=a0>//------Сложение целых произвольной разрядности</p>

<p class=a0><span style='mso-spacerun:yes'> </span>typedef unsigned char uchar;</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void add(uchar out[], uchar in1[], uchar in2[],
int n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{int i, carry;<span
style='mso-spacerun:yes'>                                 </span>// </span>Разряд<span
style='mso-ansi-language:EN-US'> </span>переноса<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>unsigned w;<span
style='mso-spacerun:yes'>            </span><span style='mso-tab-count:2'>                  </span>//
Рабочая переменная для сложения двух байтов</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (i=0, carry=0; i&lt;n; i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>out [i] = w = in1[i]+in2[i]+carry;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>carry = (w &amp; 0x0100)
&gt;&gt;8;<span style='mso-tab-count:1'>    </span>// Разряд переноса сдвинуть
вправо на 8</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}} </p>

<p class=a>Для того, чтобы продемонстрировать работоспособность алгоритма и соответствие
его принятым форматам представления данным, необходимо взять в качестве
параметров функции любой базовый тип (например, <span lang=EN-US
style='mso-ansi-language:EN-US'>long</span>), сформировать на него указатель
как на область памяти, заполненную беззнаковыми байтами.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void main(){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long a=125000,
b=30000, c;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>add((uchar*)&amp;c,
(uchar*)&amp;a, (uchar*)&amp;b,sizeof(long));<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>printf(&quot;c=%ld\n&quot;,c);}<o:p></o:p></span></p>

<p class=a>Для моделирования операции вычитания необходимо сформировать
дополнительный код числа: произвести побайтную инверсию и добавить 1 к
результату. Последнее можно сделать, установив первоначально в 1 перенос и
распространив его по массиву байтов, аналогично сложению.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------91-09.cpp</p>

<p class=a0>//------ Получение отрицательного числа в дополнительном коде</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>typedef unsigned char uchar;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void neg(uchar in[], int n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{int i, carry;<span
style='mso-spacerun:yes'>       </span><span style='mso-tab-count:1'>                                    </span>//
</span>Разряд<span style='mso-ansi-language:EN-US'> </span>переноса<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>unsigned w;<span
style='mso-spacerun:yes'>            </span><span style='mso-tab-count:1'>                  </span>// Рабочая переменная для сложения
двух байтов</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (i=0; i&lt;n; i++) in[i]=~in[i];<span
style='mso-tab-count:1'>      </span>// Инвертированин всех разрядов<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>=0, <span lang=EN-US style='mso-ansi-language:EN-US'>carry</span>=1;
<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>&lt;<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>; <span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>++){<span style='mso-tab-count:1'>         </span>// Добавление
1 (инкремент) с первоначальной</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>in [i] = w = in[i]+carry;<span
style='mso-tab-count:1'>          </span>// установкой переноса в 1<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>carry = (w &amp; 0x0100)
&gt;&gt;8;</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a4>Для моделирования операции умножения необходимо реализовать
операции сдвига на 1 разряд влево и вправо.</p>

<p class=MsoNormal style='text-align:justify'><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------91-10.cpp</p>

<p class=a0>//------Сдвиг целых произвольной разрядности</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void lshift(uchar in[], int n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int carry;<span style='mso-tab-count:4'>                                            </span>//
</span>Разряд<span style='mso-ansi-language:EN-US'> </span>переноса<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int i,z;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (carry=0, i=0; i&lt;n; i++){ <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>z</span>=(<span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>] &amp; 0<span lang=EN-US style='mso-ansi-language:EN-US'>x</span>80)&gt;&gt;7;<span
style='mso-spacerun:yes'>          </span><span style='mso-tab-count:2'>               </span>//
Выделить старший разряд (перенос)</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>in[i] &lt;&lt;= 1;<span
style='mso-spacerun:yes'>                  </span><span style='mso-tab-count:
2'>                    </span>// Сдвинуть влево и установить</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>in[i] |=carry;<span
style='mso-spacerun:yes'>                </span><span style='mso-tab-count:
2'>                     </span>// старый перенос в младший разряд</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>carry = z;<span
style='mso-spacerun:yes'>                   </span><span style='mso-tab-count:
2'>                     </span>// Запомнить новый перенос</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>}}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void rshift(uchar in[], int n)<span
style='mso-tab-count:2'>                      </span>// </span>Сдвиг<span
style='mso-ansi-language:EN-US'> </span>арифметический<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>{ int
carry=((in[n-1]&amp;0x80)!=0);<span style='mso-spacerun:yes'>   </span>// Разряд переноса = копия знакового</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int i,z;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (i=n-1; i&gt;=0; i--){ <o:p></o:p></span></p>

<p class=a0><span style='mso-spacerun:yes'>      </span>z = in[i] &amp; 1;<span
style='mso-spacerun:yes'>               </span><span style='mso-tab-count:2'>                     </span>//
Выделить младший разряд (перенос)</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>in[i] &gt;&gt;= 1;<span
style='mso-spacerun:yes'>                  </span><span style='mso-tab-count:2'>                    </span>//
Сдвинуть вправо и установить</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>in[i] |= carry
&lt;&lt;7;<span style='mso-spacerun:yes'>           </span><span
style='mso-tab-count:2'>                  </span>// старый перенос в старший
разряд</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>carry = z;<span
style='mso-spacerun:yes'>                    </span><span style='mso-tab-count:
2'>                    </span>// Запомнить новый перенос</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>}} <o:p></o:p></span></p>

<p class=a0><span style='font-family:"Courier New"'><o:p></o:p></span></p>

<p class=a4>В переменной carry запоминается значение старшего (младшего) разряда,
который переносится в следующий байт на место младшего (старшего). Сдвиг влево
происходит от младшего байта к старшему, вправо – наоборот. Сдвиг вправо –
арифметический, освобождающийся старший разряд старшего байта устанавливается
как копия сдвигаемого (начальное значение переноса carry). Это обеспечивает
сохранение<span style='mso-spacerun:yes'>  </span>знака отрицательного числа
при сдвиге вправо (аналог деления на 2).</p>

<p class=a>В операции умножения реализован самый простой алгоритм сложения и
сдвига. Он, как и все алгоритмы машинной арифметики для внутреннего
представления данных, использует свойства двоичной системы. </p>

<p class=a5><span style='mso-ansi-language:RU'><o:p>&nbsp;</o:p></span></p>

<p class=a5><span lang=EN-US>cc = aa*bb = aa * </span><span lang=EN-US
style='mso-bidi-font-family:"Courier New"'>&#931; bb<sub>i </sub><sup>*</sup> 2<sup>i
</sup>=<sub> </sub>&#931; bb<sub>i</sub> *(aa * 2<sup>i</sup>)<sub> </sub></span></p>

<p class=a>В произведении множитель <b style='mso-bidi-font-weight:normal'><a name="m55"><span
lang=EN-US style='mso-ansi-language:EN-US'>bb</span><span lang=EN-US> </span></b>раскладывается
как сумма произведений двоичных разрядов на степени 2, <span
style='mso-spacerun:yes'> </span>т.е. <b style='mso-bidi-font-weight:normal'><a name="m56"><span
style='mso-bidi-font-family:"Courier New"'>bb<sub>i </sub><sup>*</sup> 2<sup>i</sup></span></b>.
<span style='mso-spacerun:yes'> </span>Известно, что степень 2 эквивалентна
сдвигу влево на <b style='mso-bidi-font-weight:normal'><a name="m57"><span lang=EN-US
style='mso-ansi-language:EN-US'>n</span><span lang=EN-US> </span></b>разрядов. Тогда
при наличии 1 в <b style='mso-bidi-font-weight:normal'><a name="m58"><span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>-ом </b>разряде множителя <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>bb</span><span lang=EN-US> </span></b>к произведению должен быть
добавлен множитель <b style='mso-bidi-font-weight:normal'><a name="m59">аа, </b>сдвинутый на <b
style='mso-bidi-font-weight:normal'>n </b>разрядов влево. При наличии 0
добавление не производится.<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=MsoNormal style='text-align:justify'><b style='mso-bidi-font-weight:
normal'><a name="m60"><span lang=EN-US style='font-family:"Courier New CYR";mso-bidi-font-family:
"Times New Roman";mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></b></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------</span>91<span
lang=EN-US style='mso-ansi-language:EN-US'>-11.cpp<o:p></o:p></span></p>

<p class=a0>//------Умножение целых произвольной разрядности</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void mul(uchar out[], uchar aa[], uchar bb[],
int n)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>{int i,s1=0,s2=0;<span
style='mso-tab-count:4'>                                               </span>//
Отрицательные числа - прямой код</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (aa[n-1] &amp; 0x80) { neg(aa,n); s1=1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (bb[n-1] &amp; 0x80) { neg(bb,n); s2=1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (i=0; i&lt;n; i++) out[i]=0;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>for (i=0; i&lt; n* 8; i++){<span
style='mso-tab-count:3'>                                    </span>// Цикл по
количеству разрядов</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>if (bb[0] &amp; 1
)<span style='mso-spacerun:yes'>                   </span><span
style='mso-tab-count:3'>                            </span>// Разряд множителя
равен 1 </p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
1'>      </span>add(out,out,aa,n);<span style='mso-tab-count:3'>                                   </span>//
Добавить множимое к произведению</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>lshift(aa,n);<span
style='mso-spacerun:yes'>                     </span><span style='mso-tab-count:
3'>                             </span>// Множимое - влево</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>rshift(bb,n);<span
style='mso-spacerun:yes'>                     </span><span style='mso-tab-count:
3'>                             </span>// Множитель - вправо</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}</p>

<p class=a0><span style='mso-spacerun:yes'> </span>if (s1!=s2) neg(out,n);<span
style='mso-tab-count:4'>                                        </span>// Знаки
не совпадают - доп. код</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a5><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=a5><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=a>В множителе <b style='mso-bidi-font-weight:normal'><a name="m61">bb</b> подряд
просматриваются все разряды, начиная с младшего (путем одноразрядного сдвига
его вправо). Множитель при этом каждый раз сдвигается на 1 разряд влево
(умножается на 2). Если очередной разряд множителя равен 1, то текущее
сдвинутое значение множимого добавляется к произведению. Чтобы не усложнять
программу, значения множимого и множителя не сохраняются. Поскольку
перемножаются положительные значения (абсолютные величины), то дополнительный
код отрицательных множителей переводится в прямой, а результат при
необходимости – обратно в дополнительный.</p>

<h3>Арифметика в других формах представления данных</h3>

<p class=a4>В арифметике произвольной точности совсем не обязательно
придерживаться форматов внутреннего представления даже двоичной системы. Данные
могут быть представлены десятичной системе счисления, при этом операции
производятся над каждой цифрой числа отдельно с учетом взаимного влияния
десятичных разрядов через переносы, заемы, то есть так, как «учат в школе».
Возможны два варианта представления десятичных цифр<span style='font-family:
"Times New Roman"'>:<o:p></o:p></span></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>отдельная цифра представлена 4 битами (тетрадой,
шестнадцатеричной цифрой, так называемый <span lang=EN-US style='mso-ansi-language:
EN-US'>BDC</span>-код)<span style='font-family:"Times New Roman"'>;<o:p></o:p></span></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>
<span
style='mso-spacerun:yes; font-family:Times New Roman'> </span>цифра задана символом во внешней форме
представления, а само число - текстовой строкой.</p>

<p class=a>Например, число 17665 выглядит в этих формах представления следующим
образом<span style='font-family:"Times New Roman"'>:<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long
ss=0x00017655;<span style='mso-tab-count:3'>                             </span>//
</span>или<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>char s[]={0x55,0x76,0x10,0x00};<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>char</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>s</span>[]=&quot;17665&quot;;</p>

<p class=a0 style='text-indent:36.0pt'><o:p>&nbsp;</o:p></p>

<p class=a>В качестве иллюстрации технологии работы с отдельными цифрами числа
в десятичной системе счисления рассмотрим пример функции, добавляющей 1 к числу
во внешней форме представления, то есть в виде текстовой строки.<span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'> </span>Добавление
1 состоит в поиске первой цифры, отличной от 9, к которой добавляется 1. Все
встречающиеся «на пути» цифры 9 превращаются в 0. Если процесс «превращения
девяток» доходит до конца строки, то производится расширение строки следующей
цифрой 1.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//--------------------------------------------------------------------91-12.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//------ Инкремент числа во внешней форме представления</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void inc(char
s[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int i=0;
s[i]!=0; i++);<span style='mso-spacerun:yes'>                    </span><span
style='mso-tab-count:1'>      </span>// Поиск конца строки<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>-1; <span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>&gt;=0; <span lang=EN-US style='mso-ansi-language:EN-US'>n</span>--){<span
style='mso-spacerun:yes'>                </span><span style='mso-tab-count:1'>          </span>//
Младшая цифра - в конце</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>n</span>]=='9'
)<span style='mso-spacerun:yes'>                            </span><span
style='mso-tab-count:1'>        </span>// 9 превращается в 0</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>]='0';</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>else</span> { <span lang=EN-US
style='mso-ansi-language:EN-US'>s</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>]++; <span lang=EN-US style='mso-ansi-language:EN-US'>return</span>;
}}<span style='mso-spacerun:yes'>     </span><span style='mso-tab-count:2'>                </span>//
добавить 1 к цифре и выйти</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s[i+1]=0;
i&gt;0; i--) s[i]='0' ; <span style='mso-tab-count:2'>                 </span>//
Записать в строку 1000...<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>s</span>[0]='1';}</p>

<p class=a>Другие арифметические операции также моделируются по принципу «цифра
за цифрой». Так, <span style='mso-spacerun:yes'> </span>при сложении
суммируется очередная пара цифр, переведенных во внутреннее представление, и
при получении результирующей суммы, превышающей 9, формируется перенос в
следующий разряд. Вычитание производится, соответственно, с учетом заема.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<span style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";mso-ansi-language:RU;mso-fareast-language:
RU;mso-bidi-language:AR-SA'><br clear=all style='page-break-before:always'>
</span>

<p class=a0>//------------------------------------------------------------------91-13.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//------ Сложение чисел во внешней форме представления</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void add(char out[],char c1[],char c2[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>l</span>1=<span lang=EN-US
style='mso-ansi-language:EN-US'>strlen</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>1)-1;<span
style='mso-spacerun:yes'>                 </span><span style='mso-tab-count:
1'>    </span><span style='mso-tab-count:1'>            </span>// Определение
разрядности суммы</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>l</span>2=<span lang=EN-US
style='mso-ansi-language:EN-US'>strlen</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>2)-1;<span
style='mso-spacerun:yes'>             </span><span style='mso-tab-count:1'>                    </span>// и индексов младших цифр слагаемых</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int l=l1; if (l2&gt;l1) l=l2;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>l</span>++; <span lang=EN-US style='mso-ansi-language:
EN-US'>out</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>l</span>+1]=0;<span
style='mso-spacerun:yes'>                         </span><span
style='mso-tab-count:1'>                        </span>//
В сумме на 1 цифру больше</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>v</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>v</span>1,<span lang=EN-US style='mso-ansi-language:
EN-US'>v</span>2,<span lang=EN-US style='mso-ansi-language:EN-US'>carry</span>;<span
style='mso-spacerun:yes'>                       </span><span style='mso-tab-count:1'>            </span>// Цифры и перенос</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>carry</span>=0;<span lang=EN-US style='mso-ansi-language:EN-US'>l</span>&gt;=0;<span
lang=EN-US style='mso-ansi-language:EN-US'>l</span>--,<span lang=EN-US
style='mso-ansi-language:EN-US'>l</span>1--,<span lang=EN-US style='mso-ansi-language:
EN-US'>l</span>2--){ <span style='mso-tab-count:1'>            </span>// Цикл
от младших цифр к старшим</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (l1&lt;0) v1=0; else v1=c1[l1]-'0';<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>if (l2&lt;0) v2=0; else v2=c2[l2]-'0';<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>v</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>v</span>1+<span lang=EN-US style='mso-ansi-language:
EN-US'>v</span>2+<span lang=EN-US style='mso-ansi-language:EN-US'>carry</span>;<span
style='mso-spacerun:yes'>                     </span><span style='mso-tab-count:
1'>            </span><span style='mso-tab-count:1'>            </span>//
Сложение с учетом входного</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span><span lang=EN-US style='mso-ansi-language:
EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>v</span>&gt;=10)
{<span lang=EN-US style='mso-ansi-language:EN-US'>carry</span>=1; <span
lang=EN-US style='mso-ansi-language:EN-US'>v</span>-=10;}<span
style='mso-tab-count:1'>       </span>// и формированием выходного</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>else</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>carry</span>=0;<span
style='mso-spacerun:yes'>                  </span><span style='mso-tab-count:
1'>     </span><span style='mso-tab-count:1'>            </span>// переноса (во
внутренней форме)</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>out</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>l</span>]=<span lang=EN-US style='mso-ansi-language:EN-US'>v</span>+'0';<span
style='mso-spacerun:yes'>                         </span><span style='mso-tab-count:1'>            </span>//
Запись цифры результата</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>}}<o:p></o:p></span></p>

<a name="lr13"><h3>Лабораторный практикум</h3>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>1. Программа деления целых чисел произвольной длины во внутреннем
представлении с использованием операций вычитания, инкремента и проверки на
знак результата. Частное определяется как количество вычитаний делителя из
делимого до появления отрицательного результата (проверить на переменных типа
long).</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>2. Программа деления целых чисел произвольной длины во внутреннем
представлении с восстановлением остатка. Очередной разряд частного определяется
вычитанием делителя из делимого. Если результат положителен, то разряд равен 1,
если отрицателен, то делитель добавляется к делимому (восстановление остатка) и
разряд частного считается равным 0. После каждого вычитания делимое и частное
сдвигаются на 1 разряд влево. Перед началом операции делитель выравнивается с
делимым путем сдвига на <b style='mso-bidi-font-weight:normal'><a name="m62"><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>/2 </b>разрядов влево.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>3. Умножение<span style='mso-spacerun:yes'>  </span>чисел<span
style='mso-spacerun:yes'>  </span>произвольной<span style='mso-spacerun:yes'> 
</span>длины, представленных непосредственно строками цифр. Первоначально
формируется строка символов произведения с необходимым количеством нулей. Далее
для каждой пары цифр сомножителей к нему добавляется частичное произведение: значения
цифр переводятся во внутреннюю форму и перемножаются, после чего выделяется
младшая и старшая цифры результата, которые суммируются с соответствующими
цифрами произведения с учетом переноса и его распространения в старшие цифры.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>4. Вариант 3 для двоично-десятичного представления исходных данных – в
одном байте – 2 тетрады, хранящие десятичные цифры числа. Последовательность
цифр размещена, начиная с младшей, и ограничена тетрадой с кодом 0<span
lang=EN-US style='mso-ansi-language:EN-US'>xF</span>.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>5. Умножение<span style='mso-spacerun:yes'>  </span>чисел<span
style='mso-spacerun:yes'>  </span>произвольной<span style='mso-spacerun:yes'> 
</span>длины, представленных непосредственно строками цифр. Произведение
формируется через многократное сложение одного из множителей с накапливаемым
произведением, количество сложений определяется вторым сомножителем.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>6. Вариант 5 для двоично-десятичного представления исходных данных – в
одном байте – 2 тетрады, хранящие десятичные цифры числа. Последовательность
цифр размещена, начиная с младшей, и ограничена тетрадой с кодом 0<span
lang=EN-US style='mso-ansi-language:EN-US'>xF</span>.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>7. Вычитание<span style='mso-spacerun:yes'>  </span>чисел<span
style='mso-spacerun:yes'>  </span>произвольной<span style='mso-spacerun:yes'> 
</span>длины, представленных непосредственно строками цифр с использованием
дополнительного кода вычитаемого (в десятичной системе счисления).</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>8. Вариант 7 для двоично-десятичного представления исходных данных – в
одном байте – 2 тетрады, хранящие десятичные цифры числа. Последовательность
цифр размещена, начиная с младшей, и ограничена тетрадой с кодом 0<span
lang=EN-US style='mso-ansi-language:EN-US'>xF</span>.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'><span style='font-family:"Times New Roman"'>9. </span>Кодирование и
декодирование строки символов, содержащих цифры, в последовательность
битов.<span style='mso-spacerun:yes'>  </span>Десятичная цифра кодируется 4
битами - одной шестнадцатеричной цифрой. Цифра <b style='mso-bidi-font-weight:
normal'><a name="m63"><span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'>F</span></b><span lang=EN-US style='font-family:"Times New Roman"'> </span>обозначает,
что за ней следует байт (2 цифры) с кодом символа, отличного от цифры.
Разработать функции кодирования и декодирования с определением процента
уплотнения.<span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'><o:p></o:p></span></p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>10.<span style='font-family:"Times New Roman"'> </span>Последовательность
целых переменных различной размерности кодируется следующим образом<span
style='font-family:"Times New Roman"'>: </span>перед каждым числом размещаются
5 битов, определяющие количество битов в следующем за ним целом числе. 00000 -
конец последовательности. Разработать функции упаковки и распаковки массива
переменных типа <span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>long</span><span lang=EN-US style='font-family:"Times New Roman"'>
</span>с учетом количества значащих битов и с определением коэффициента
уплотнения. Пример<span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>: <b style='mso-bidi-font-weight:normal'><a name="m64">01000
xxxxxxxx 00011 xxx 10000 xxxxxxxxxxxxxxxx 00000</b></span></p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>11.<span style='font-family:"Times New Roman"'> </span>Кодирование
массива, содержащего последовательности одинаковых битов. При обнаружении
изменения значения очередного бита по сравнению с предыдущим в последовательность
записывается 6 разрядное значение счетчика (<span lang=EN-US style='font-family:
"Times New Roman";mso-ansi-language:EN-US'>n</span><span style='font-family:
"Times New Roman"'>&lt;6</span>)<span style='font-family:"Times New Roman"'> </span>длины
последовательности одинаковых битов. <span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>n</span><span style='font-family:"Times New Roman"'>=0
</span>обозначает конец последовательности. Пример (исходная последовательность
битов задана справа налево)<span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>: </span><b style='mso-bidi-font-weight:normal'><a name="m65">000000001111111000000000000
- 001100 000111 001000 000000<o:p></o:p></b></p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>12. Большие латинские буквы упаковываются в виде 5-битных кодов по 3
символа в одну целую переменную типа <span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>int</span><span style='font-family:"Times New Roman"'>.
</span>При этом старший бит устанавливается<span style='mso-spacerun:yes'> 
</span>в 1. Остальные символы упаковываются по одному в целую переменную со
значением старшего бита - 0. Разработать функции упаковки и распаковки
строки<span style='mso-spacerun:yes'>  </span>с определением коэффициента
уплотнения.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>13.<span style='font-family:"Times New Roman"'> </span>Первые 15
наиболее часто встречающихся символов кодируются 4-битными кодами от 0000 до
1110. Код 1111 обозначает, что следующие за ним 8 бит кодируют один из
остальных символов. Разработать функции упаковки и распаковки строки<span
style='mso-spacerun:yes'>  </span>с определением наиболее часто встречающихся
символов и коэффициента уплотнения.</p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>14. Если в последовательности встречается бит 0, то за ним идет
3-битовый код первых 8 наиболее часто встречающихся символов (000 ... 111). За
битом 1 - следует обычный 8-битный код остальных символов. Разработать функции
упаковки и распаковки строки<span style='mso-spacerun:yes'>  </span>с
определением наиболее часто встречающихся символов и коэффициента
уплотнения.<span style='mso-spacerun:yes'>  </span><span style='font-family:
"Times New Roman"'><o:p></o:p></span></p>

<p class=a1 style='margin-left:1.0cm;text-indent:0cm;mso-list:none;tab-stops:
42.55pt'>15. Первый наиболее часто встречающийся символ кодируется битом 0. Бит
1 кодирует группу из всех остальных символов. Код 10 кодирует второй по частоте
символ, 11 - группу всех остальных и т.д.. Разработать функции упаковки и
распаковки строки<span style='mso-spacerun:yes'>  </span>с определением
наиболее часто встречающихся символов и коэффициента уплотнения.<span
style='mso-spacerun:yes'>  </span></p>

<h3>Вопросы без ответов</h3>

<p class=a>Содержательно сформулируйте результат функции, определите, какие
свойства машинного слова и какие действия над ним она производит. Вызов функции
оформите с формальным параметром – шестнадцатеричной константой и
прокомментируйте полученный результат.</p>

<p class=a4><b style='mso-bidi-font-weight:normal'><a name="m66">Пример оформления <span
style='mso-spacerun:yes'> </span>задания.<o:p></o:p></b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------91-14.cpp</p>

<p class=a0>unsigned long F(unsigned long v, int k){</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int i; unsigned long s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (s=1, i=0; i&lt;k; s&lt;&lt;=1, i++) v = v
&amp; ~s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return v;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void main(){
printf(&quot;F(0x1FFF,7)=%lx\n&quot;,F(0x1FFF,7)); }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a4>В данном примере необходимо представить процессы перемещения битов
по машинному слову. Единственный цикл в программе организует перемещение
единичного бита последовательно по разрядам машинного слова <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span><span lang=EN-US> </span></b>справа налево. Число повторений
цикла <b style='mso-bidi-font-weight:normal'><a name="m67"><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span><span lang=EN-US> </span></b>ограничивает этот процесс <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span><span lang=EN-US> </span></b>разрядами. Таким образом, в <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span><span lang=EN-US> </span></b>находится единичная маска, которая
пробегает по первым <b style='mso-bidi-font-weight:normal'><a name="m68"><span lang=EN-US
style='mso-ansi-language:EN-US'>k</span><span lang=EN-US> </span></b>разрядам
машинного слова. В теле цикла имеет место поразрядная операция <b
style='mso-bidi-font-weight:normal'>И </b>с инвертированной маской, что, как мы
знаем, интерпретируется как очистка соответствующего бита. Результат функции –
очистка <b style='mso-bidi-font-weight:normal'><a name="m69"><span lang=EN-US
style='mso-ansi-language:EN-US'>k</span><span lang=EN-US> </span></b>младших
разрядов входной переменной. Для приведенного примера вызова можно легко
определить результат, естественно, в шестнадцатеричной системе счисления (с
раскладкой по битам) - <b style='mso-bidi-font-weight:normal'><a name="m70">0<span lang=EN-US style='mso-ansi-language:
EN-US'>x</span>1<span lang=EN-US
style='mso-ansi-language:EN-US'>D</span>20 . </b>Очищаются первые 5 разрядов –
младшая тетрада и еще младший бит второй тетрады.</p>

<p class=a0><b style='mso-bidi-font-weight:normal'><a name="m71"><o:p>&nbsp;</o:p></b></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//--------------------------------------------------------------</span>91<span
lang=EN-US style='mso-ansi-language:EN-US'>-1</span>5<span lang=EN-US
style='mso-ansi-language:EN-US'>.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
1<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int F1(){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i; long l;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (l=1,i=0; l
&gt;0;<span style='mso-spacerun:yes'>  </span>l&lt;&lt;=1, i++);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return i;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
2<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int F2(){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i; long l;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (l=1,i=0; l
!=0; l&lt;&lt;=1, i++);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return i;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
3<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int F3(long n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int i,s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0,s=0; i
&lt; sizeof(long) * 8; i++, n &gt;&gt;=1)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (n &amp; 0x7==5) { s++; i+=2; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return s; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
4<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long F4(long n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int i; long s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=s=0; i &lt;
sizeof(long) * 8; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>{ s &lt;&lt;=1; s |= n &amp; 1; n
&gt;&gt;=1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return s; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
5<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>long F5(long n,
int m1, int m2)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ long s,x; int i;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0,x=1,s=n;
i &lt; sizeof(long)*8; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>{ if (i &gt;=m1 &amp;&amp; i
&lt;=m2) s |= x; x &lt;&lt;=1; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return s; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
6<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int F6(char c[])<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int i,s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0; c[i]
!='\0'; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (c[i] &gt;='0' &amp;&amp; c[i]
&lt;='7') break;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=0; c[i]
&gt;='0' &amp;&amp; c[i] &lt;='7'; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>{ s &lt;&lt;=3; s |= c[i] &amp; 0x7;
}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return s; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
7<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void F7(char
c[],long n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int
i=sizeof(long)*8/3 +1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (c[i--]='\0';
i&gt;=0; i--)<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>{ c[i] = (n &amp; 0x7) + '0';
n &gt;&gt;=3; }}</p>

<p class=a0>//------------------------------------------------ 8</p>

<p class=a0>// Операция &quot;^&quot; - ИСКЛЮЧАЮЩЕЕ ИЛИ</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int<span
style='mso-tab-count:1'>         </span>F8(long n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int <span
style='mso-tab-count:1'>      </span>i,m,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=m=k=0; i
&lt; sizeof(long) * 8; i++, n &gt;&gt;= 1)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>    </span>if ((n &amp; 1) ^ m)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>{ k++; m =!m; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return k; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
9<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int<span
style='mso-tab-count:1'>         </span>F9(long n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int <span
style='mso-tab-count:1'>      </span>i,m,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=m=k=0; i
&lt; sizeof(long) * 8; i++, n &gt;&gt;= 1)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (n &amp; 1)
k++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>else<span
style='mso-tab-count:1'>      </span>{ if (k &gt; m) m=k; k=0; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return m; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------
10<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int F10(long v){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int i=0;
v!=0; i++, v&gt;&gt;=1);<o:p></o:p></span></p>

<p class=a0>return v;}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span style='mso-tab-count:1'>            </span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<h2><o:p>&nbsp;</o:p></h2>

</div>

</body>

</html>
