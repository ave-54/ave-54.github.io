<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="046.files/editdata.mso">
<title>4.6. Сортировка и поиск</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>romanow</o:Author>
  <o:Template>Форматер.dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>751</o:TotalTime>
  <o:LastPrinted>2004-12-25T09:56:00Z</o:LastPrinted>
  <o:Created>2008-05-13T15:31:00Z</o:Created>
  <o:LastSaved>2008-05-13T15:31:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>5389</o:Words>
  <o:Characters>30722</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>256</o:Lines>
  <o:Paragraphs>72</o:Paragraphs>
  <o:CharactersWithSpaces>36039</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Courier New CYR";
	panose-1:2 7 3 9 2 2 5 2 4 4;
	mso-font-charset:204;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin-top:0cm;
	margin-right:4.2pt;
	margin-bottom:0cm;
	margin-left:7.1pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:21.25pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{mso-style-name:Готовый;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:0cm 47.95pt 95.9pt 143.85pt 191.8pt 239.75pt 287.7pt 335.65pt 383.6pt 431.55pt 479.5pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	layout-grid-mode:line;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("046.files/header.htm") fs;
	mso-footnote-continuation-separator:url("046.files/header.htm") fcs;
	mso-endnote-separator:url("046.files/header.htm") es;
	mso-endnote-continuation-separator:url("046.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-header:url("046.files/header.htm") h1;
	mso-even-footer:url("046.files/header.htm") ef1;
	mso-footer:url("046.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:274024996;
	mso-list-type:simple;
	mso-list-template-ids:-1035561468;}
@list l0:level1
	{mso-level-start-at:2;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:53.45pt;
	mso-level-number-position:left;
	margin-left:53.45pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";}
@list l1
	{mso-list-id:327908262;
	mso-list-type:simple;
	mso-list-template-ids:68747279;}
@list l1:level1
	{mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:1072311819;
	mso-list-type:hybrid;
	mso-list-template-ids:567024120 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l3
	{mso-list-id:1650597019;
	mso-list-type:hybrid;
	mso-list-template-ids:910970976 68747279 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l3:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l4
	{mso-list-id:1674842426;
	mso-list-template-ids:631377446;}
@list l4:level1
	{mso-level-start-at:11;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:53.45pt;
	mso-level-number-position:left;
	margin-left:53.45pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@list l5
	{mso-list-id:1742748801;
	mso-list-type:hybrid;
	mso-list-template-ids:-777620932 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l5:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l6
	{mso-list-id:2004503222;
	mso-list-type:hybrid;
	mso-list-template-ids:-363577588 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><a name="m1"><i style='mso-bidi-font-style:
normal'><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:
"Arial CYR";mso-bidi-font-family:"Times New Roman"'>4.6. Сортировка и поиск<o:p></o:p></span></i></b></p>

<p class=a3><span style='mso-spacerun:yes'> </span>«Далее он расставил всех
присутствующих по этому кругу (строго как попало)».<b style='mso-bidi-font-weight:
normal'><a name="m2">Льюис Кэрролл. Алиса в стране чудес (Перевод Бориса Заходера)</b></p>

<p class=a>Раздел «Сортировка и поиск» важен по нескольким причинам. Во-первых,
он касается свойств упорядоченных и неупорядоченных данных. Кроме того, нигде
больше Вы не найдете такого разнообразия решений одной и той же задачи.</p>

<h3>Поиск и упорядочение<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></h3>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m3">Линейный поиск.</b><span
style='mso-spacerun:yes'>  </span>Для начала зададимся жизненно важным
вопросом: а зачем вообще нужна сортировка? Ответ простой: если данные не
упорядочены, то найти что-либо нас интересующее можно только путем
последовательного перебора всех элементов (если не полагаться на удачу и судьбу,
см., например, <b style='mso-bidi-font-weight:normal'><a name="m4">хэширование</b> – 6.6).
Для обычного массива фрагмент программы, определяющий, имеет ли один из его
элементов заданное значение, выглядит так: </p>

<p class=MsoNormal style='text-align:justify;text-indent:14.2pt'><o:p>&nbsp;</o:p></p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (i=0; i&lt;n; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>if (A[i]==B) break;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (i != n) ...найден...</p>

<p class=a>То, что мы получаем в данном фрагменте только факт наличия элемента
массива с данным значением, не играет никакой роли для понимания сущности
поиска данных. В реальных программах <span style='font-family:"Times New Roman"'>«</span>элементами
массива<span style='font-family:"Times New Roman"'>»</span> являются, конечно,
не простые переменные, а более сложные образования (например, структурированные
переменные). Та часть элемента данных, которая идентифицирует его и используется
для поиска, называется <b style='mso-bidi-font-weight:normal'><a name="m5">ключом</b>.
Остальная часть несет в себе содержательную информацию, которая извлекается и
используется из найденного элемента данных. </p>

<p class=a>Поиск значения путем последовательного перебора всех элементов
называется <b style='mso-bidi-font-weight:normal'><a name="m6">линейным поиском. </b>Его трудоемкость
в среднем <b style='mso-bidi-font-weight:normal'><a name="m7">T<sub>ср</sub>(<span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>)=<span lang=EN-US
style='mso-ansi-language:EN-US'>N</span>/2 =&gt; </b><b style='mso-bidi-font-weight:
normal'><a name="m8"><span lang=EN-US style='mso-ansi-language:EN-US'>O</span>(</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>). </b>По статистике надо просмотреть половину
последовательности (по «закону подлости» - всю).</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m9">Двоичный поиск в
упорядоченных данных.</b> Если данные упорядочены, то найти интересующий нас
можно значительно быстрее. Алгоритм <b style='mso-bidi-font-weight:normal'><a name="m10">двоичного
</b><span style='mso-spacerun:yes'> </span>или <b style='mso-bidi-font-weight:
normal'><a name="m11">бинарного поиска</b> основан на делении пополам текущего интервала
поиска. В основе его лежит тот факт, что при однократном сравнении искомого
элемента и некоторого элемента массива мы можем определить, справа или слева от
текущего следует искать. Проще всего выбирать элемент на середине интервала, в
котором производится поиск. Основные идеи<span style='mso-spacerun:yes'> 
</span>такого алгоритма:</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l6 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>искомый интервал поиска делится пополам и по
значению элемента массива в точке деления определяется, в какой части следует
искать значение на следующем шаге цикла; </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l6 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>для выбранного интервала поиск повторяется; </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l6 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>при «сжатии» интервала в 0 поиск прекращается; </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l6 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>в качестве начального интервала выбирается весь
массив. </p>

<p class=a1><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------46-01.cpp</p>

<p class=a0>//------Двоичный поиск в упорядоченном массиве</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int binary(int c[], int n,
int val){<span style='mso-spacerun:yes'>  </span><span style='mso-tab-count:
1'>  </span>// Возвращает индекс найденного</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int a,b,m;<span
style='mso-spacerun:yes'>                                 </span><span
style='mso-tab-count:1'>            </span>// Левая, правая границы и</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for(a=0,b=n-1; a &lt;= b;) {<span
style='mso-spacerun:yes'>         </span><span style='mso-tab-count:1'>   </span>//
</span>середина<span lang=EN-US style='mso-ansi-language:EN-US'> <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span><span style='mso-tab-count:1'>           </span>m
= (a + b)/2;<span style='mso-spacerun:yes'>                 </span>// Середина интервала</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>  </span>if (c[m] == val)<span
style='mso-spacerun:yes'>           </span><span style='mso-tab-count:1'>  </span>//
Значение найдено -</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>return m;<span
style='mso-spacerun:yes'>                           </span><span
style='mso-tab-count:1'>  </span>// вернуть индекс найденного</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>if (c[m] &gt; val)</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
1'>      </span>b = m-1;<span style='mso-spacerun:yes'>                    
</span><span style='mso-tab-count:1'>   </span>// Выбрать левую половину</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>else</p>

<p class=a0 style='text-indent:36.0pt'>a = m+1; <span
style='mso-spacerun:yes'>                   </span><span style='mso-tab-count:
1'>   </span>// Выбрать правую половину</p>

<p class=a0 style='text-indent:36.0pt'>}</p>

<p class=a0>return -1; }<span
style='mso-spacerun:yes'>                           </span><span
style='mso-tab-count:1'>      </span>// Значение не найдено </p>

<p class=a>В соответствии с принципом удвоения (деления пополам), изложенного в
<b style='mso-bidi-font-weight:normal'><a name="m12">4.1</b>, алгоритм имеет гарантированную логарифмическую
трудоемкость <b style='mso-bidi-font-weight:normal'><a name="m13"><span lang=EN-US
style='mso-ansi-language:EN-US'>T<sub>max</sub></span>=</b><b style='mso-bidi-font-weight:
normal'><a name="m14"><span lang=EN-US style='mso-ansi-language:EN-US'>log</span><sub>2</sub>(</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>). </b>Именно из-за этого свойства двоичного поиска и существуют
многочисленные алгоритмы сортировки. С небольшими изменениями алгоритм может
использоваться для определения <b style='mso-bidi-font-weight:normal'><a name="m15">места
включения</b> нового значения в упорядоченный массив. Для этого необходимо
ограничить деление интервала до получения единственного элемента (<b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>a</span>==<span lang=EN-US
style='mso-ansi-language:EN-US'>b</span></b>), после чего дополнительно
скорректировать место включения.<b style='mso-bidi-font-weight:normal'><a name="m16"><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'><o:p></o:p></span></b></p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------46-02.cpp</p>

<p class=a0>//------Двоичный поиск места включения в упорядоченном массиве</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int find(int c[], int n, int val){ <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>int a,b,m;<span
style='mso-spacerun:yes'>                                 </span><span
style='mso-tab-count:1'>            </span>// Левая, правая границы и</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for(a=0,b=n-1; a &lt; b;) {<span
style='mso-spacerun:yes'>           </span><span style='mso-tab-count:1'>   </span>//
</span>середина<span lang=EN-US style='mso-ansi-language:EN-US'> <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>m = (a + b)/2;<span
style='mso-spacerun:yes'>                        </span>// Середина интервала</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>if (c[m] == val)<span
style='mso-spacerun:yes'>                       </span>// Значение найдено -</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>return m;<span
style='mso-spacerun:yes'>                               </span>// вернуть
индекс</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>if (c[m] &gt; val)</p>

<p class=a0><span style='mso-spacerun:yes'>           </span>b = m-1;<span
style='mso-spacerun:yes'>                          </span><span
style='mso-tab-count:1'>           </span>// Выбрать левую половину</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>else</p>

<p class=a0><span style='mso-spacerun:yes'>           </span>a = m+1;<span
style='mso-spacerun:yes'>                         </span><span
style='mso-tab-count:1'>           </span>// Выбрать правую половину</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}<span
style='mso-spacerun:yes'>                                           </span><span
style='mso-tab-count:1'>          </span>// Выход из цикла по a==b</p>

<p class=a0><span style='mso-spacerun:yes'> </span>if (val &gt; c[a]) return
a+1;<span style='mso-spacerun:yes'>             </span>// Включить на следующую</p>

<p class=a0><span style='mso-spacerun:yes'> </span>return a; }<span
style='mso-spacerun:yes'>                            </span><span
style='mso-tab-count:1'>     </span>// или на текущую позицию</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Классификация сортировок</h3>

<p class=a>Любая классификация, как известно, неполна и ущербна. Признаками
классификации могут быть <b style='mso-bidi-font-weight:normal'><a name="m17">структуры
данных</b>, используемые при сортировке (массивы, списки, деревья), <b
style='mso-bidi-font-weight:normal'>местонахождение данных</b> – в памяти
(внутренняя) и в файлах (внешняя). Но все же самым лучшим принципом
классификации является классификация идей, на которых строятся сортировки. </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>сортировки, основанные на наличии упорядоченной
и неупорядоченной последовательностей, за один шаг переносят по одному элементу
из неупорядоченной части в упорядоченную (<b style='mso-bidi-font-weight:normal'><a name="m18">перенос</b>).
Эта общая идея в зависимости от того, при работе с какой частью массива она
проявляет свой «интеллект», дает нам сортировки <b style='mso-bidi-font-weight:
normal'><a name="m19">выбором </b>и <b style='mso-bidi-font-weight:normal'><a name="m20">вставками. </b>Сюда
же относятся <b style='mso-bidi-font-weight:normal'><a name="m21">вставка погружением </b>и
сортировка <b style='mso-bidi-font-weight:normal'><a name="m22">Шелла, </b>основанная на
переменном шаге погружения<b style='mso-bidi-font-weight:normal'><a name="m23">;</b></p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>идея обменной сортировки очевидна: если
достаточно долго менять местами пары соседних элементов, не находящихся в
порядке возрастания, то рано или поздно последовательность упорядочится.
Различные оптимизации (<b style='mso-bidi-font-weight:normal'><a name="m24">шейкер-сортировка,
сортировка Шелла</b>) учитывают различные эффекты, возникающие в этом процессе;</p>

<p class=a1 style='margin-left:70.9pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:42.55pt list 70.9pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><b style='mso-bidi-font-weight:normal'><a name="m25">распределение</b>
предполагает, что элементы исходной последовательности «разбрасываются» (распределяются)
- в несколько последовательностей или на различные позиции в одной. Куда
помещать очередной элемент, зависит не от его значения, а от его косвенных
характеристик. Строго говоря, они и определяют индекс (номер) выходной
последовательности или индекс (место) в выходном массиве;</p>

<p class=a1 style='margin-left:70.9pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:42.55pt list 70.9pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>сортировки на основе<span
style='mso-spacerun:yes'>  </span><b style='mso-bidi-font-weight:normal'><a name="m26">разделения/слияния</b>
основаны на перенесении данных из одной группы в несколько (в простейшем случае
– в две) (<b style='mso-bidi-font-weight:normal'><a name="m27">разделение</b>) и в обратном
их соединении (<b style='mso-bidi-font-weight:normal'><a name="m28">слияние</b>). В отличие
от распределения оба процесса линейны, то есть перенос элементов происходит
линейно (последовательно). Однако «интеллект» сортировки, т.е. выбор последовательности,
в которую или из которой следует помещать элементы, сосредоточен в одном из
этих процессов. Тогда другой носит чисто формальный характер разъединения или
соединения частей. Поэтому известны сортировки <b style='mso-bidi-font-weight:
normal'><a name="m29">разделением («</b>быстрая», рекурсивное и поразрядное разделение<b
style='mso-bidi-font-weight:normal'>), </b>основанные на разделении массива
относительно среднего значения – медианы (см. <b style='mso-bidi-font-weight:
normal'><a name="m30">2.4</b>) и сортировки <b style='mso-bidi-font-weight:normal'><a name="m31">слиянием </b>упорядоченных
последовательностей (см. там же) – однократное, циклическое, рекурсивное
слияние. Более подробно рекурсивных сортировках см. <b style='mso-bidi-font-weight:
normal'><a name="m32">7.2</b><b style='mso-bidi-font-weight:normal'><a name="m33"><span style='mso-ansi-language:
EN-US'> </span></b>и <b style='mso-bidi-font-weight:normal'><a name="m34">10.1.</b></p>

<p class=a1 style='margin-left:70.9pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:42.55pt list 70.9pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>и, наконец, известны сортировки, основанные на
хранении данных в ветвящихся последовательностях (или <b style='mso-bidi-font-weight:
normal'><a name="m35">деревьях</b>). Хотя для них обычно используются специальные способы
представления (см.<b style='mso-bidi-font-weight:normal'><a name="m36">8.1,8.4,8.5</b>), их
также можно «отобразить» в обычные массивы.</p>

<p class=a1 style='margin-left:52.9pt; text-align:center'><o:p>&nbsp;<img border="0" src="Images/046-01.gif" width="600" height="413"></o:p></p>

<p class=a style='margin-left:7.1pt;text-indent:0cm'><b style='mso-bidi-font-weight:
normal'><a name="m37"><span style='mso-spacerun:yes'> </span></b><b
style='mso-bidi-font-weight:normal'><o:p></o:p></b></p>

<p class=a align=center style='margin-left:36.0pt;text-align:center;text-indent:
0cm'><b style='mso-bidi-font-weight:normal'><a name="m38">Рис.46.1. Классификация сортировок<o:p></o:p></b></p>

<p class=a style='margin-left:36.0pt;text-indent:0cm'><o:p>&nbsp;</o:p><o:p>&nbsp;</o:p></p>

<p class=a>Другим важным критерием, по которому разделяются сортировки,
является их эффективность (трудоемкость). Здесь можно выделить несколько групп:</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l5 level1 lfo6;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>заведомо неэффективные сортировки – это, как
правило, простые алгоритмы, основанные на двойном (сложенном) цикле, для
которых оценка трудоемкости имеет вид <b style='mso-bidi-font-weight:normal'><a name="m39"><span
lang=EN-US style='mso-ansi-language:EN-US'>O</span>(</b><b style='mso-bidi-font-weight:
normal'><a name="m40"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span><sup>2</sup>)
– </b>это сортировки выбором, вставками, погружением, обменом, подсчетом. Путем
частичных усовершенствований трудоемкость может быть снижена, например, в
обменной сортировке Шелла до <b style='mso-bidi-font-weight:normal'><a name="m41">O(<span lang=EN-US style='mso-ansi-language:
EN-US'>N</span><sup>3/2</sup>);</b></p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l5 level1 lfo6;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>эффективные сортировки, основанные на наличии
процесса удвоения или деления пополам при обработке каждого элемента имеют нижнее
значение трудоемкости <b style='mso-bidi-font-weight:normal'><a name="m42">O(<span lang=EN-US style='mso-ansi-language:
EN-US'>Nlog</span><sub>2</sub>(<span
lang=EN-US style='mso-ansi-language:EN-US'>N</span>)). </b>Грубое обоснование –
процесс удвоения/деления пополам для каждого элемента имеет<b style='mso-bidi-font-weight:
normal'><a name="m43"> </b><b style='mso-bidi-font-weight:normal'><a name="m44"><span lang=EN-US
style='mso-ansi-language:EN-US'>log</span><sub>2</sub>(</b><b style='mso-bidi-font-weight:
normal'><a name="m45"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span>) </b>шагов, а
элементов всего <b style='mso-bidi-font-weight:normal'><a name="m46">N. </b>К этой группе
относятся все сортировки, основанные на использовании деревьев, слияние и
разделение (кроме однократного слияния). Среди них есть как нечувствительные к
данным, так и такие, у которых при определенных наборах данных трудоемкость
межет возрасти до <b style='mso-bidi-font-weight:normal'><a name="m47"><span lang=EN-US
style='mso-ansi-language:EN-US'>O</span>(</b><b style='mso-bidi-font-weight:
normal'><a name="m48"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span><sup>2</sup>) </b>(«быстрая»,
поразрядное и рекурсивное разделение, сортировка на двоичном дереве);</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l5 level1 lfo6;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>
<p><br
style='mso-ignore:vglayout' clear=ALL>
и, наконец, сортировки, использующие дополнительную память, могут иметь качественно
другие характеристики трудоемкости, вплоть до линейной <b style='mso-bidi-font-weight:
normal'><a name="m49">T(</b><b style='mso-bidi-font-weight:normal'><a name="m50"><span lang=EN-US
style='mso-ansi-language:EN-US'>N</span>)=2(</b><b style='mso-bidi-font-weight:
normal'><a name="m51"><span lang=EN-US style='mso-ansi-language:EN-US'>D</span>+</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>), <span lang=EN-US
style='mso-ansi-language:EN-US'>T</span>(</b><b style='mso-bidi-font-weight:
normal'><a name="m52"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span>)=</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>*<span lang=EN-US
style='mso-ansi-language:EN-US'>N</span></b> =&gt; <b style='mso-bidi-font-weight:
normal'><a name="m53"><span lang=EN-US style='mso-ansi-language:EN-US'>O</span>(</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>)</b> (распределяющий подсчет, лексикографическая, поразрядное
распределение).</p>
</p>

<p class=a align=center style='text-align:center'>
<img border="0" src="Images/046-02.jpg" width="461" height="301"></p>
<p class=a align=center style='text-align:center'>
<b style='mso-bidi-font-weight:
normal'><a name="m54">Рис 46.2. Трудоемкость алгоритмов сортировки и поиска<o:p></o:p></b></p>

<h3>Сортировки выбором и вставками</h3>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m55">«Дилетантская» сортировка. </b>Если
попросить не знающего содержание этого раздела написать функцию, выполняющую
упорядочение данных в массиве, то 90% напишут примерно так.</p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------</span>-------------46<span
lang=EN-US style='mso-ansi-language:EN-US'>-0</span>3<span lang=EN-US
style='mso-ansi-language:EN-US'>.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------ Дилетантская
сортировка<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int A[],
int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>        </span>for (int i=0; i&lt;n; i++)<o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for (int j=i; j&lt;n; j++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>        </span>if (A[i]&gt;A[j]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
           </span>int c=A[i]; A[i]=A[j];
A[j]=c;}<o:p></o:p></span></p>

<p class=a0 style='margin-left:36.0pt;text-indent:36.0pt'><span lang=EN-US
style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a4>В основе лежит логика здравого смысла. Необходимо переставлять
элементы массива, если они нарушают порядок, количество таких перестановок
должно соответствовать количеству возможных пар элементов, а это дает цикл в
цикле. Принцип сравнения «каждый с каждым» приводит к тому, что для каждого <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>-го </b>элемента необходимо просмотреть все последующие за ним
(второй цикл начинается с <b style='mso-bidi-font-weight:normal'><a name="m56"><span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>=</b><b style='mso-bidi-font-weight:
normal'><a name="m57"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span></b>). И
наконец, программа отражает справедливую убежденность большинства, что <b
style='mso-bidi-font-weight:normal'>за один цикл просмотра упорядочить массив
нельзя</b>.</p>

<p class=a4>Парадокс: несмотря на явное наличие обмена, эта сортировка
относится к группе сортировок выбором.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m58">Проверка упорядоченности. </b>Функция
проверки упорядоченности массива является живой иллюстрацией теоремы: массив
упорядочен, если упорядочена любая пара соседних элементов.</p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------</span>46<span
lang=EN-US style='mso-ansi-language:EN-US'>-0</span>4<span lang=EN-US
style='mso-ansi-language:EN-US'>.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//---- Проверка
упорядоченности массива<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int is_sorted(int a[], int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (int i=0; i&lt;n-1; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>if (a[i]&gt;a[i+1]) return 0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return</span> 1;}</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m59">Сортировка выбором. </b>На
каждом шаге сортировки из последовательности выбирается минимальный элемент и
переносится в конец выходной последовательности. Дальше вступают в силу детали
процесса, но характерным остается наличие двух независимых частей –
неупорядоченной (оставшихся элементов) и упорядоченной. При исключении
выбранного элемента из массива на его место может быть записано «очень большое
число», исключающее его повторный выбор. Выбранный элемент может удаляться
путем сдвига оставшейся части, минимальный элемент может меняться местами с
очередным.</p>

<p class=a>Следующий пример – один из многочисленных вариантов «мирного
сосуществования» упорядоченной и неупорядоченной частей в одном массиве.
Упорядоченная часть находится слева и ее размерность соответствует числу
выполненных шагов внешнего цикла. Неупорядоченная часть расположена справа,
поэтому поиск минимума с запоминанием индекса минимального элемента происходит
в интервале от <b style='mso-bidi-font-weight:normal'><a name="m60"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>-го </b>до конца массива.</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------46-05.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//---- Сортировка
выбором<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int
in[], int n){ <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for ( int i=0; i
&lt; n-1; i++){<span style='mso-spacerun:yes'>                </span><span
style='mso-tab-count:1'>         </span>// Для очередного i<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>for ( int j=i+1, k=i; j&lt;n; j++)<span style='mso-spacerun:yes'>     
</span>// k - индекс минимального<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>if (in[j] &lt; in[k]) k=j;<span
style='mso-spacerun:yes'>                    </span><span style='mso-tab-count:
1'>            </span>// в диапазоне i..n-1<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>int</span><span lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>c</span>=<span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>]; <span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>] = <span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>]; <span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>] = <span lang=EN-US style='mso-ansi-language:EN-US'>c</span>; <span
style='mso-tab-count:1'>           </span>// Три стакана для очередного</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>  </span>}}<span
style='mso-spacerun:yes'>                                            </span><span style='mso-tab-count:1'>            </span>//
и минимального</p>

<p class=a4>В сортировке выбором контекст выбора минимального элемента обычно
заметен «невооруженным глазом». Но в следующем варианте он совмещен с процессом
обмена, и потому не виден: минимальный элемент сразу же перемещается на
очередную позицию.</p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------46-06.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//---- «Законспирированная» сортировка выбором</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>sort</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>){ </p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for ( int i=0; i &lt; n-1; i++)<span
style='mso-spacerun:yes'>                   </span><span style='mso-tab-count:
1'>      </span>// Для очередного i<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for ( int j=i+1, k=i; j&lt;n; j++)<span
style='mso-spacerun:yes'>               </span><span style='mso-tab-count:1'>     </span>//
Для всех оставшихся <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>if (in[j] &lt; in[ i]) {<span
style='mso-spacerun:yes'>                     </span><span style='mso-tab-count:
1'>   </span>// в диапазоне i..n-1<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]; <span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>] = <span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>]; <span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>] = <span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>; <span style='mso-tab-count:1'>         </span>//
сразу же менять с очередным</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>}}<span
style='mso-spacerun:yes'>                                         </span><span
style='mso-tab-count:2'>                       </span>// Выбор совмещен с обменом</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m61">Сортировка вставками. </b>Основная
идея алгоритма: имеется упорядоченная часть, в которую очередной элемент
помещается так, что упорядоченность сохраняется (включение с сохранением
порядка). Технические детали: можно проводить линейный поиск от начала упорядоченной
части до первого большего, чем включаемый, использовать двоичный поиск места в
упорядоченной части. Сама процедура вставки включает в себя перемещение
элементов массива. В следующем примере последовательность действий по вставке
очередного элемента в упорядоченную часть «разложена по полочкам» в виде
последовательности четырех действий, связанных переменными (извлечение, поиск
места, сдвиг, вставка). </p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------46-07.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>//---- Простая вставка</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>sort</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>){ </p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for</span> ( <span lang=EN-US style='mso-ansi-language:
EN-US'>int i=1; i &lt; n; i++) {<span style='mso-spacerun:yes'>              
</span><span style='mso-tab-count:1'>          </span>// Для очередного i<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>           </span>int</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>v</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>];<span
style='mso-spacerun:yes'>                         </span><span style='mso-tab-count:1'>         </span>//
сохранить очередной</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span style='mso-tab-count:
1'>           </span><span lang=EN-US style='mso-ansi-language:EN-US'>for</span>
(<span lang=EN-US style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>=0; <span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>; <span lang=EN-US style='mso-ansi-language:EN-US'>k</span>++)<span
style='mso-spacerun:yes'>           </span><span style='mso-tab-count:1'>      </span>//
поиск места вставки</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
2'>                  </span><span lang=EN-US style='mso-ansi-language:EN-US'>if</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>]&gt;<span lang=EN-US style='mso-ansi-language:
EN-US'>v</span>) <span lang=EN-US style='mso-ansi-language:EN-US'>break</span>;<span
style='mso-spacerun:yes'>          </span><span style='mso-tab-count:1'>   </span>//
перед первым, большим <span lang=EN-US style='mso-ansi-language:EN-US'>v</span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for(int j=i-1; j&gt;=k; j--)<span style='mso-spacerun:yes'>   </span><span
style='mso-tab-count:2'>                </span>// c</span>двиг<span
style='mso-ansi-language:EN-US'> </span>на<span lang=EN-US style='mso-ansi-language:
EN-US'> 1 </span>вправо<span lang=EN-US style='mso-ansi-language:EN-US'> <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span></span><span
style='mso-tab-count:1'>            </span><span lang=EN-US style='mso-ansi-language:
EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>j</span>+1]=<span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>j</span>];<span
style='mso-spacerun:yes'>                </span><span style='mso-tab-count:
1'>   </span>// от очередного до найденного</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span style='mso-tab-count:
1'>           </span><span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>]=<span lang=EN-US
style='mso-ansi-language:EN-US'>v</span>;<span
style='mso-spacerun:yes'>                     </span><span style='mso-tab-count:
1'>     </span><span style='mso-tab-count:1'>            </span>// вставка
очередного на место</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span style='mso-tab-count:
1'>           </span>}}<span
style='mso-spacerun:yes'>                               </span><span
style='mso-tab-count:2'>               </span>// первого, большего него</p>

<p class=a4><span style='mso-spacerun:yes'> </span>В сортировке выбором нет
характерных программных контекстов, «ответственных» за вставку: характер
программы определяется циклом поиска места вставки, который корректно работает
только на упорядоченных данных. Таким образом, получается замкнутый круг для
логического анализа, разрываемый только доказательством, основанным на методе
математической индукции: вставка на <b style='mso-bidi-font-weight:normal'><a name="m62"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>-ом </b>шаге выполняется
корректно в упорядоченных данных, подготовленных аналогичным <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>-1-ым</b> шагом и т.д до 0.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m63">Вставка погружением.</b> Очередной
элемент <span style='font-family:"Times New Roman"'>«</span>погружается<span
style='font-family:"Times New Roman"'>»</span> путем ряда обменов с предыдущим
до требуемой позиции в уже упорядоченную часть массива, пока «не достигнет
дна», либо пока не встретит элемент, меньший себя. Наличие контекста «трех
стаканов» делает его подозрительно похожим на обменную сортировку, но это не
так.</p>

<p class=a><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------46-08.cpp</p>

<p class=a0>//----- Вставка погружением, подозрительно похожая на обмен</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void sort(int in[],int n) {<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>for ( int i=1; i&lt;n; i++) <span
style='mso-tab-count:2'>                </span>// Пока не достигли &quot;
дна&quot; или меньшего себя</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>  </span><span lang=EN-US style='mso-ansi-language:
EN-US'>for ( int k=i; k !=0 &amp;&amp; in[k] &lt; in[k-1]; k--){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>int c=in[k]; in[k]=in[k-1]; in[k-1]=c;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">      </span>}} </p>

<p class=a4>
<img border="0" src="Images/yan-in.jpg" width="34" height="31" align="left">Небольшое
техническое замечание. Сортировка начинается с <b style='mso-bidi-font-weight:
normal'><a name="m64">i=1</b>. Это соответствует погружению второго элемента в упорядоченную
последовательность единичной длины, что порождает схоластический вопрос: является
ли последовательность из одного элемента упорядоченной или нет. Можно смело
сказать: является.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m65">Сортировка Шелла. </b>Существенными
в сортировках вставками (или обмена) являются затраты на обмены или сдвиги
элементов. Для их уменьшения желательно сначала производить погружение с
большим шагом, сразу определяя элемент «по месту», а затем делать точную
«подгонку». Так поступает <b style='mso-bidi-font-weight:normal'><a name="m66">сортировка
Шелла</b>: исходный массив разбивается на m частей, в каждую из которых
попадают элементы с шагом m, начиная от 0,1,...,m-1 соответственно, то есть </p>

<p class=a6><o:p>&nbsp;</o:p></p>

<p class=a6><span style='mso-spacerun:yes'>     </span>0 , m<span
style='mso-spacerun:yes'>  </span>, 2m<span style='mso-spacerun:yes'>  </span>,
3m<span style='mso-spacerun:yes'>  </span>,...</p>

<p class=a6><span style='mso-spacerun:yes'>     </span>1 , m+1, 2m+1, 3m+1,...</p>

<p class=a6><span style='mso-spacerun:yes'>     </span>2 , m+2, 2m+2, 3m+2,...</p>

<p class=a4>Каждая часть сортируется отдельно с использованием алгоритма
вставок или обмена. Затем выбирается меньший шаг, и алгоритм повторяется. Шаг можно
выбрать равным степени 2, например 64,32,16,8,4,2,1. Тогда на каждом следующем
шаге происходит объединение каждых двух уже упорядоченных групп в одну. </p>

<p class=a>Сортировка Шелла требует четырех вложенных циклов: по шагу
сортировки (по уменьшающимся степеням 2 – <b style='mso-bidi-font-weight:normal'><a name="m67"><span
lang=EN-US style='mso-ansi-language:EN-US'>m</span>=64,32,16…),</b> по группам
– (по индексу первого элемента в диапазоне <b style='mso-bidi-font-weight:normal'><a name="m68"><span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>=0…</b><b style='mso-bidi-font-weight:
normal'><a name="m69"><span lang=EN-US style='mso-ansi-language:EN-US'>s</span>-1</b>), а
затем два цикла обычной сортировки погружением для элементов группы,
начинающейся с <b style='mso-bidi-font-weight:normal'><a name="m70"><span lang=EN-US
style='mso-ansi-language:EN-US'>k</span></b><span lang=EN-US> </span>с шагом <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>m</span></b>. Для двух последних циклов нужно взять базовый алгоритм,
заменив шаг <b style='mso-bidi-font-weight:normal'><a name="m71">1</b> на <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>m</span></b> и поменяв границы сортировки.<span style='font-family:"Courier New CYR";
mso-bidi-font-family:"Times New Roman"'><o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//-----------------------------------------------------------------46-09.cpp</p>

<p class=a0>//------ Сортировка Шелла с шагом по степеням 2 (погружение)</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void shell(int
A[], int n ){<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>for (int m=1; m&lt;n; m*=2);<span
style='mso-tab-count:1'>                       </span>//
Определение последней степени 2</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for (m/=2; m!=0;
m/=2)<span style='mso-spacerun:yes'>          </span><span style='mso-tab-count:
2'>                 </span>// Цикл с переменным шагом m=32,16,8..1</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>    </span>for (int k=0; k&lt;m; k++)<span
style='mso-spacerun:yes'>         </span><span style='mso-tab-count:2'>              </span>//
Цикл по группам k=0..m-1</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>        </span>for (int i=k+m; i&lt;n; i+=m)<span
style='mso-tab-count:1'>                </span>//
Погружение с шагом с в группе k</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>            
</span>for (int j=i; j&gt;=m &amp;&amp; A[j]&lt;A[j-m]; j-=m){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>                        </span><span
style='mso-spacerun:yes'>    </span>int cc = A[j]; A[j]=A[j-m]; A[j-m]=cc;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a>Предыдущий пример демонстрирует «правильный» подход, основанный на
постановке задачи: каждая группа сортируется отдельно и для их перебора
используется отдельный цикл (с переменной <b style='mso-bidi-font-weight:normal'><a name="m72"><span
lang=EN-US style='mso-ansi-language:EN-US'>k</span></b>). На самом деле его
можно объединить со следующим, производя погружение сразу по всем группам в
одном цикле. Кроме того, последовательность шагов погружения можно выбрать
другой, тогда при переходе к следующему шагу группы будут перемешиваться между
собой. Например, при формуле шага <b style='mso-bidi-font-weight:normal'><a name="m73">h<sub>i+1</sub>=3h<sub>i</sub>+1</b>
<b style='mso-bidi-font-weight:normal'><a name="m74">(1,4,13,40,121…) </b>трудоемкость
сортировки оценивается как <b style='mso-bidi-font-weight:normal'><a name="m75">O(<span lang=EN-US style='mso-ansi-language:
EN-US'>N</span><sup>3/2</sup>).</b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------------------46-10.cpp</p>

<p class=a0>// Сортировка Шелла. Формула<span style='mso-spacerun:yes'> 
</span>шаг<span lang=EN-US style='mso-ansi-language:EN-US'>а</span> h=3h+1</p>

<p class=a0>// Погружение с уменьшающимся шагом</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int A[],
int n){<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>int i,j,h;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for (h=1;
h&lt;n/9; h=h*3+1);<span style='mso-tab-count:1'>           </span>//
Определить максимальный шаг</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for
(;h&gt;0;h=h/3)<span style='mso-tab-count:3'>                          </span>//
Одновременно просматриваются все группы</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>      </span><span lang=EN-US style='mso-ansi-language:
EN-US'>for</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>h</span>;<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>;<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++)<span
style='mso-tab-count:2'>                    </span>// Погружение с шагом <span
lang=EN-US style='mso-ansi-language:EN-US'>h</span></p>

<p class=a0><span style='mso-tab-count:1'>                        </span><span lang=EN-US style='mso-ansi-language:
EN-US'>for (j=i;j&gt;=h &amp;&amp; A[j]&lt;A[j-h];j-=h)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span><span
style='mso-spacerun:yes'>      </span>{ int c=A[j]; A[j]=A[j-h]; A[j-h]=c; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>}<span style='mso-tab-count:5'>                                                           </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<h3>Обменные сортировки</h3>

<p class=a>Обменная сортировка представляет собой самое прямолинейное решение
проблемы: если в упорядоченной последовательности все пары<span
style='mso-spacerun:yes'>  </span>соседних элементов упорядочены, то нужно
достаточно долго переставлять «неправильные» пары, пока порядок не установится.
Как мы уже знаем, для этого достаточно двойного цикла. Первая оптимизация
состоит в том, что сортировку можно прекратить, если при просмотре всех пар от
начала да конца перестановок не будет.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//-----------------------------------------------------------46-11.cpp</p>

<p class=a0>//------Обменная сортировка &quot;пузырьком&quot;</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void sort(int A[], int n){</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int i,found;<span
style='mso-tab-count:3'>                                </span>// Количество обменов</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>do {<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">                              </span><span style='mso-tab-count:
1'>       </span><span lang=EN-US style='mso-ansi-language:EN-US'>// </span>Повторять<span
style='mso-ansi-language:EN-US'> </span>просмотр<span lang=EN-US
style='mso-ansi-language:EN-US'>...<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>found =0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>for (i=0; i&lt;n-1; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>                </span>if (A[i] &gt; A[i+1]) {<span
style='mso-spacerun:yes'>    </span><span style='mso-tab-count:1'>    </span>//
</span>Сравнить<span style='mso-ansi-language:EN-US'> </span>соседей<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>           </span>int cc = A[i]; A[i]=A[i+1];
A[i+1]=cc;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">           </span>found++;<span
style='mso-spacerun:yes'>                     </span>
<span style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">   </span>//
Переставить соседей </p>

<p class=a0><span style='mso-spacerun:yes'>           </span>}</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>} while(found !=0);
}<span style='mso-spacerun:yes'>             </span><span style='mso-tab-count:
1'>  </span>//...пока есть перестановки </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Обменные сортировки имеют ряд особенностей. Прежде всего, они
чувствительны к степени исходной упорядоченности массива. Полностью
упорядоченный массив будет просмотрен один раз, в то время как выбор или
вставка будут «изображать бурную деятельность». Кроме того, имеется несколько
свойств, на котором основана их оптимизация. Они непосредственно не наблюдаемы
в тексте программы, ему не соответствуют никакие программные контексты и они
выводятся только «историческим» анализом программы (см. также <b
style='mso-bidi-font-weight:normal'>2.6</b>).</p>

<p class=a>Эффект «пузырька» состоит в том, что в последовательности сравнений
и обменов пар наибольший элемент захватывается и «всплывает» до тех пор, пока
не встретит большего себя. Этот элемент становится новым пузырьком и т.д.. Другой
эффект, который можно увидеть только непосредственным наблюдением: от места
последней перестановки будет находиться упорядоченная часть.</p>

<p class=a style="text-align: center"><o:p>&nbsp;<img border="0" src="Images/046-05.gif" width="617" height="164"></o:p></p>

<p class=a align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m76">Рис 46.3. Образование «пузырька» в обменной сортировке.<o:p></o:p></b></p>

<p class=a>Исходя из установленного свойства, просмотр имеет смысл делать не до
конца массива, а до последней перестановки, выполненной на предыдущем
просмотре. Для этой цели в программе обменной сортировки необходимо запоминать
индекс переставляемой пары, который по завершении внутреннего цикла просмотра и
будет индексом последней перестановки. Кроме того, необходима переменная –
граница упорядоченной части, которая должна при переходе к следующему шагу
получать значение пресловутого индекса последней перестановки. Условие
окончания – граница сместится к началу массива.</p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a0>//---------------------------------------------------------46-12.cpp</p>

<p class=a0>//------------ Однонаправленная Шейкер-сортировка</p>

<p class=a0><span style='mso-spacerun:yes'> </span>void sort(int A[], int n){</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int i,b,b1;<span
style='mso-spacerun:yes'>                       </span><span style='mso-tab-count:
1'>           </span><span style='mso-tab-count:2'>                        </span>//
b граница отсортированной части </p>

<p class=a0><span style='mso-spacerun:yes'> </span>for (b=n-1; b!=0; <b
style='mso-bidi-font-weight:normal'>b=b1</b>) { <span style='mso-tab-count:
1'>           </span><span style='mso-tab-count:1'>            </span>// Пока
граница не сместится к правому краю </p>

<p class=a0 style='text-indent:36.0pt'>b1=0;<span
style='mso-spacerun:yes'>                         </span><span
style='mso-tab-count:1'>               </span>//
b1 место последней перестановки</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
1'>      </span><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0;
i&lt;b; i++)<span style='mso-spacerun:yes'>           </span><span
style='mso-tab-count:2'>             </span>// </span>Просмотр<span
style='mso-ansi-language:EN-US'> </span>массива<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>           </span><span style='mso-tab-count:2'>             </span>if
(A[i] &gt; A[i+1]) {<span style='mso-spacerun:yes'>   </span><span
style='mso-tab-count:1'>         </span>// </span>Перестановка<span
style='mso-ansi-language:EN-US'> </span>с<span style='mso-ansi-language:EN-US'>
</span>запоминанием<span style='mso-ansi-language:EN-US'> </span>места<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'>
<span style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">           </span><span lang=EN-US style='mso-ansi-language:EN-US'>int
cc = A[i]; A[i]=A[i+1]; A[i+1]=cc;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">           </span><span style='mso-tab-count:
2'>             </span><b style='mso-bidi-font-weight:normal'><a name="m77"><span lang=EN-US
style='mso-ansi-language:EN-US'>b1=</span>i</b>; </p>

<p class=a0><span style='mso-spacerun:yes'>           </span>}}}</p>

<p class=a>Если же просмотр делать попеременно в двух направлениях и
фиксировать нижнюю и верхнюю границы неупорядоченной части, то получим <b
style='mso-bidi-font-weight:normal'>шейкер – сортировку</b>.<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=MsoPlainText style='mso-list:none'><span style='font-size:10.0pt;
font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------------------46-13.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//-------------- </span>Шейкер<span
lang=EN-US style='mso-ansi-language:EN-US'> - </span>сортировка<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void shake(int
A[],int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int
z=1,a=0,b=n-1,i,last=0;<span style='mso-tab-count:3'>                                  </span>//
a,b - </span>границы<span lang=EN-US style='mso-ansi-language:EN-US'>, z - </span>направление<span
lang=EN-US style='mso-ansi-language:EN-US'> (</span>шаг<span lang=EN-US
style='mso-ansi-language:EN-US'>)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0;<span lang=EN-US
style='mso-ansi-language:EN-US'>a</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>b</span>;){<span style='mso-tab-count:5'>                                                     </span>//
цикл – пока границы не сойдутся</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(A[i]&gt;A[i+1]){<span style='mso-tab-count:4'>                                       </span>//
обмен с запоминанием места</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>int c=A[i];A[i]=A[i+1];A[i+1]=c;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>last=i;</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>i+=z;<span
style='mso-tab-count:5'>                                                     </span>//
шаг в текущем направлении</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (i==b ||
i&lt;a) {<span style='mso-tab-count:4'>                                       </span>//
достинута граница ???</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(z&gt;0) i=b=last;<span style='mso-tab-count:3'>                                    </span>//
место перестановки - новая</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>else
i=a=last+1;<span style='mso-tab-count:2'>             </span><span
style='mso-tab-count:1'>            </span>// граница слева или справа</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>z=-z;<span
style='mso-tab-count:4'>                                         </span>//
направление противоположное</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}}}</p>

<p class=a>Попеременное движение в двух направлениях удается сделать введением
переменной <b style='mso-bidi-font-weight:normal'><a name="m78"><span lang=EN-US
style='mso-ansi-language:EN-US'>z</span><span lang=EN-US> </span>–</b>шага,
принимающей значения <b style='mso-bidi-font-weight:normal'><a name="m79">+1/-1</b>. Сама же
сортировка программа содержит единственный цикл, который выполняет сравнение
очередной пары, переход к следующей и контроль границ, пока границы не
сойдутся.</p>

<h3>Сортировки распределением</h3>

<p class=a>Идея распределения состоит в том, чтобы «разбрасывать» элементы,
сообразуясь с их собственными свойствами, либо со свойствами по отношению к
другим. Сама идея разбрасывания требует наличия дополнительной памяти, за счет
чего можно принципиально снизить трудоемкость. Соответствующие примеры будут
рассмотрены позднее в <b style='mso-bidi-font-weight:normal'><a name="m80">7.7</b>. Здесь же
приведем <b style='mso-bidi-font-weight:normal'><a name="m81">сортировку подсчетом. </b>Идея
алгоритма: количество элементов, меньше текущего, определяет его позицию
(индекс) в выходном массиве. Наличие переменной-счетчика и использование его
как индекса в выходном массиве являются хорошо заметными программными контекстами.
Трудоемкость алгоритма при любых данных <b style='mso-bidi-font-weight:normal'><a name="m82"><span
lang=EN-US style='mso-ansi-language:EN-US'>T</span><sub>cp</sub>=N<sup>2</sup>.</b><span
style='font-size:10.0pt;font-family:"Courier New"'><o:p></o:p></span></p>

<p class=MsoPlainText style='mso-list:none'><span lang=EN-US style='font-size:
10.0pt;font-family:"Courier New";mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//--------------------------------------------</span>--------<span
lang=EN-US style='mso-ansi-language:EN-US'>-----46-14.cpp</span></p>

<p class=a0>//---------<span style='mso-spacerun:yes'>  </span>Сортировка
подсчетом</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int
in[],int n){ <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i,j,cnt;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int *out=new
int[n];<span style='mso-tab-count:3'>                                 </span>//
</span>выходной<span style='mso-ansi-language:EN-US'> </span>массив<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>for (i=0; i&lt;n; i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for ( cnt=0,j=0; j&lt;n; j++)<span
style='mso-tab-count:1'>              </span>//
</span>для<span lang=EN-US style='mso-ansi-language:EN-US'> in[i] </span>подсчет<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>               </span>if (in[j] &lt; in[i]) cnt++;<span
style='mso-tab-count:2'>               </span>// </span>меньших<span
style='mso-ansi-language:EN-US'> </span>его<span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span></span>else<span
style='mso-tab-count:4'>                                          </span>// а
также равных ему </p>

<p class=a0><span style='mso-spacerun:yes'>                 </span><span lang=EN-US style='mso-ansi-language:
EN-US'>if (in[j]==in[i] &amp;&amp; j&gt;i) cnt++;<span style='mso-tab-count:
1'>    </span>// </span>и<span style='mso-ansi-language:EN-US'> </span>стоящих<span
style='mso-ansi-language:EN-US'> </span>слева<span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span></span>out[cnt]=in[i];<span
style='mso-tab-count:3'>                             </span>// место в выходном</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
1'>      </span><span lang=EN-US style='mso-ansi-language:EN-US'>} <span
style='mso-tab-count:4'>                                              </span></span>//
определяется счетчиком</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0; i&lt;n;
i++) in[i]=out[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>delete []out;}<o:p></o:p></span></p>

<p class=MsoPlainText style='mso-list:none'><span lang=EN-US style='font-size:
10.0pt;font-family:"Courier New";mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>Ситуация, требующая отдельного рассмотрения – наличие одинаковых
элементов (допустим, <b style='mso-bidi-font-weight:normal'><a name="m83">m</b>). Они будут
иметь одинаковые счетчики и, следовательно, попадут в одну и ту же ячейку.
Последующие же <b style='mso-bidi-font-weight:normal'><a name="m84">m-1</b> элементов
окажутся незаполненными. Для исправления ошибки одинаковым элементам нужно
придать разный «вес» в зависимости от их взаимного положения. Поэтому элемент
считает равные ему элементы, стоящие слева, «меньшими себя».</p>

<h3>Сортировки разделением/слиянием</h3>

<p class=a>Как уже отмечалось, сортировки этого типа используются повторяющийся
процесс разделения исходной последовательности на части с последующим их
соединением обратно. При этом на одном этапе происходит изменение порядка
следования<span style='mso-spacerun:yes'>  </span>элементов, а другой является
чисто формальным. Сами процессы разделения и слияния рассмотрены были в <b
style='mso-bidi-font-weight:normal'>2.4 </b>как примеры с независимыми
перемещениями в массиве.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m85">Сортировки рекурсивным
разделением. </b>Сортировки разделяют массив на две части относительно
некоторого значения, называемого <b style='mso-bidi-font-weight:normal'><a name="m86">медианой</b>.
Медианой может быть выбрано любое «среднее» значение, например, среднее
арифметическое. Сами части не упорядочены, но обладают таким свойством, что
элементы в левой части меньше медианы, а элементы правой - больше. Благодаря
такому свойству эти части можно сортировать независимо. Для этого нужно вызвать
ту же самую функцию сортировки, но уже не по отношению к массиву, а к его
частям. Функции, вызывающие сами себя, называются рекурсивными (см. <b
style='mso-bidi-font-weight:normal'>7.1</b>). Рекурсивный вызов продолжается до
тех пор, пока очередная часть массива не станет содержать единственный элемент.
Так будет выглядеть «заготовка» сортировки разделением, использующая простейший
способ реализации разделения, приведенный в <b style='mso-bidi-font-weight:
normal'><a name="m87">2.4</b>.<span style='mso-spacerun:yes'>  </span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//----------------------------------------------------------------------------------------<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int
in[],int a,int b){<o:p></o:p></span></p>

<p class=a0>if (a&gt;=b) return;<span style='mso-tab-count:3'>                          </span><span
style='mso-tab-count:1'>            </span>// осталось не более 1 элемента -
выход</p>

<p class=a0>int i,j,k,n1=b-a+1;<span style='mso-tab-count:3'>                                   </span>//
размерность интервала</p>

<p class=a0>int *out=new tmp[b-a+1];<span style='mso-tab-count:2'>                        </span>//
временный массив для разделения</p>

<p class=a0>double s;<span style='mso-ansi-language:EN-US'> </span>...<span
style='mso-tab-count:4'>                                           </span>//
вычислить медиану, например (min+max)/2</p>

<p class=a0>for(i=a,j=0,k=n1-1;i&lt;=b;i++)<span style='mso-tab-count:2'>                    </span>//
цикл разделения из 2.4 с учетом </p>

<p class=a0>...<span style='mso-tab-count:5'>                                                         </span>//
начала интервала – a</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>If</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>!=0){<span style='mso-tab-count:
5'>                                                 </span>// если все элементы
одинаковые - </p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>sort</span>(<span lang=EN-US style='mso-ansi-language:EN-US'>tmp</span>,0,<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>);<span style='mso-tab-count:
3'>                             </span>// разделения не будет</p>

<p class=a0 style='text-indent:36.0pt'>sort(tmp,j,n-1);<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>}<o:p></o:p></span></p>

<p class=a0>for(i=a,j=0;i&lt;=b;i++,j++) in[i]=tmp[j];<span style='mso-tab-count:
1'>        </span>// вернуть отсортированные данные</p>

<p class=a0>delete []tmp;}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m88">Сортировки слиянием</b>
использует слияние упорядоченных последовательностей. Разделение исходной
последовательности на части носит формальный характер. Рекурсивное разделение
рассматривается в <b style='mso-bidi-font-weight:normal'><a name="m89">7.2. Простое
однократное слияние</b> является прекрасной иллюстрацией, как можно достигнуть
более высокой эффективности только за счет выполнения любой работы по частям с
последующим объединением результатов.<span style='mso-spacerun:yes'>  
</span>Исходный массив разбивается на <b style='mso-bidi-font-weight:normal'><a name="m90"><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span></b><span lang=EN-US> </span>частей,
каждая из них сортируется независимо, а затем отсортированные части
объединяются<span style='mso-spacerun:yes'>  </span>слиянием. Алгоритм слияния
использует стандартные контексты: выбирается строка, в которой первый элемент
является минимальным (минимальный из очередных), который «сливается» в выходную
последовательность. Исключение его производится путем сдвига содержимого строки
к началу, причем в конец добавляется «очень большое число», играющее роль
«затычки» при окончании этой последовательности. Двумерный массив произвольной
размерности реализован с использованием динамического массива указателей (<b
style='mso-bidi-font-weight:normal'>см.6.3</b>), который при работе даже
синтаксически выглядит как обычный. Естественно, что при произвольной
размерности входного массива, последняя строка двумерного будет неполной.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------------------------46-1<span
lang=EN-US style='mso-ansi-language:EN-US'>5</span>.cpp</p>

<p class=a0>//------- Простое однократное слияние</p>

<p class=a0>void sort(int a[], int n);<span style='mso-tab-count:2'>                 </span>//
любая сортировка одномерного массива</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void big_sort(int
A[], int N){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int
max=A[0],i,j,n=sqrt(N)+1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int **B=new int*[n];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for (i=0; i&lt;n; i++) B[i]=new
int[n];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for (i=0; i&lt;N; i++) {<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>B[i/n][i%n]=A[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>if (A[i]&gt;max)
max=A[i];<span style='mso-tab-count:3'>                           </span>// </span>Распределение<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for (j=n*n-N;
j&lt;n;j++)<span style='mso-tab-count:4'>                                           </span>//
Заполнение &quot;хвоста&quot; последнего</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>B[n-1][j]=max+1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for (i=0; i&lt;n; i++) sort(B[i],n);<span
style='mso-tab-count:1'>       </span><span style='mso-tab-count:2'>                        </span>//
</span>Сортировка<span style='mso-ansi-language:EN-US'> </span>частей<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for (i=0; i&lt;N; i++){<span
style='mso-spacerun:yes'>               </span><span style='mso-tab-count:3'>                               </span>//
</span>Слияние<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>for ( int k=0, j=0; j&lt;n;
j++)<span style='mso-tab-count:2'>                       </span><span
style='mso-tab-count:1'>            </span>// Индекс строки с минимальным </p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(B[j][0] &lt; B[k][0]) k=j;<span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:2'>                       </span>// начальным B[k][0]</p>

<p class=a0><span style='mso-tab-count:1'>            </span>A[i] =
B[k][0];<span style='mso-spacerun:yes'>                     </span><span
style='mso-tab-count:3'>                               </span>// Перенос
элемента</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for (j=1; j&lt;n;
j++) </p>

<p class=a0><span style='mso-tab-count:2'>                        </span>B[k][j-1]=B[k][j];<span
style='mso-tab-count:4'>                                     </span>// Сдвиг
сливаемой строки</p>

<p class=a0><span style='mso-tab-count:1'>            </span>B[k][n-1]=max+1;<span
style='mso-spacerun:yes'>                  </span><span style='mso-tab-count:
3'>                             </span>// Запись ограничителя</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0; i&lt;n;
i++) delete []B[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>delete []B;}<o:p></o:p></span></p>

<p class=MsoPlainText style='mso-list:none'><span lang=EN-US style='font-size:
10.0pt;font-family:"Courier New";mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>При оценке трудоемкости будем использовать «принцип квадрата» - из
всех прямоугольников с заданным периметром максимальная площадь будет у
квадрата. Не утруждая себя доказательством (а его достаточно просто провести по
аналогии), будем считать, что линейный массив разбивается на <b
style='mso-bidi-font-weight:normal'>n=<span
style='mso-bidi-font-family:"Times New Roman CYR"'>&#8730;</span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m91"><span lang=EN-US style='mso-bidi-font-family:"Times New Roman CYR"'> </span></b><span
style='mso-bidi-font-family:"Times New Roman CYR"'>частей размерности <b
style='mso-bidi-font-weight:normal'>n. </b>Предположим, что мы используем самую
неэффективную сортировку частей с <span
style='mso-spacerun:yes'> </span>оценкой трудоемкости <b style='mso-bidi-font-weight:
normal'><a name="m92">O(</b></span><b style='mso-bidi-font-weight:normal'><a name="m93"><span lang=EN-US
style='mso-bidi-font-family:"Times New Roman CYR";mso-ansi-language:EN-US'>n</span><sup><span style='mso-bidi-font-family:
"Times New Roman CYR"'>2</span></sup><span
style='mso-bidi-font-family:"Times New Roman CYR"'>), </span></b><span
style='mso-bidi-font-family:"Times New Roman CYR"'>например, сортировку выбором
с трудоемкостью сравнений <b style='mso-bidi-font-weight:normal'><a name="m94">T<sub>ср</sub>=</b></span><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>n</span></b><b style='mso-bidi-font-weight:
normal'><a name="m95"><sup><span style='mso-bidi-font-family:"Times New Roman CYR"'>2</span></sup></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>/2</span></b><span
style='mso-bidi-font-family:"Times New Roman CYR"'>. Тогда независимая
сортировка частей даст нам </span><b style='mso-bidi-font-weight:normal'><a name="m96"><span
lang=EN-US style='mso-bidi-font-family:"Times New Roman CYR";mso-ansi-language:
EN-US'>n</span><span
style='mso-bidi-font-family:"Times New Roman CYR"'>T<sub>ср </sub>= </span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>n</span></b><b style='mso-bidi-font-weight:
normal'><a name="m97"><sup><span style='mso-bidi-font-family:"Times New Roman CYR"'>3</span></sup></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>/2
= </span><span lang=EN-US
style='mso-bidi-font-family:"Times New Roman CYR";mso-ansi-language:EN-US'>N</span><sup><span style='mso-bidi-font-family:
"Times New Roman CYR"'>3/2</span></sup><span
style='mso-bidi-font-family:"Times New Roman CYR"'>/2. </span></b><span
style='mso-bidi-font-family:"Times New Roman CYR"'>При слиянии мы переносим <b
style='mso-bidi-font-weight:normal'>N</b> элементов, для каждого из которых
используется выбор минимального из не более чем <b style='mso-bidi-font-weight:
normal'><a name="m98">n</b> элементов, т.е. оценка трудоемкости слияния </span><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>T</span></b><b style='mso-bidi-font-weight:
normal'><a name="m99"><sub><span style='mso-bidi-font-family:"Times New Roman CYR"'>ср</span></sub></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>(</span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m100"><span style='mso-bidi-font-family:"Times New Roman CYR"'>) =</span></b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>nN</span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR"'> </span><span
style='mso-bidi-font-family:"Times New Roman CYR"'>= </span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m101"><sup><span style='mso-bidi-font-family:"Times New Roman CYR"'>3/2</span></sup></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>.
</span></b><span style='mso-bidi-font-family:"Times New Roman CYR"'>В целом
получим <b style='mso-bidi-font-weight:normal'><a name="m102"><span
style='mso-spacerun:yes'> </span></b></span><b style='mso-bidi-font-weight:
normal'><a name="m103"><span lang=EN-US style='mso-bidi-font-family:"Times New Roman CYR";
mso-ansi-language:EN-US'>T</span></b><b style='mso-bidi-font-weight:normal'><a name="m104"><sub><span
style='mso-bidi-font-family:"Times New Roman CYR"'>ср</span></sub><span style='mso-bidi-font-family:"Times New Roman CYR"'>(</span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m105"><span style='mso-bidi-font-family:"Times New Roman CYR"'>) = 1.5</span></b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m106"><sup><span style='mso-bidi-font-family:"Times New Roman CYR"'>3/2</span></sup></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>
= </span><span lang=EN-US
style='mso-bidi-font-family:"Times New Roman CYR";mso-ansi-language:EN-US'>O</span><span style='mso-bidi-font-family:"Times New Roman CYR"'>(</span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m107"><sup><span style='mso-bidi-font-family:"Times New Roman CYR"'>3/2</span></sup></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>).</span></b><span
style='mso-bidi-font-family:"Times New Roman CYR"'>Т.е. только за счет
«организационных мер» удалось уменьшить трудоемкость с исходной <b
style='mso-bidi-font-weight:normal'>N<sup>2</sup>/2 </b>до<span
style='mso-spacerun:yes'>  </span><b style='mso-bidi-font-weight:normal'><a name="m108">1.5</b></span><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR";mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:
normal'><a name="m109"><sup><span style='mso-bidi-font-family:"Times New Roman CYR"'>3/2</span></sup></b><b
style='mso-bidi-font-weight:normal'><span style='mso-bidi-font-family:"Times New Roman CYR"'>,
</span></b><span style='mso-bidi-font-family:"Times New Roman CYR"'>т.е. в <b
style='mso-bidi-font-weight:normal'>&#8730;</b></span><b style='mso-bidi-font-weight:
normal'><a name="m110"><span lang=EN-US style='mso-bidi-font-family:"Times New Roman CYR";
mso-ansi-language:EN-US'>N</span></b><b style='mso-bidi-font-weight:normal'><a name="m111"><span
style='mso-bidi-font-family:"Times New Roman CYR"'>/3 </span></b><span
style='mso-bidi-font-family:"Times New Roman CYR"'>раза. <o:p></o:p></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m112">Циклическое слияние. </b>Все
сортировки так или иначе меняют элементы местами. При этом позиции элементов, с
которыми работает программа, меняются нерегулярным (произвольным) образом.
Например, в сортировке выбором позиция минимального элемента «случайна». Даже в
тех случаях, когда индексы движутся по массиву линейно, обмен также происходит
между произвольными парами. Это называется <b style='mso-bidi-font-weight:normal'><a name="m113">произвольным
доступом. </b>Циклическое слияние оригинально уже тем, что использует <b
style='mso-bidi-font-weight:normal'>только последовательный просмотр </b>и
перемещение элементов, что внешне воспринимается как «сортировки без
сортировки». Сортировка базируется на том факте, что при слиянии двух
упорядоченных последовательностей длиной <b style='mso-bidi-font-weight:normal'><a name="m114">s
</b>получается последовательность удвоенной длины. Поэтому основная идея
состоит в том, что две последовательности сливаются, но не просто, а группами
или слоями толщиной <b style='mso-bidi-font-weight:normal'><a name="m115">s </b>элементов.<span
style='mso-spacerun:yes'>  </span>В результате получается последовательность с
группами по <b style='mso-bidi-font-weight:normal'><a name="m116">2s </b>элементов.</p>

<p class=a align=center style='text-align:center'>
<p align="center">
<img border="0" src="Images/046-06.jpg" width="500" height="210"><br
style='mso-ignore:vglayout' clear=ALL>
<b style='mso-bidi-font-weight:normal'><a name="m117">рис.46.4. Циклическое слияние группами
по s элеметов</b></p>
</p>

<p class=a>Первоначально <b style='mso-bidi-font-weight:normal'><a name="m118">s=1</b>, что
соответствует исходной последовательности. Она, само собой, не упорядочена, то
в то же время каждый ее отдельный элемент «упорядочен сам в себе». Главный цикл
включает в себя разделение последовательности на две части и их обратное
слияние в одну. На первом слиянии в последовательности имеются упорядоченные
группы длиной <b style='mso-bidi-font-weight:normal'><a name="m119"><span lang=EN-US
style='mso-ansi-language:EN-US'>s</span>=1</b>, на втором – <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>=2</b>, и далее <b style='mso-bidi-font-weight:normal'><a name="m120"><span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>=4,8,16…2<sup>m</sup>. </b>Процесс
слияния происходит точно так же, как <span style='mso-spacerun:yes'> </span>это
было описано выше, но он не может выйти за пределы очередной группы, пока обе
сливаемые группы не закончились. Это значит, что переход к следующей паре
осуществляется «скачком».</p>

<p class=a0><o:p>&nbsp;</o:p></p>
<p class=a0>//--------------------------------------------------------------------------------46-1<span
lang=EN-US style='mso-ansi-language:EN-US'>6</span>.cpp</p>

<p class=a0>//------ Циклическое двухпутевое слияние</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>sort</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>A</span>[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>){</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i,i1,i2,s,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=1; 1; s*=2){<span
style='mso-tab-count:5'>                                                           </span>//
</span>Размер<span style='mso-ansi-language:EN-US'> </span>группы<span
style='mso-ansi-language:EN-US'> </span>кратен<span style='mso-ansi-language:
EN-US'> </span>степени<span lang=EN-US style='mso-ansi-language:EN-US'> 2<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>nn</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>/<span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>; <span style='mso-tab-count:5'>                                                        </span>//
Количество групп по <span lang=EN-US style='mso-ansi-language:EN-US'>s</span>
элементов </p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>%<span lang=EN-US style='mso-ansi-language:EN-US'>s</span>!=0) <span
lang=EN-US style='mso-ansi-language:EN-US'>nn</span>++;<span style='mso-tab-count:
4'>                                               </span>// Остаток – есть
неполная группа</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int n1=nn/2*s;<span
style='mso-tab-count:5'>                                                    </span>//
Деление ближе к середине,</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>2=<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>-<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>1;<span style='mso-tab-count:5'>                                                       </span>//
но кратно размеру группы</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>1&lt;=0 || <span lang=EN-US style='mso-ansi-language:EN-US'>n</span>2&lt;=0)
<span lang=EN-US style='mso-ansi-language:EN-US'>return</span>;<span
style='mso-tab-count:3'>                                   </span>// Часть
больше целого - выход</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int *B1=new int[n1],*B2=new int[n2];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>    </span><span style='mso-tab-count:1'>        </span>for
(i=0; i&lt;n1; i++) B1[i]=A[i];<span style='mso-tab-count:3'>                              </span>//
Разделение на части<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for (i=0; i&lt;n2; i++)
B2[i]=A[i+n1]; <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>    </span><span style='mso-tab-count:1'>        </span>i1=i2=0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>=0,<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>=0; <span lang=EN-US style='mso-ansi-language:EN-US'>i</span>&lt;<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++){<span style='mso-tab-count:4'>                                        </span>//
Слияние с переходом «скачком»</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (i1==s &amp;&amp; i2==s)<span
style='mso-tab-count:3'>                                 </span>// </span>при<span
style='mso-ansi-language:EN-US'> </span>достижении<span style='mso-ansi-language:
EN-US'> </span>границ<span style='mso-ansi-language:EN-US'> </span>обеих<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>k+=s,i1=0,i2=0;<span
style='mso-spacerun:yes'>             </span><span style='mso-tab-count:2'>                        </span>//
</span>групп<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>if (i1==s || k+i1==n1)
A[i]=B2[k+i2++];<span style='mso-tab-count:1'>     </span>// </span>Достигла<span
style='mso-ansi-language:EN-US'> </span>границы<span style='mso-ansi-language:
EN-US'> </span>группы<span style='mso-ansi-language:EN-US'> </span>или<span
style='mso-ansi-language:EN-US'> <span lang=EN-US><o:p></o:p></span></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>else</span><span
style='mso-tab-count:5'>                                                      </span>//
массива</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (i2==s || k+i2==n2)
A[i]=B1[k+i1++];<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>else<span
style='mso-spacerun:yes'>                            </span><span
style='mso-tab-count:3'>                          </span>// Если нет –
минимальный из пары</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (B1[k+i1 ] &lt; B2[k+i2 ])
A[i]=B1[k+i1++];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>else A[i]=B2[k+i2++];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>        </span><span style='mso-tab-count:2'>                </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>delete </span>[]<span lang=EN-US
style='mso-ansi-language:EN-US'>B1; delete []B2; <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>}}</p>

<p class=a>А теперь рассмотрим технологические приемы. Здесь важно правильно
выбрать «систему координат», используемую при слиянии групп. В выходной
последовательности используется индекс <b style='mso-bidi-font-weight:normal'><a name="m121">i,
</b>который «равномерно» движется по массиву. Слияние всех групп происходит в
одном цикле, за один шаг которого происходит перенос одного элемента. Движение
же по группам «неравномерное», более того, переход к следующему слою
осуществляется скачком, когда обе группы в текущем слое уже слиты. Движение по
группам разложено на две составляющие: <b style='mso-bidi-font-weight:normal'><a name="m122"><span
lang=EN-US style='mso-ansi-language:EN-US'>k</span> – </b>общий индекс начала
слоя, а <b style='mso-bidi-font-weight:normal'><a name="m123"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>1,</b><b style='mso-bidi-font-weight:
normal'><a name="m124"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>2 </b>– относительные
индексы внутри групп. Здесь же отрабатывается «скачок» к<span
style='mso-spacerun:yes'>  </span>следующему слою: при условии, что обе группы
закончились (<b style='mso-bidi-font-weight:normal'><a name="m125"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>1==</b><b style='mso-bidi-font-weight:
normal'><a name="m126"><span lang=EN-US style='mso-ansi-language:EN-US'>s</span> &amp;&amp; </b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>2==<span lang=EN-US
style='mso-ansi-language:EN-US'>s</span></b>) обнуляются относительные индексы
в группах, а <b style='mso-bidi-font-weight:normal'><a name="m127">k</b> переносится на начало
следующего. В процессе слияния отрабатываются четыре возможные ситуации: завершение
первой или второй группы и выбор минимального из пары очередных элементов групп
– в противном случае.<span style='font-size:10.0pt;font-family:"Courier New"'><o:p></o:p></span></p>

<p class=a>Главный цикл организован формально: переменная <b style='mso-bidi-font-weight:
normal'><a name="m128"><span lang=EN-US style='mso-ansi-language:EN-US'>s</span><span
lang=EN-US> </span></b>принимает значения <span
style='mso-spacerun:yes'> </span>степени 2. В теле цикла сначала производится
разделение массива на две части, а затем - их слияние. Дополнительную головную
боль создает произвольная размерность входного массива. Во-первых, разделение
нужно проводить на две части, кратные размеру группы (т.е.по ее границе), а во
вторых, одна из групп может оказаться неполной. Это решается косметическими
поправками: определяется количество групп с учетом неполной, затем делится
пополам и умножается на размер группы – получаем размер первой части(<b
style='mso-bidi-font-weight:normal'>n1</b>). В процессе слияния появляются
дополнительные условия к проверкам границ групп – проверка границ сливаемых
частей.</p>

<p class=a>Оценка трудоемкости производится достаточно просто. Если принять
размерность массива равной <b style='mso-bidi-font-weight:normal'><a name="m129">N=2<sup>k</sup></b>,
то главный цикл будет выполняться <b style='mso-bidi-font-weight:normal'><a name="m130">k=log<sub>2</sub>(N)</b>
раз. За этот шаг <b style='mso-bidi-font-weight:normal'><a name="m131">N</b> элементов
переносятся при разделении и <b style='mso-bidi-font-weight:normal'><a name="m132">N</b>
элементов – обратно при слиянии, прочем количество перемещений не зависит от
значений (нечувствительность к данным). <b style='mso-bidi-font-weight:normal'><a name="m133"><span
lang=EN-US style='mso-ansi-language:EN-US'>T<sub>move</sub></span>=2<span lang=EN-US style='mso-ansi-language:
EN-US'>N</span> log<sub>2</sub>(N). </b>Сравнений будет меньше, чем <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>log<sub>2</sub>(N), </b>т.к. они происходят, когда обе текущие
группы не пусты. В целом же имеем <b style='mso-bidi-font-weight:normal'><a name="m134">O<sup><span lang=EN-US style='mso-ansi-language:
EN-US'>max</span></sup>(<span
lang=EN-US style='mso-ansi-language:EN-US'>N</span>log<sub>2</sub>(N)</b>) по
всем основным операциям.</p>

<a name="lr6"><h3>Лабораторный практикум</h3>

<a name="m139">
<p class="a">Алгоритм сортировки реализовать в виде функции, возвращающей в 
качестве результата характеристику трудоемкости алгоритма (например, количество 
сравнений). Для получить трудоемкость для различных значений N=1000,5000,10000. 
Сравнить с теоретической оценкой.</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">1.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Модификация сортировки&nbsp;&nbsp; циклическим&nbsp;&nbsp; слиянием. Для разграничения 
сливаемых групп в последовательности в качестве разделителя добавить «очень 
большое значение» (<span lang="EN-US">MAXINT</span>). Переход к следующей паре 
групп производить при обнаружении одновременно двух <span lang="EN-US">MAXINT</span>.</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">2.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Модификация простого однократного слияния. Разделить&nbsp;&nbsp; массив&nbsp;&nbsp; на&nbsp; <b>n</b>&nbsp;&nbsp; 
частей и отсортировать их произвольным методом.&nbsp; Отсортированный&nbsp; массив&nbsp; 
получить путем однократного слияния упорядоченных частей. Для извлечения 
очередных элементов из упорядоченных массивов использовать массив из <b>
<span lang="EN-US">n</span></b><span lang="EN-US"> </span>индексов (по одному на 
каждый массив).</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">3.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Модификация сортировки Шелла. Пузырьковая сортировка с шагом
<span lang="EN-US">M</span>, т.е. просмотр пар 0--<span lang="EN-US">M</span>,1--<span lang="EN-US">M</span>+1, 
2—<span lang="EN-US">M</span>+2 и т.д. до тех пор, пока есть перестановки при 
однократном просмотре, затем уменьшение шага в 2 раза.</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">4.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Модификация обменной сортировки. <span lang="EN-US">M </span>раз 
повторяется процесс цикл предварительного обмена. Просматривается массив и 
текущий элемент <b><span lang="EN-US">i</span></b><span lang="EN-US"> &nbsp;</span>обменивается 
с элементом с индексом <b><span lang="EN-US">j</span>,</b> который определяет 
конечное местоположение <span lang="EN-US">A</span>[<span lang="EN-US">i</span>], 
исходя из предположения о линейном возрастании значений в выходном массиве</p>
<p class="a1" style="margin-left:36.0pt;text-indent:36.0pt"><b>
<span lang="EN-US">j&nbsp; = (A[i]-Amin) *n/ (Amax-Amin).</span></b></p>
<p class="a1" style="margin-left:36.0pt;text-indent:-.55pt">Обмен происходит, 
как в обычной сортировке, если пара не находится в порядке возрвастания (с 
учетом взаимного расположения <span lang="EN-US">i</span>,<span lang="EN-US">j</span>). 
Окончательно массив досортировывается обычным пузырьком.</p>
<p class="a1" style="margin-left:36.0pt">&nbsp;</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">5.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Сортировка <span lang="EN-US">c </span>предварительным выбором. Из 
массива путем однократного просмотра выбирается <b>последовательность подряд 
расположенных элементов,</b> находящихся в порядке возрастания, переносятся в 
выходной массив и заменяются во входном на <b>-1</b>. Затем оставшиеся элементы 
включаются в полученную упорядоченную последовательность методом погружения. 
Проверить эффективность на массивах, содержащих значения, возрастающие «с 
большой вероятностью».</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">6.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Сортировка <span lang="EN-US">c </span>предварительным выбором. Из 
массива путем однократного просмотра выбирается последовательность элементов, 
находящихся в порядке возрастания и переносится очередную строку двумерного 
массива с заменой во входном&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на <b>-1</b>.&nbsp; Этот процессс повторяется, 
пока в массиве не останется возрастающих последовательностей. После этого в 
масссиве остается последовательность в порядке убывания, которая также заносится 
в строку массива «задом наперед». Затем для строк производится однократное 
слияние. Если строрки в двумерном массиве окончатся раньше, после слияния 
оставшиеся элементы добавляются в выходной массив при помощи погружения.</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">7.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Сортировка с предварительным размещением. Выходной массив заполняется 
значениями -1. Делается попытка разместить каждый элемент входного массива в 
выходном. Индекс размещения <b><span lang="EN-US">j </span></b>формируется 
исходя из предположения о линейном возрастании значений в выходном массиве</p>
<p class="a1" style="margin-left:36.0pt;text-indent:36.0pt"><b>
<span lang="EN-US">j&nbsp; = (A[i]-Amin) *n/ (Amax-Amin).</span></b></p>
<p class="a1" style="margin-left:35.45pt">Если элемент в выходном массиве уже 
занят, то текущий остается во входном, иначе он переносится в выходной, а во 
входном заменяется на -1. После чего выходной массив уплотняется (удаляются -1), 
а оставшиеся элементы входного добавляются в выходной при помощи вставки 
погружением.</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">8.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Сортировка «демоном Максвелла» (<span lang="EN-US">http</span>://<span lang="EN-US">habrahabr</span>.<span lang="EN-US">ru</span>/<span lang="EN-US">post</span>/161835/): 
Ёмкость с газом разделена на две половины непроницаемой стенкой. В стенке есть 
отверстие, которое снабжено специальным устройством, которое назовём демоном 
Максвелла. Демон устроен так, что через отверстие он из левой части в правую 
пропускает только быстрые (горячие) молекулы газа, а из правой в левую — 
медленные (холодные) молекулы. Идея решения: интервал массива делится пополам, 
справа выбирается максимум, слева – минимум. Затем в промежуточный массив 
переносятся из левой части: меньшие <b>правого минимума – </b>с левого конца, 
иначе с правого, из правой части: большие <b>левого максимума - </b>с левого 
конца, иначе с правого. Получается новая граница (это и есть демон Максвелла для 
чисел). Данные возвращаются в исходный массив. Процесс повторяется, пока левый 
максимум не станет меньше правого минимума. Вызывается рекурсия для полученных 
частей. (аналог рекурсивного разделения).</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 36.0pt">9.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Сортировка с предварительными обменами. <span lang="EN-US">M </span>раз 
повторяется процесс предварительного обмена. Выбирается случайная позиция
<span lang="EN-US">i</span>=<span lang="EN-US">i</span>0 и из нее выбирается 
элемент <span lang="EN-US">C</span>=<span lang="EN-US">A</span>[<span lang="EN-US">i</span>]. 
Затем вычисляется его новое положение, исходя из из предположения о линейном 
возрастании значений в выходном массиве</p>
<p class="a1" style="margin-left:36.0pt;text-indent:36.0pt"><b>
<span lang="EN-US">j&nbsp; = (C-Amin) *n/ (Amax-Amin).</span></b></p>
<p class="a1" style="margin-left:36.0pt;text-indent:-.55pt">Если
<span lang="EN-US">j </span>и <span lang="EN-US">i</span> не равны, выбранный 
элемент С вытесняет <span lang="EN-US">A</span>[<span lang="EN-US">j</span>] 
(обмен С и <span lang="EN-US">A</span>[<span lang="EN-US">j</span>]) и процесс 
повторяется для <span lang="EN-US">i</span>=<span lang="EN-US">j</span>. Иначе 
процесс вытеснения закачивается записью последного вытесненного значения 
поиндексу <span lang="EN-US">i</span>0. Затем массив досортировывается обычным 
пузырьком.</p>
</a>
<p align="center">
<img border="0" src="Images/046-07.jpg" width="463" height="163"><a name="m139"><br clear="ALL">
&nbsp;</p>
<p class="a1" style="text-indent: -18.0pt; margin-left: 54.0pt">10.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;
</span>Оптимизированный двоичный поиск. В процессе деления выбирается не 
середина интервала, а значение, вычисленное из предположения о линейном 
возрастании значений элементов массива в текущем интервале поиска. Точка деления 
интервала <b>&nbsp;<span lang="EN-US">m </span></b>выбирается, исходя из пропорции, 
т.е. исходя из предпложения о линейном возрастании значений на интервале: </p>
<p class="a1" style="margin-left:108.0pt"><b>&nbsp;<span lang="EN-US">(m-a) / (b-a) = 
(val-F(a)) / (F(b)-F(a)).</span></b></p>
<p class="a1" style="margin-left:36.0pt">Сравнить эффективность на равномерно 
возрастяющих данных и данных вида <span lang="EN-US">a</span>1,<span lang="EN-US">a</span>2,а3…,<span lang="EN-US">b</span>, 
где <span lang="EN-US">b</span>&gt;&gt;<span lang="EN-US">a</span>(<span lang="EN-US">i</span>), 
т.е. последнее значение много больше предыдущих.</p>
<h3>Вопросы без ответов</h3>
<p class="a">Определить класс сортировки, описать сущность алгоритма, выполнить 
полный анализ программы (смысл переменных, результат исполнения назначение 
фрагментов, наличие стандартных программных контекстов). Примечание. Все 
программы взяты из разделов 4.6 или 7.2 или описаны в них, или несколько иначе 
реализованы.</p>
<p class="a">&nbsp;</p>
<p class="a0"><span lang="EN-US">//-------------------------------------------1</span></p>
<p class="a0"><span lang="EN-US">void sort(int A[], int n){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *B=new int[n];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i1,i2,j,s,k;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (s=1;s&lt;n;s*=2){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(k=0; k&lt;n; 
k+=2*s){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i1=k,i2=k+s,j=k; 
j&lt;n &amp;&amp; j&lt;k+2*s;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
if (i2&gt;=n || i2==k+2*s || i1!=k+s &amp;&amp; A[i1]&lt;A[i2])</span></p>
<p class="a0"><span lang="EN-US">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[j]=A[i1++];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
else</span></p>
<p class="a0"><span lang="EN-US">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[j]=A[i2++];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=0;j&lt;n;j++) 
A[j]=B[j];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete B;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------2</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int in[], int n){ </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( int i=1; i &lt; n; i++) 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;int 
v=in[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;for (int k=0; k&lt;i; 
k++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(in[k]&gt;v) 
break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;for(int j=i-1; j&gt;=k; 
j--)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
in[j+1]=in[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">
&nbsp;in[k]=v;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------3</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int in[],int n) {</span></p>
<p class="a0"><span lang="EN-US">&nbsp;for ( int i=1; i&lt;n; i++)&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; for ( int k=i; k !=0 &amp;&amp; in[k] &lt; 
in[k-1]; k--){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c=in[k]; in[k]=in[k-1]; in[k-1]=c;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }} </span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------4</span></p>
<p class="a0"><span lang="EN-US">void sort(int A[], int n ){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int m=1; m&lt;n; m*=2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (m/=2; m!=0; m/=2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int k=0; k&lt;m; k++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=k+m; i&lt;n; i+=m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j=i; j&gt;=m &amp;&amp; A[j]&lt;A[j-m]; 
j-=m){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cc = A[j]; A[j]=A[j-m]; 
A[j-m]=cc;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">//-------------------------------------------5</span></p>
<p class="a0"><span lang="EN-US">void sort(int A[], int n){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i,j,h;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (h=1; h&lt;n/9; 
h=h*3+1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for 
(;h&gt;0;h=h/3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=h;i&lt;n;i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=i;j&gt;=h &amp;&amp; A[j]&lt;A[j-h];j-=h)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { int c=A[j]; 
A[j]=A[j-h]; A[j-h]=c; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------6</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int A[], int n){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;int 
i,found;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found =0;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n-1; i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[i] &gt; A[i+1]) {&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cc = A[i]; A[i]=A[i+1]; 
A[i+1]=cc;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while(found !=0); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------7</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int A[], int n){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;int 
i,b,b1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (b=n-1; b!=0; b=b1) {&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;b1=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;b; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[i] &gt; A[i+1]) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cc = A[i]; A[i]=A[i+1]; 
A[i+1]=cc;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1=i; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }}}</span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------------------8</span></p>
<p class="a0"><span lang="EN-US">void sort(int A[],int n){</span></p>
<p class="a0"><span lang="EN-US">int 
z=1,a=0,b=n-1,i,last=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">for (i=0;a&lt;b;){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 
(A[i]&gt;A[i+1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 
c=A[i];A[i]=A[i+1];A[i+1]=c;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last=i;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
i+=z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i==b || i&lt;a) 
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (z&gt;0) 
i=b=last;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else 
i=a=last+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
z=-z;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }}}</span></p>
<p class="a0"><span lang="EN-US">
//-------------------------------------------------9</span></p>
<p class="a0"><span lang="EN-US">void sort(int in[],int n){ </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i,j,cnt;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *out=new 
int[n];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n; i++){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( cnt=0,j=0; j&lt;n; 
j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (in[j] &lt; in[i]) 
cnt++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (in[j]==in[i] &amp;&amp; j&lt;i) 
cnt++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
out[cnt]=in[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n; i++) 
in[i]=out[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete []out;</span></p>
<p class="a0"><span lang="EN-US">}</span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------10</span></p>
<p class="a0"><span lang="EN-US">void sort(int a[], int n);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
</span>любая сортировка одномерного массива</p>
<p class="a0"><span lang="EN-US">&nbsp;</span></p>
<p class="a0"><span lang="EN-US">void big_sort(int A[], int N){</span></p>
<p class="a0"><span lang="EN-US">int max=A[0],i,j,n=sqrt(N)+1;</span></p>
<p class="a0"><span lang="EN-US">int **B=new int*[n];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n; i++) B[i]=new 
int[n];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;N; i++) {</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[i/n][i%n]=A[i];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[i]&gt;max) 
max=A[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=n*n-N; 
j&lt;n;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[n-1][j]=max+1;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n; i++) sort(B[i],n);</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;N; i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( int k=0, j=0; j&lt;n; 
j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (B[j][0] &lt; B[k][0]) 
k=j;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A[i] = B[k][0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=1; j&lt;n; j++) </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
B[k][j-1]=B[k][j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[k][n-1]=max+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">for (i=0; i&lt;n; i++) delete []B[i];</span></p>
<p class="a0"><span lang="EN-US">delete []B;</span></p>
<p class="a0"><span lang="EN-US">}</span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------11</span></p>
<p class="a0"><span lang="EN-US">void sort(int A[], int n){</span></p>
<p class="a0"><span lang="EN-US">int i,i1,i2,s,k;</span></p>
<p class="a0"><span lang="EN-US">for (s=1; 1; 
s*=2){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nn=n/s;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n%s!=0) nn++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int n1=nn/2*s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int n2=n-n1;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n1&lt;=0 || n2&lt;=0) return;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *B1=new int[n1],*B2=new 
int[n2];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n1; i++) B1[i]=A[i];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;n2; i++) B2[i]=A[i+n1];
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; i1=i2=0;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0,k=0; i&lt;n; 
i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i1==s &amp;&amp; 
i2==s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
k+=s,i1=0,i2=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i1==s || k+i1==n1) 
A[i]=B2[k+i2++];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i2==s || k+i2==n2) 
A[i]=B1[k+i1++];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (B1[k+i1 ] &lt; B2[k+i2 
]) A[i]=B1[k+i1++];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else A[i]=B2[k+i2++];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete []B1; delete []B2; </span>
</p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }}</span></p>
<p class="a0"><span lang="EN-US">//-------------------------------------------12</span></p>
<p class="a0"><span lang="EN-US">void sort(int in[], int out[], int n){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i,j,k,max;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (max=in[0],i=0;i&lt;n;i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (in[i]&gt;max) 
max=in[i];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *cnt=new int[max+1];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;=max;i++) cnt[i]=0;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;n;i++) 
cnt[in[i]]++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(j=0,i=0;i&lt;=max;i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
while(cnt[i]--!=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
out[j++]=i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------13</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int in[], int n){ </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( int i=0; i &lt; n-1; 
i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; for ( int j=i+1, k=i; j&lt;n; 
j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; if (in[j] &lt; in[k]) k=j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; int c=in[k]; in[k] = in[i]; in[i] 
= c;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p class="a0"><span lang="EN-US">
//------------------------------------------------------14</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int in[], int a, int b){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;int i,j,mode;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;if (a&gt;=b) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;for (i=a, j=b, mode=1; i &lt; j; mode &gt;0 ? j-- : 
i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; if (in[i] &gt; 
in[j]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;int c = in[i]; in[i] = in[j]; 
in[j]=c;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; mode = -mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;sort(in,a,i-1); sort(in,i+1,b);}</span></p>
<p class="a0"><span lang="EN-US">&nbsp;</span></p>
<p class="a0"><span lang="EN-US">
//-----------------------------------------------------15</span></p>
<p class="a0"><span lang="EN-US">&nbsp;void sort(int in[], int a, int b){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;int i,j,mode;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;double sr=0;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;if (a&gt;=b) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;for (i=a; i&lt;=b; i++) sr+=in[i];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;sr=sr/(b-a+1);</span></p>
<p class="a0"><span lang="EN-US">&nbsp;for (i=a, j=b; i &lt;= j;)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (in[i]&lt; sr) { i++; continue; 
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (in[j]&gt;=sr) { j--; continue; 
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c = in[i]; in[i] = in[j]; in[j]=c;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
i++,j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">&nbsp;if (i==a) 
return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">&nbsp;sort(in,a,j); 
sort(in,i,b);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p class="a0"><span lang="EN-US">
//--------------------------------------------------------16</span></p>
<p class="a0"><span lang="EN-US">for(j=0;n!=0;j++){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (k=0,i=1; i&lt;n; i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[i]&lt;A[k]) k=i;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[j]=A[k];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (;k&lt;n-1;k++) A[k]=A[k+1];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n--;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">
//--------------------------------------------------------17</span></p>
<p class="a0"><span lang="EN-US">for(j=0,max=A[0];j&lt;n;j++) </span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[j]&gt;max) max=A[j];</span></p>
<p class="a0"><span lang="EN-US">for(j=0;j&lt;n;j++){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (k=0,i=1; i&lt;n; i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[i]&lt;A[k]) k=i;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B[j]=A[k];</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A[k]=max+1;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="a0"><span lang="EN-US">
//--------------------------------------------------------18</span></p>
<p class="a0"><span lang="EN-US">while(n!=0){</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (k=0,i=1; i&lt;n; i++)</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (A[i]&lt;A[k]) k=i;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c=A[k]; A[k]=A[n-1]; A[n-1]=c;</span></p>
<p class="a0"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>n--;</p>
<p class="a0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>

<p class=a1 style='margin-left:17.45pt;tab-stops:list 42.55pt'>&nbsp;</p>

</div>

</body>

</html>
