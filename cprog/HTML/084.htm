<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="084.files/editdata.mso">
<title>Романов Е.Л. Беседы о программировании</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Comp</o:Author>
  <o:Template>Книга.dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>369</o:TotalTime>
  <o:Created>2008-02-13T20:21:00Z</o:Created>
  <o:LastSaved>2008-02-13T20:21:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1580</o:Words>
  <o:Characters>9010</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>75</o:Lines>
  <o:Paragraphs>21</o:Paragraphs>
  <o:CharactersWithSpaces>10569</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial Narrow";
	panose-1:2 11 5 6 2 2 2 3 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("084.files/header.htm") fs;
	mso-footnote-continuation-separator:url("084.files/header.htm") fcs;
	mso-endnote-separator:url("084.files/header.htm") es;
	mso-endnote-continuation-separator:url("084.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-header:url("084.files/header.htm") h1;
	mso-even-footer:url("084.files/header.htm") ef1;
	mso-footer:url("084.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:77945188;
	mso-list-type:hybrid;
	mso-list-template-ids:-827664056 -2071412966 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l0:level1
	{mso-level-start-at:8;
	mso-level-text:%1;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l0:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1
	{mso-list-id:111748343;
	mso-list-type:hybrid;
	mso-list-template-ids:1698987124 -2113098950 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l1:level1
	{mso-level-start-at:12;
	mso-level-text:%1;
	mso-level-tab-stop:159.6pt;
	mso-level-number-position:left;
	margin-left:159.6pt;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:371812094;
	mso-list-type:hybrid;
	mso-list-template-ids:-298818442 -798984900 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l2:level1
	{mso-level-start-at:9;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:53.45pt;
	mso-level-number-position:left;
	margin-left:53.45pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@list l3
	{mso-list-id:517357751;
	mso-list-type:hybrid;
	mso-list-template-ids:-780488968 344367286 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l3:level1
	{mso-level-start-at:42;
	mso-level-text:%1;
	mso-level-tab-stop:159.6pt;
	mso-level-number-position:left;
	margin-left:159.6pt;
	text-indent:-18.0pt;}
@list l4
	{mso-list-id:609823021;
	mso-list-type:hybrid;
	mso-list-template-ids:-1684117832 1246773214 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l4:level1
	{mso-level-start-at:3;
	mso-level-text:%1;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-style:normal;}
@list l4:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l5
	{mso-list-id:682636648;
	mso-list-type:hybrid;
	mso-list-template-ids:-852318486 1647877064 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l5:level1
	{mso-level-start-at:12;
	mso-level-text:%1;
	mso-level-tab-stop:318.6pt;
	mso-level-number-position:left;
	margin-left:318.6pt;
	text-indent:-177.0pt;}
@list l6
	{mso-list-id:1027485245;
	mso-list-type:hybrid;
	mso-list-template-ids:270539844 -798984900 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l6:level1
	{mso-level-start-at:9;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:88.9pt;
	mso-level-number-position:left;
	margin-left:88.9pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@list l7
	{mso-list-id:1133984564;
	mso-list-type:hybrid;
	mso-list-template-ids:-1586203394 -665312716 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l7:level1
	{mso-level-start-at:12;
	mso-level-text:%1;
	mso-level-tab-stop:250.2pt;
	mso-level-number-position:left;
	margin-left:250.2pt;
	text-indent:-141.0pt;}
@list l8
	{mso-list-id:1574268910;
	mso-list-type:hybrid;
	mso-list-template-ids:-754653212 -1936657838 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l8:level1
	{mso-level-start-at:0;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:53.45pt;
	mso-level-number-position:left;
	margin-left:53.45pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";}
@list l9
	{mso-list-id:1669164620;
	mso-list-type:hybrid;
	mso-list-template-ids:-300668598 114878812 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l9:level1
	{mso-level-start-at:12;
	mso-level-text:%1;
	mso-level-tab-stop:353.7pt;
	mso-level-number-position:left;
	margin-left:353.7pt;
	text-indent:-247.5pt;}
@list l10
	{mso-list-id:1731735085;
	mso-list-type:hybrid;
	mso-list-template-ids:577033638 -1808759424 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l10:level1
	{mso-level-text:%1;
	mso-level-tab-stop:53.25pt;
	mso-level-number-position:left;
	margin-left:53.25pt;
	text-indent:-35.25pt;
	font-family:"Times New Roman";}
@list l10:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l11
	{mso-list-id:1793815671;
	mso-list-type:hybrid;
	mso-list-template-ids:1915898340 926160618 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l11:level1
	{mso-level-start-at:2;
	mso-level-text:%1;
	mso-level-tab-stop:53.25pt;
	mso-level-number-position:left;
	margin-left:53.25pt;
	text-indent:-35.25pt;}
@list l12
	{mso-list-id:1946381470;
	mso-list-type:hybrid;
	mso-list-template-ids:-505747168 -1937573454 68747289 68747291 68747279 68747289 68747291 68747279 68747289 68747291;}
@list l12:level1
	{mso-level-start-at:12;
	mso-level-text:%1;
	mso-level-tab-stop:159.6pt;
	mso-level-number-position:left;
	margin-left:159.6pt;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
  <o:regrouptable v:ext="edit">
   <o:entry new="1" old="0"/>
   <o:entry new="2" old="0"/>
   <o:entry new="3" old="0"/>
   <o:entry new="4" old="0"/>
   <o:entry new="5" old="0"/>
   <o:entry new="6" old="0"/>
   <o:entry new="7" old="0"/>
   <o:entry new="8" old="0"/>
   <o:entry new="9" old="0"/>
   <o:entry new="10" old="0"/>
   <o:entry new="11" old="0"/>
   <o:entry new="12" old="0"/>
   <o:entry new="13" old="0"/>
   <o:entry new="14" old="0"/>
   <o:entry new="15" old="0"/>
   <o:entry new="16" old="0"/>
   <o:entry new="17" old="0"/>
   <o:entry new="18" old="0"/>
   <o:entry new="19" old="11"/>
   <o:entry new="20" old="11"/>
   <o:entry new="21" old="0"/>
   <o:entry new="22" old="0"/>
   <o:entry new="23" old="0"/>
  </o:regrouptable>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2><font face="Arial"><span lang=EN-US style='mso-ansi-language:EN-US;layout-grid-mode:line'>8</span><span
style='layout-grid-mode:line'>.4. Деревья, упорядоченные в глубину</span></font></h2>
<h3><font face="Arial">Упорядочение
в глубину</font></h3>

<h3><font face="Arial"><b><a name="m1">
<img border="0" src="Images/084-01.gif" width="244" height="232" align="left"></b></font></h3>
<p class=a4>Упорядочение значений в дереве может быть произведено в глубину
(условно говоря, по вертикали): значение в каждой вершине меньше, чем значения
у прямых потомков. Рекурсивное применение такого утверждения приводит к тому,
что в каждой вершине находится минимальное значение из всего подчиненного ей
поддерева. Такое размещение данных позволяет предполагать, что их можно
получить в порядке возрастания. Однако ни рекурсивный обход, ни «горизонтальный»
(с использованием очереди) для этих целей не подходят.<span
style='mso-spacerun:yes'>  </span>Такую возможность дает алгоритм рекурсивного
слияния значений из вершин дерева с замещением «ушедших» значениями потомков.
Аналогично, построение дерева производится путем вытеснения больших значений
меньшими при их прохождении через промежуточные вершины. Во всех случаях выбор
направления дальнейшего<span style='mso-spacerun:yes'>  </span>движения
алгоритма производится в сторону потомка с меньшим значением.</p>

<h3><font face="Arial">Построение
дерева, упорядоченного в глубину</font></h3>
<p class=a4>Для начала будем использовать естественное
представление дерева в виде вершин, содержащих указатели на потомков. В самом
простом случае их будет не более двух: правый и левый. Включение в дерево
нового значения, не нарушающего свойства упорядоченности в глубину, базируется
на следующих принципах:</p>

<p class=a1>- алгоритм основывается на ветвлении: выполнение его для корневой
вершины сопровождается<span style='mso-spacerun:yes'>  </span>выбором потомка,
для которого алгоритм повторяется линейно - рекурсивно или циклически;</p>

<p class=a1>- «замещение»: если новое значение меньше, чем значение в текущей
вершине, то оно вытесняет последнее, занимая его место. Вытесненное значение
участвует в последующем погружении вместо нового. Заметим, что такой процесс не
нарушает свойства упорядоченности дерева в глубину;</p>

<p class=a1>- для продолжения алгоритма может быть выбран любой потомок. Если
выбирать потомка с минимальным количеством вершин в поддереве, то в процессе
его построения будет поддерживаться его сбалансированность;</p>

<p class=a1>-
для реализации предыдущего положения каждая вершина должна содержать счетчик
вершин в поддереве, который будет увеличиваться при вставке каждого нового
значения в поддерево.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------84-01.cpp<img border="0" src="Images/084-04.gif" width="239" height="257" align="right"></p>

<p class=a0>//------- Дерево, упорядоченное в глубину.</p>

<p class=a0>// Построение дерева - вытеснение в поддерево </p>

<p class=a0>// с минимальным количеством вершин</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>struct vtree{<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int val;<span style='mso-tab-count:
3'>                           </span>// </span>значение<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>vtree *l,*r;<span style='mso-tab-count:
2'>                      </span>// </span>потомки<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int cnt;<span style='mso-tab-count:
3'>                          </span>// </span>счетчик<span style='mso-ansi-language:
EN-US'> </span>вершин<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>};<o:p></o:p></span></p>

<p class=a0><span style='mso-tab-count:4'>                                                </span>//
Ссылка на указатель</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void insert(vtree
*&amp;p, int v){<span style='mso-tab-count:1'>          </span>// </span>на
текущую вершину</p>

<p class=a0><span
style='mso-spacerun:yes; mso-ansi-language:EN-US'> </span>if (p==NULL){<span style='mso-tab-count:
3'>                            </span>// Найдено свободное место</p>

<p class=a0><span style='mso-tab-count:1'>            </span>p=new vtree;<span
style='mso-tab-count:2'>                  </span>// Создать новую вершину</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>p-&gt;l = p-&gt;r = NULL;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>p-&gt;cnt = 1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>p-&gt;val = v;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>return;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0><span style='mso-spacerun:yes'> </span>p-&gt;cnt++;<span
style='mso-tab-count:5'>                                                         </span>//
Увеличить счетчик вершин в текущей вершине</p>

<p class=a0><span style='mso-spacerun:yes'> </span>if (v &lt; p-&gt;val){<span
style='mso-tab-count:5'>                                                    </span>//
Вытеснение меньшим значением большего</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'> </span>int c=p-&gt;val; p-&gt;val=v; v=c;<span
style='mso-tab-count:2'>                     </span>// из текущей вершины</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (p-&gt;l == NULL || p-&gt;r !=NULL
&amp;&amp; p-&gt;l-&gt;cnt &lt; p-&gt;r-&gt;cnt) <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'> </span></span>insert(p-&gt;l,v);<span
style='mso-tab-count:4'>                                        </span>// Выбор
свободной ветви или</p>

<p class=a0><span style='mso-spacerun:yes'> </span>else<span style='mso-tab-count:
6'>                                                                 </span>//
поддерева с минимумом вершин</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>insert(p-&gt;r,v);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a>Технологические особенности программы: используется ссылка на
указатель на текущую вершину (т.е. ссылка на местоположение указателя на
текущую вершину в вершине - предке). Тогда получение ссылки на <span
lang=EN-US style='mso-ansi-language:EN-US'>NULL</span>-указатель говорит о том,
что достигнут «свободный»<span style='mso-spacerun:yes'>  </span>указатель, на
который можно «повесить» новую вершину. Аналогично, при наличии одного потомка
предпочтение отдается «свободной» ссылке. Для получения информации о топологии
построенного дерева можно использовать обычный рекурсивный обход. Понятно, что
он не создает порядка возрастания.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void scan(vtree
*p, int level){<span style='mso-tab-count:3'>                                </span>//
level – </span>уровень<span style='mso-ansi-language:EN-US'> </span>вершины<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (p == NULL) return;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>printf(&quot;l=%d
v=%d\n&quot;,level,p-&gt;val);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>scan(p-&gt;l,level+1);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>scan(p-&gt;r,level+1);<o:p></o:p></span></p>

<p class=a0>} </p>

<h3><font face="Arial">«Слияние»
данных из дерева, упорядоченного в глубину.</font><b><a name="m2"> </b></h3>
<p class=a4>Получение упорядоченной
последовательности происходит путем обратного перемещения значений от потомков
к предкам. Поскольку вершина каждого поддерева содержит минимальное значение в
нем, то очередное значение берется из корневой вершины. На его место помещается
значение, полученное от потомка. Чтобы свойство упорядоченности дерева в глубину
сохранялось, необходимо выбирать потомка с минимальным значением. Процесс
«заимствования» повторяется для него далее по дереву, пока не будет достигнута
терминальная вершина, которая уничтожается. Похожий процесс объединения двух
упорядоченных линейных последовательностей, как известно, называется, <b><a name="m3">слиянием.
</b>Здесь можно применить тот же термин, хотя речь идет о <b><a name="m4">замещении.<o:p></o:p></b></p>

<p class=a>В приведенном ниже фрагменте технологически удобнее передавать
ссылку на указатель текущей вершины, что необходимо для его обнуления при
уничтожении терминальной вершины (не имеющей потомков). При наличии
единственного потомка он выбирается безальтернативно, иначе берется потомок с
минимальным значением.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------84-02.cpp</p>

<p class=a0>// &quot;Слияние&quot; дерева - замещение значения в текущей
вершине значением минимального потомка<img border="0" src="Images/084-05.gif" width="229" height="276" align="right"></p>

<p class=a0>int shift(vtree *&amp;p){</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (p==NULL) return 0;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>int vv=p-&gt;val;<span
style='mso-tab-count:4'>                                         </span>//
Возвратить значение из текущей</p>

<p class=a0><span style='mso-spacerun:yes'> </span>if (p-&gt;l==NULL &amp;&amp;
p-&gt;r==NULL){<span style='mso-tab-count:1'>            </span>// Нет потомков
-<span style='mso-spacerun:yes'>  </span>удалить вершину</p>

<p class=a0><span style='mso-tab-count:1'>            </span>delete p;<span
style='mso-tab-count:3'>                                    </span>// и возвратить
ее значение</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>p = NULL;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>return vv;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (p-&gt;l==NULL || p-&gt;r!=NULL &amp;&amp;
p-&gt;r-&gt;val &lt; p-&gt;l-&gt;val)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'> </span>p</span>-&gt;<span lang=EN-US
style='mso-ansi-language:EN-US'>val</span> = <span lang=EN-US style='mso-ansi-language:
EN-US'>shift</span>(<span lang=EN-US style='mso-ansi-language:EN-US'>p</span>-&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>r</span>);<span style='mso-tab-count:
2'>                    </span>// Выбрать минимальное значение </p>

<p class=a0><span style='mso-spacerun:yes'> </span>else<span style='mso-tab-count:
5'>                                                     </span>// от потомков и
заместить текущее</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>p</span>-&gt;<span lang=EN-US style='mso-ansi-language:EN-US'>val</span>
= <span lang=EN-US style='mso-ansi-language:EN-US'>shift</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>p</span>-&gt;<span lang=EN-US
style='mso-ansi-language:EN-US'>l</span>);</p>

<p class=a0>return vv;<span style='mso-tab-count:4'>                                               </span>//
вернуть значение вершины</p>

<p class=a0>}</p>
<p class=a0>&nbsp;</p>

<p class=a4><b><a name="m5">Ограничение
обхода дерева, упорядоченного в глубину.</b> Рекурсивный обход упорядоченного в
глубину дерева может быть эффективен, если в нем производится поиск значения,
близкого к минимальному, либо всех значений не больше заданного. В этом случае
погружение в поддерево прекращается, как только в вершине обнаружится значение,
не входящее в диапазон.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------84-03.cpp</p>

<p class=a0>//------- Дерево, упорядоченное в глубину.</p>

<p class=a0>// Поиск значений, не превышающих заданное</p>

<p class=a0>// Рекурсивный обход с ограничением глубины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void search(vtree
*p,<span style='mso-spacerun:yes'>  </span>int high, int &amp;n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>if (p==NULL) return;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span>n++;<span style='mso-tab-count:4'>                                        </span>//
Счетчик пройденных вершин</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (p-&gt;val &lt;= high){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>printf(&quot;v=%d\n&quot;,p-&gt;val);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>search(p-&gt;r,high,n);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>search(p-&gt;l,high,n);<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>}}</p>

<p class=a4><b><a name="m6"><o:p>&nbsp;</o:p></b></p>

<h3><font face="Arial">Пирамидальная
сортировка в массиве</font></h3>
<p class=a4>Идею упорядоченного в глубину дерева можно перенести
в массив, где оно получает название <b><a name="m7">пирамиды – </b>модели дерева с двумя
потомками. В ней используется следующий способ индексации вершин: вершина с
индексом <b><a name="m8"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span><span
lang=EN-US> </span></b>имеет двух потомков с индексами <b><a name="m9">2<span
lang=EN-US style='mso-ansi-language:EN-US'>N</span><span lang=EN-US> </span></b>и
<b><a name="m10">2<span lang=EN-US style='mso-ansi-language:EN-US'>N</span>+1. </b>Корневая
вершина имеет индекс <b><a name="m11">1</b>. При таком представлении единственной проблемой
является сбалансированность дерева. Будучи сбалансированным, оно занимает все
ячейки массива.<span style='mso-spacerun:yes'>  </span>При отображении
несбалансированного дерева размерность необходимого массива равна <b><a name="m12">2<sup><span
lang=EN-US style='mso-ansi-language:EN-US'>L</span></sup><span lang=EN-US> </span></b>,
где <b><a name="m13"><span lang=EN-US style='mso-ansi-language:EN-US'>L</span> – </b>максимальная
длина ветви: все отсутствующие вершины, тем не менее, представлены ячейками
массива. </p>

<p class=a>Процессы
построения и слияния дерева в массиве несколько отличаются: они происходят в
противоположном направлении. Построение дерева состоит в последовательном
добавлении вершин к уже построенному дереву. Значение из новой вершины
погружается в дерево путем обмена с предком в направлении к корню дерева. Это
поразительно напоминает сортировку погружением, только происходит не в линейном
массиве, а в последовательности вершин.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><img border="0" src="Images/084-07.gif" width="585" height="260"></p>

<p class=a0>//--------------------------------------------------------------84-04.cpp</p>
<p class=a0>// Пирамидальная сортировка - построение пирамиды</p>

<p class=a0>// Погружение в дерево путем обмена с предком</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void set_tree(int
A[],int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int l,i;<o:p></o:p></span></p>

<p class=a0>for (l=2;l&lt;=n;l++){<span style='mso-tab-count:4'>                                               </span>//
l - индекс погружаемой вершины</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for (i=l; i!=1;i=i/2){<span style='mso-tab-count:3'>                                   </span>//
</span>индекс<span style='mso-ansi-language:EN-US'> </span>предка<span
lang=EN-US style='mso-ansi-language:EN-US'> = i/2<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:2'>                  </span>if
(A[i]&gt;A[i/2]) break;<span style='mso-tab-count:2'>                   </span>//
</span>предок<span style='mso-ansi-language:EN-US'> </span>меньше<span
style='mso-ansi-language:EN-US'> </span>потомка<span lang=EN-US
style='mso-ansi-language:EN-US'> - </span>выйти<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>int c=A[i]; A[i]=A[i/2];
A[i/2]=c;<span style='mso-tab-count:1'>    </span>// </span>поменяться<span
style='mso-ansi-language:EN-US'> </span>с<span style='mso-ansi-language:EN-US'>
</span>предком<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>   </span><span style='mso-tab-count:2'>                     </span></span>}}}</p>

<p class=a4><img border="0" src="Images/084-09.gif" width="248" height="221"><img border="0" src="Images/084-08.gif" width="246" height="254"><p class=a>Процесс слияния можно воспроизвести «по образу и подобию»
аналогичного процесса в дереве. При этом удаляемые в процессе слияния вершины
можно обозначить в массиве значениями <b><a name="m14"><span lang=EN-US style='mso-ansi-language:
EN-US'>MAXINT</span></b> – максимального целого. Тогда процесс слияния будет
естественным образом обходить несуществующие вершины и замещать терминальные
(удаление). Единственный технологический нюанс – определение концевых вершин
дерева, потомки которых выходят за размерность массива.</p>

<p class=a0><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:
"Times New Roman CYR";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//------------------------------------------------------------------------84-05.cpp</p>

<p class=a0>// Пирамидальная сортировка – слияние пирамиды</p>

<p class=a0>// Сортировка - n раз выбрать из дерева с замещением на
минимального потомка</p>

<p class=a0>// Извлекаемые элементы в конце массива, не имеющие потомков,</p>

<p class=a0>// заменяются на<span style='mso-spacerun:yes'> 
</span>MAXINT.<span style='mso-spacerun:yes'>  </span>Значение MAXINT
обозначает отсутствие вершины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int
A[],int B[], int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int i=1;
i&lt;=n; i++){<span style='mso-tab-count:5'>                                                    </span>//
</span>повторить<span lang=EN-US style='mso-ansi-language:EN-US'> n </span>раз<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int j,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>B</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>]=<span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[1];<span style='mso-tab-count:5'>                                                          </span>//
Корневая вершина – в выходной массив</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for
(j=1;j&lt;=n;j=k){<span style='mso-tab-count:4'>                                               </span>//
j=k - переход к замещающему потомку</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>k=2*j;<span
style='mso-tab-count:3'>                            </span><span
style='mso-tab-count:2'>                        </span>// k - левый потомок</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(k&gt;n)<span style='mso-tab-count:1'>  </span>{ A[j]=MAXINT; break; }<span
style='mso-tab-count:2'>               </span>// нет потомков - MAXINT
(затычка)</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>+1&gt;<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>)<span style='mso-spacerun:yes'> 
</span><span style='mso-tab-count:4'>                                            </span>//
нет второго потомка - взять первого</p>

<p class=a0 style='margin-left:72.0pt;text-indent:36.0pt'><span lang=EN-US
style='mso-ansi-language:EN-US'>{ A[j]=A[k]; A[k]=MAXINT; break; }<o:p></o:p></span></p>

<p class=a0 style='margin-left:216.0pt;text-indent:36.0pt'><o:p>&nbsp;</o:p></p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(A[k+1]&lt;A[k]) k++;<span style='mso-tab-count:3'>                              </span>//
иначе - выбрать минимального из них</p>

<p class=a0><span style='mso-spacerun:yes'>   </span><span style='mso-tab-count:
1'>         </span><span style='mso-tab-count:1'>            </span>A[j]=A[k];<span
style='mso-tab-count:4'>                                              </span>//
скопировать значение потомка в предка</p>

<p class=a0><span style='mso-spacerun:yes'>   </span><span style='mso-tab-count:
1'>         </span>}}}</p>

<span style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:"Times New Roman CYR";
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:"Times New Roman";
mso-ansi-language:RU;mso-fareast-language:RU;mso-bidi-language:AR-SA'><br
clear=all style='mso-special-character:line-break;page-break-before:always'>
<img border="0" src="Images/084-10.gif" width="275" height="222"><img border="0" src="Images/084-11.gif" width="255" height="221"></span><p class=a>Существует и более элегантное решение, позволяющее обойтись одним
массивом. В нем корневая вершина обменивается значением с последней, после чего
последняя вершина из дерева исключается. Значение же корневой вершины
погружается в дерево путем обмена с минимальным из потомков, пока не достигнет
большего себя. В результате массив будет упорядочен по убыванию.</p>

<p class=a><o:p>
<img border="0" src="Images/084-12.gif" width="593" height="250">&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------------------------84-06.cpp</p>

<p class=a0>// Слияние дерева, упорядоченного в глубину.</p>

<p class=a0>// На каждом шаге размерность дерева уменьшается на 1</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void sort(int A[],
int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int m,j,k;<o:p></o:p></span></p>

<p class=a0>for (m=n; m&gt;1; m--){<span style='mso-tab-count:3'>                               </span>//
Текущий размер дерева 1..m-1</p>

<p class=a0><span style='mso-spacerun:yes'>   </span>int c=A[1]; A[1]=A[m];
A[m]=c;<span style='mso-tab-count:2'>                        </span>// Обмен:
вершина дерева (min) - с последним</p>

<p class=a0><span style='mso-spacerun:yes'>   </span>int j,k;<span
style='mso-spacerun:yes'>                         </span><span
style='mso-tab-count:3'>                                   </span>// Последний
далее не учитывается (размерность &lt;m)</p>

<p class=a0><span style='mso-spacerun:yes'>   </span>for (k=1;2*k&lt;m; k=j){<span
style='mso-tab-count:3'>                           </span>// j=k - переход к
замещающему потомку</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>j=2*k;<span
style='mso-tab-count:4'>                                              </span>//
j - левый потомок</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>if (j+1&lt;m &amp;&amp;
A[j+1]&lt;A[j]) j++;<span style='mso-tab-count:2'>                       </span>//
Если правый есть и меньше левого - взять его</p>

<p class=a0><span style='mso-spacerun:yes'>      </span>if (A[k]&lt;A[j])
break;<span style='mso-tab-count:3'>                           </span>// Достиг
большего себя - прекратить обмен</p>

<p class=a0><span style='mso-spacerun:yes'>      </span><span lang=EN-US
style='mso-ansi-language:EN-US'>c=A[k]; A[k]=A[j]; A[j]=c;<span
style='mso-tab-count:2'>                  </span>// </span>Обмен<span
style='mso-ansi-language:EN-US'> </span>с<span style='mso-ansi-language:EN-US'>
</span>потомком<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>}}}</p>

<p class=a4><b><a name="m15"><img border="0" src="Images/science.jpg" width="43" height="33">Оценка
трудоемкости. </b>Верхнюю границу трудоемкости<span style='mso-spacerun:yes'> 
</span>оценить легко. При погружении значений в дерево и их слиянии из него для
каждого из них производится не более <b><a name="m16"><span lang=EN-US style='mso-ansi-language:
EN-US'>log</span><sub>2</sub><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span><span lang=EN-US> </span></b>обменов (длина ветви
сбалансированного дерева) в каждом случае. Для <b><a name="m17"><span lang=EN-US
style='mso-ansi-language:EN-US'>N</span><span lang=EN-US> </span></b>таких
элементов получаем <b><a name="m18"><span lang=EN-US style='mso-ansi-language:EN-US'>T<sub>max</sub></span>=2<span
lang=EN-US style='mso-ansi-language:EN-US'>Nlog</span><sub>2</sub><span
lang=EN-US style='mso-ansi-language:EN-US'>N</span>. </b>Но даже эта оценка
является завышенной, поскольку не учитывает, что для <b><a name="m19"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span></b>-го элемента массива длина ветви
будет <b><a name="m20"><span lang=EN-US style='mso-ansi-language:EN-US'>log</span><sub>2</sub><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span></b>, то есть меньше <b><a name="m21"><span
lang=EN-US style='mso-ansi-language:EN-US'>N</span>.</b></p>

</div>

</body>

</html>
