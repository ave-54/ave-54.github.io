<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="037.files/editdata.mso">
<title>3.7. Инвариант цикла</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>www.PHILka.RU</o:Author>
  <o:Template>Книга(шаблон)</o:Template>
  <o:LastAuthor>romanow</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>603</o:TotalTime>
  <o:Created>2008-07-21T11:18:00Z</o:Created>
  <o:LastSaved>2008-07-21T11:18:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1870</o:Words>
  <o:Characters>10664</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>88</o:Lines>
  <o:Paragraphs>25</o:Paragraphs>
  <o:CharactersWithSpaces>12509</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:AttachedTemplate HRef="C:\ForAll\Book2008\Книга(шаблон).dot"></w:AttachedTemplate>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{mso-style-name:стихи;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.1, li.1, div.1
	{mso-style-name:эпиграф1;
	mso-style-parent:эпиграф;
	margin-top:0cm;
	margin-right:9.35pt;
	margin-bottom:0cm;
	margin-left:9.0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("037.files/header.htm") fs;
	mso-footnote-continuation-separator:url("037.files/header.htm") fcs;
	mso-endnote-separator:url("037.files/header.htm") es;
	mso-endnote-continuation-separator:url("037.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-even-header:url("037.files/header.htm") eh1;
	mso-header:url("037.files/header.htm") h1;
	mso-even-footer:url("037.files/header.htm") ef1;
	mso-footer:url("037.files/header.htm") f1;
	mso-first-header:url("037.files/header.htm") fh1;
	mso-first-footer:url("037.files/header.htm") ff1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:127675688;
	mso-list-type:hybrid;
	mso-list-template-ids:30015702 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:176504481;
	mso-list-type:hybrid;
	mso-list-template-ids:-1429331794 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:74.25pt;
	mso-level-number-position:left;
	margin-left:74.25pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l2
	{mso-list-id:371078698;
	mso-list-type:hybrid;
	mso-list-template-ids:812915916 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	margin-left:72.0pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l3
	{mso-list-id:414670730;
	mso-list-type:simple;
	mso-list-template-ids:68747279;}
@list l3:level1
	{mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;}
@list l4
	{mso-list-id:1266234435;
	mso-list-type:hybrid;
	mso-list-template-ids:1524769000 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Сетка таблицы";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
  <o:regrouptable v:ext="edit">
   <o:entry new="1" old="0"/>
   <o:entry new="2" old="1"/>
   <o:entry new="3" old="0"/>
  </o:regrouptable>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2>3.7. Инвариант цикла</h2>

<p class=a4><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a4>
<img border="0" src="Images/labs.jpg" width="41" height="40" align="left">Начнем,
как обычно, с задачки. В строке, содержащей цепочки одинаковых символов, нужно
их обнаружить и заменить на счетчик повторений и один такой символ. Например,
из строки «<span lang=EN-US style='mso-ansi-language:EN-US'>abcdddddddddefggggggggggggggggggx</span>»
получить<span style='mso-spacerun:yes'>  </span>«<span lang=EN-US
style='mso-ansi-language:EN-US'>abc</span>9<span lang=EN-US style='mso-ansi-language:
EN-US'>def</span>18<span lang=EN-US style='mso-ansi-language:EN-US'>gx</span>».
Извечный вопрос русской интеллигенции: «Что делать?».<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a>Типичный ход рассуждений: «Будем просматривать строку в цикле. Если обнаружим
повторяющийся фрагмент…» содержит одну существенную недосказанность: как процесс
обнаружения повторяющегося фрагмента связан с циклом посимвольного просмотра
неповторяющихся символов. Это отдельный процесс – цикл, или он является частью
предыдущего.</p>

<p class=a>Допустим, что программа состоит из единственного цикла, в котором
действует принцип «1 шаг - 1 символ». И поведение программы на каждом шаге
цикла будет зависеть от того, одинакова ли очередная пара символов или нет.
Тогда придется ввести счетчик повторяющихся символов. Если это пара одинаковых
символов, то надо просто увеличивать счетчик. А если это пара разных, то <span
style='mso-spacerun:yes'> </span>поведение программы зависит от того, находится
ли эта пара в конце повторяющегося фрагмента, или нет. Судить об этом можно
опять же по значению счетчика. После проверки его надо будет сбрасывать в
исходное состояние. С учетом всего этого можно набросать «грязную» программу,
которая отслеживает все эти закономерности, ничего не меняя в строке.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//---------------------------------------------------------37-01.cpp</p>

<p class=a0>// &quot;Склеивание&quot; повторяющихся символов строки.</p>

<p class=a0>// Использование счетчика повторений. &quot;Грязная программа&quot;</p>

<p class=a0>void<span style='mso-spacerun:yes'>  </span>F1(char in[]){</p>

<p class=a0>int i,k;</p>

<p class=a0>for (i=0,k=1; in[i]!=0;i++)</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(in[i]==in[i+1]) k++;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>else<span
style='mso-tab-count:1'>      </span>{</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(k&gt;1) printf(&quot;%d&quot;,k);</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>printf(&quot;%c&quot;,in[i]);</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>k=1;</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>void main(){
F1(&quot;abcdddddddddddddddefffffffffffffffffffffg&quot;); }</p>

<p class=a>Мы здесь одним условием убили двух зайцев. В паре неодинаковых
символов первый сохраняется всегда, а если он еще заканчивает цепочку
повторяющихся, то выводится счетчик.</p>

<p class=a><span style='mso-bidi-font-weight:bold'>Здесь есть еще один «заяц».
Вспомните, что любой цикл нужно проверять на первый и последний шаг. Они могут
«вписаться» в имеющийся текст, а могут и нет. В нашем случае, когда текущий
символ – последний в строке, мы сравниваем его с символом «конец строки», т.е.
заведомо будет несовпадение и программа сработает правильно. В других случаях,
например, когда строка задана объектом или типом данных, состоящим из массива
символов и текущей размерности, придется в явном виде записывать условие –
последний символ строки. В классическом Си это выглядит так:</span><span
lang=EN-US style='mso-ansi-language:EN-US;mso-bidi-font-weight:bold'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='letter-spacing:1.0pt;mso-ansi-language:
EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0>if (i!=strlen(in) &amp;&amp; in[i]==in[i+1]) k++;<span
style='mso-tab-count:1'>       </span>// Символ не последний и за ним такой же</p>

<p class=a0>else<span style='mso-tab-count:1'>      </span>{<span
style='mso-tab-count:4'>                                               </span>//
Либо последний, либо пара разных</p>

<p class=a>Перейдем теперь к решению задачи. Технологически возможны два
варианта обработки строки: переписывание в новую или сжатие текущей. Вариант с
п<span style='mso-bidi-font-weight:bold'>ереписыванием будет проще. Мы сможем
сохранить «грязную» программу, добавив в нее процесс переписывания – массив и
индекс в нем. И не только. Чтобы записать счетчик в виде числа, необходимо
перевести его во внешнюю форму представления, в виде цепочки символов-цифр
(см.4.5).<o:p></o:p></span></p>

<p class=a0><span style='letter-spacing:1.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//---------------------------------------------------------37-02.cpp</p>

<p class=a0>// Использование счетчика повторений. Переписывание строки</p>

<p class=a0>void<span style='mso-spacerun:yes'>  </span>F2(char in[], char
out[]){</p>

<p class=a0>int i,j,k;</p>

<p class=a0>for (i=0,j=0,k=1; in[i]!=0;i++)</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(in[i]==in[i+1]) k++;<span style='mso-tab-count:3'>                              </span>//
Пара различных - счетчик+1</p>

<p class=a0><span style='mso-tab-count:1'>            </span>else{<span
style='mso-tab-count:5'>                                                     </span>//
Пара одинаковых</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(k&gt;1) {<span style='mso-tab-count:3'>                                    </span>//
Есть повторения</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>int
k1,j1;<span style='mso-tab-count:2'>                        </span>// Записать
k в виде символов-цифр</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>for
(k1=k; k1!=0;k1=k1/10,j++);</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>for
(j1=j-1; k!=0;k=k/10,j1--) </p>

<p class=a0><span style='mso-tab-count:4'>                                                </span>out[j1]=k%10+'0';</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>}</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>out[j++]=in[i];<span
style='mso-tab-count:3'>                             </span>// Переписать
текущий символ</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>k=1;</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>out[j]=0;}<span
style='mso-tab-count:4'>                                               </span>//
Добавить &quot;конец строки&quot;</p>

<h3>Инвариант цикла</h3>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m1">З</b>аметим, что логика
работы программы сильно зависит от предположения, которое мы не отметили явно:
за один шаг цикла программа просматривает один символ строки. А есть ли другие
варианты? <span style='mso-bidi-font-weight:bold'>Можно сделать так, что
программа будет «выделять» фрагмент за один шаг. Тогда основной цикл станет
неравномерным, поэтому неправильно будет писать в его заголовке <b><a name="m2">i++</b>. Вот
пример «грязной» программы.<o:p></o:p></span></p>

<p class=a0><span style='letter-spacing:1.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//--------------------------------------------37-03.cpp</p>

<p class=a0>// Отдельный цикл &quot;измерения&quot; повторений. &quot;Грязная
программа&quot;</p>

<p class=a0>void<span style='mso-spacerun:yes'>  </span>F3(char in[]){</p>

<p class=a0>int i,j,k;</p>

<p class=a0>for (i=0; in[i]!=0;){</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for(k=1;in[i]==in[i+k];k++);<span
style='mso-tab-count:1'>          </span>// Измерить длину цепочки</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (k&gt;1)
printf(&quot;%d&quot;,k);</p>

<p class=a0><span style='mso-tab-count:1'>            </span>printf(&quot;%c&quot;,in[i]);</p>

<p class=a0><span style='mso-tab-count:1'>            </span>i=i+k;<span
style='mso-tab-count:4'>                                        </span>// Шаг
цикла – длина цепочки </p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0>}</p>

<p class=a>Можно было бы записать в заголовке <b style='mso-bidi-font-weight:
normal'><a name="m3"><span lang=EN-US style='letter-spacing:1.0pt;mso-ansi-language:EN-US'>i</span><span
style='letter-spacing:1.0pt'>=</span></b><b style='mso-bidi-font-weight:normal'><a name="m4"><span
lang=EN-US style='letter-spacing:1.0pt;mso-ansi-language:EN-US'>i</span><span
style='letter-spacing:1.0pt'>+</span><span
lang=EN-US style='letter-spacing:1.0pt;mso-ansi-language:EN-US'>k</span><span
style='letter-spacing:1.0pt'>, </span></b>но только задним числом. Ведь смысл
переменной <b style='mso-bidi-font-weight:normal'><a name="m5">k </b>определился только в
теле цикла. А теперь попробуем сделать более сложный вариант – произвести
преобразование внутри самой строки. <span style='mso-bidi-font-weight:bold'>Для
этого потребуется затереть часть повторяющейся цепочки цифрами числа-счетчика,
оставить один символ, а остальные удалить. Для этого достаточно «подтянуть
хвост», попарно переписывая символы.<o:p></o:p></span></p>

<p class=a0><span style='letter-spacing:1.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//--------------------------------------------37-04.cpp</p>

<p class=a0>// Отдельный цикл &quot;измерения&quot; повторений. &quot;Сжатие
строки&quot;</p>

<p class=a0>void<span style='mso-spacerun:yes'>  </span>F4(char in[]){</p>

<p class=a0>int i,j,k;</p>

<p class=a0>for (i=0; in[i]!=0;){</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for(k=1;in[i]==in[i+k];k++);<span
style='mso-tab-count:2'>                      </span>// Измерить длину цепочки</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (k==1) i++;<span
style='mso-tab-count:4'>                                         </span>// Нет
повторения - пропустить</p>

<p class=a0><span style='mso-tab-count:1'>            </span>else{</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>j=i+k;<span
style='mso-tab-count:4'>                                        </span>//
Запомнить начало &quot;хвоста&quot;</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>int k1,j1;<span
style='mso-tab-count:3'>                                    </span>// Записать
k в виде символов-цифр</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>for
(k1=k; k1!=0;k1=k1/10,i++);</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>for
(j1=i-1; k!=0;k=k/10,j1--) </p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>in[j1]=k%10+'0';<span
style='mso-tab-count:1'>             </span>//
Затереть символы цифрами числа</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>i++;<span
style='mso-tab-count:4'>                                          </span>//
«Оставить» один символ</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>j1=i;<span
style='mso-tab-count:4'>                                          </span>// i –
начало следующего шага</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>do
{in[j1++]=in[j]; } <span style='mso-tab-count:2'>                    </span>//
j1 – куда, j - откуда</p>

<p class=a0>while(in[j++]!=0);</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}}</p>

<p class=a0><span lang=EN-US style='letter-spacing:1.0pt;mso-ansi-language:
EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0 align="center"><span
lang=EN-US style='letter-spacing:1.0pt;mso-ansi-language:EN-US'><o:p>
<img border="0" src="Images/037-01.gif" width="349" height="155"></o:p></span></p>

<p class=a style="text-align: center"><b><a name="m6">рис. 37-1. Удаление цепочки 
повторяющихся символов</b></p>
<p class=a>Обратите внимание, мы пилим сук, на котором сидим: сдвигаем
содержимое части строки, которую еще будем просматривать.<span
style='mso-spacerun:yes'>  </span>Но «пилить» нужно аккуратно, сохраняя свойство,
которое мы установили в «грязной» программе: за один шаг цикла мы просматриваем
(и преобразуем) фрагмент. Следовательно, по окончании этого шага индекс <b
style='mso-bidi-font-weight:normal'>i </b><span
style='mso-spacerun:yes'> </span>должен устанавливаться сразу после сжатого
фрагмента (на символе <b style='mso-bidi-font-weight:normal'><a name="m7">e</b>). </p>

<p class=a>Резюмируем. Что бы ни происходило в теле цикла, следующий шаг должен
начинаться там, где ему положено. Или же другими словами: в начале каждого шага
цикла индекс <b style='mso-bidi-font-weight:normal'><a name="m8">i </b>должен находиться на
начале очередного фрагмента – отдельного символа или цепочки. Такое свойство,
сохраняемое циклом, называется <b style='mso-bidi-font-weight:normal'><a name="m9">инвариантом.
</b>При проектирований циклических программ это понятие является продуктивным:
прежде чем записывать цикл, нужно сформулировать его инвариант.</p>

<h3>Инвариант цикла и метод математической индукции</h3>

<p class=a4>
<img border="0" src="Images/yan-in.jpg" width="34" height="31" align="left">Есть
еще одна неожиданная параллель между программированием и математикой. В
математических доказательствах иногда используется метод математической
индукции (<b style='mso-bidi-font-weight:normal'><a name="m10">ММИ</b>). Звучит он примерно так:
если утверждение верно при <b style='mso-bidi-font-weight:normal'><a name="m11">i=0, </b>и
если из того, что оно верно при произвольном <b style='mso-bidi-font-weight:
normal'><a name="m12">i</b>, можно вывести, что оно будет верно при <b style='mso-bidi-font-weight:
normal'><a name="m13">i+1</b>, то оно будет верно всегда. </p>

<p class=a style='text-indent:0cm'>
<span style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>На первый
взгляд, метод достаточно очевиден: некоторое свойство сохраняется на всей
цепочке (последовательности), если оно выполняется в первой точке и сохраняется
при переходе из каждой точки в следующую. Но в самом доказательстве есть
элемент диалектики <b style='mso-bidi-font-weight:normal'><a name="m14">общего</b> и <b
style='mso-bidi-font-weight:normal'>частного</b>. Метод определен для
последовательности частных шагов, а доказательство проводится в общем виде для
произвольного перехода от<span style='mso-spacerun:yes'>  </span><b
style='mso-bidi-font-weight:normal'>i-го </b>шага к <b style='mso-bidi-font-weight:
normal'><a name="m15">i+1.<o:p></o:p></b></p>

<p class=a>Между способом доказательства методом математической индукции и
процессом проектирования циклов имеется прямая аналогия. Цикл – это
последовательность <b style='mso-bidi-font-weight:normal'><a name="m16">конкретных</b> шагов,
которая разворачивается во времени при выполнении цикла. В тексте же самой программы
тело цикла задается <b style='mso-bidi-font-weight:normal'><a name="m17">в общем виде. </b>Все
рассуждения по поводу правильности цикла, как правило, являются индуктивными.
Определяется свойство цикла – инвариант, которое сохраняется в процессе его
выполнения. Относительно этого свойства , основываясь на ММИ, можно убедиться в
правильности работы цикла <b style='mso-bidi-font-weight:normal'><a name="m18">в общем виде, </b>если
тело цикла (произвольный шаг) сохраняет указанное свойство.</p>

<p class=a4>
<img border="0" src="Images/labs.jpg" width="41" height="40" align="left">Инвариант
цикла может быть разным. Самым простым является утверждение типа: «в начале
каждого шага цикл находится в…». Например, программа обработки слов в строке
может быть построена по принципу «один шаг = одно слово». Тогда инвариантным
утверждением будет: «в начале шага программа находится на начале очередного
слова».</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//--------------------------------------------37-02.cpp</p>

<p class=a0>// Пословная обработка: &quot;1 шаг = 1 слово&quot;. &quot;Грязная программа&quot;</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
style='mso-spacerun:yes'>  </span><span lang=EN-US style='mso-ansi-language:
EN-US'>F</span>1(<span lang=EN-US style='mso-ansi-language:EN-US'>char</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[]){</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0,<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>;</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>while (in[i]==' ')i++;<span
style='mso-tab-count:1'>         </span>// </span>ДЛЯ<span style='mso-ansi-language:
EN-US'> </span>ПЕРВОГО<span style='mso-ansi-language:EN-US'> </span>ШАГА<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>while</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>]!=0){<span style='mso-tab-count:2'>                </span>//
1 шаг = 1 слово</p>

<p class=a0><span style='mso-tab-count:1'>            </span>// Начало слова</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>while</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>in</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]<span lang=EN-US style='mso-ansi-language:EN-US'>!=' '
&amp;&amp; in[i]!=0)</span><span lang=EN-US> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>i++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>// </span>Конец<span style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US">  </span>слова<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>while (in[i]==' ')i++;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>}}</p>

<p class=a>Инвариант цикла может быть свойством последовательности шагов от
начального до текущего, в том числе выражением, зависящем от номера шага
(индекса). Стандартные программные контексты суммирования и нахождения
максимума основаны на циклах, имеющих соответствующие инварианты. В контексте
суммирования выражение в теле цикла <b style='mso-bidi-font-weight:normal'><a name="m19">s=s+A[i]
</b>сохраняет свойство переменной <b style='mso-bidi-font-weight:normal'><a name="m20"><span
lang=EN-US style='mso-ansi-language:EN-US'>s</span><span lang=EN-US> </span></b>быть
суммой элементов массива он нулевого до текущего. Смысл переменной <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span><span lang=EN-US> </span></b>в правой и левой части различен. В
правой части находится «старое» значение суммы для предыдущего шага, т.е. <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[0]+</b><b style='mso-bidi-font-weight:
normal'><a name="m21"><span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[1]+…+</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>-1], </b>в левой части – уже для
текущего. На первом шаге начальное значение суммы обнуляется. Все сказанное
полностью соответствует идеям ММИ.</p>

<p class=a>Аналогичный порядок рассуждений применим и для контекста,
обеспечивающего нахождение максимума (минимума). Выражение <b style='mso-bidi-font-weight:
normal'><a name="m22"><span lang=EN-US style='mso-ansi-language:EN-US'>if</span> (</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>]&gt;</b><b style='mso-bidi-font-weight:
normal'><a name="m23"><span lang=EN-US style='mso-ansi-language:EN-US'>s</span>) </b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[</b><b style='mso-bidi-font-weight:
normal'><a name="m24"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]; </b>сохраняет
свойство переменной <b style='mso-bidi-font-weight:normal'><a name="m25">s </b><span
style='mso-spacerun:yes'> </span>быть максимальным значением элементов массива
от <b style='mso-bidi-font-weight:normal'><a name="m26">0</b> до <b style='mso-bidi-font-weight:
normal'><a name="m27">i-го. </b>Действительно, если в операции сравнения переменная <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span><span lang=EN-US> </span></b>содержит максимальное значение в
диапазоне от <b style='mso-bidi-font-weight:normal'><a name="m28">0 </b>до <b
style='mso-bidi-font-weight:normal'>i-1</b>, то выражение в целом определяет
максимальное значение с учетом текущего шага: максимум изменяется, если текущее
значение <b style='mso-bidi-font-weight:normal'><a name="m29"><span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[</b><b style='mso-bidi-font-weight:
normal'><a name="m30"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>] </b>превышает
старое значение максимума, иначе – ничего не происходит.</p>

<p class=a>В соответствии с ММИ необходимо обеспечить справедливость
утверждения (инварианта) на первом шаге. Для контекста суммирования это
естественно: сумма последовательности из 0 элементов равна 0.<span
style='mso-spacerun:yes'>  </span>Для контекста поиска максимума максимальное
значение последовательности из 0 элементов или не определено, или не должно
быть «меньше меньшего».<span style='mso-spacerun:yes'>  </span>Поэтому следует
в качестве максимума выбирать значение первого элемента, либо использовать
«защелку» для первого шага.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>for (s=A[0],i=1;i&lt;n;i++)</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (A[i]&gt;s)
s=A[i];</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>for (k=-1,i=0; i&lt;n; i++){<span style='mso-tab-count:2'>               </span>//
поиск минимального из положительных</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (A[i]&lt;0)
continue;<span style='mso-tab-count:1'>         </span><span style='mso-tab-count:
1'>            </span>// </span>пропуск<span style='mso-ansi-language:EN-US'> </span>отрицательных<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>if (k==-1) k=i;<span style='mso-tab-count:2'>                 </span><span
style='mso-tab-count:1'>            </span>// «защелка» на первый положительный</p>

<p class=a0>else</p>

<p class=a0>if (A[i]&lt;A[k]) k=i;<span style='mso-tab-count:2'>                        </span><span
style='mso-tab-count:1'>            </span>// сравнение минимального с
очередным<span style='mso-tab-count:2'>                      </span></p>

<p class=a0>}</p>

<p class=a style='text-indent:0cm'><span
style='mso-no-proof:yes'>
<img border="0" src="Images/yan-in.jpg" width="34" height="31" align="left">Метод математической индукции как способ
доказательства, все же имеет ограниченную область применения. Гораздо важнее,
что он является заключительным шагом <b style='mso-bidi-font-weight:normal'><a name="m31">индуктивного
подхода</b> в таких областях формально-логической деятельности как установление
зависимостей, вывод формул и т.п.. Сущность <span
style='mso-spacerun:yes'> </span>его состоит в следующем:<o:p></o:p></span></p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo2;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>для решения задачи в общем виде (например,
вывода формулы последовательности) первоначально рассматривается одна или
несколько конкретных (частых) последовательностей шагов;</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo2;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>на этой последовательности формально-логически
или интуитивно формулируется<span style='mso-spacerun:yes'>  </span>искомая
зависимость;</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo2;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>справедливость установленной зависимости
доказывается (или, наоборот, опровергается) с использованием ММИ.</p>

<p class=a>Как известно, слово <b style='mso-bidi-font-weight:normal'><a name="m32">индукция</b>
как раз и означает переход от частных утверждений к общим. Метод математической
индукции <span style='mso-spacerun:yes'> </span>является здесь гарантией
корректности такого перехода.</p>

<p class=a>Снова проведем <span style='mso-spacerun:yes'> </span>аналогию с
программированием:</p>

<p class=a1 style='margin-left:74.25pt;text-indent:-18.0pt;mso-list:l1 level1 lfo3;
tab-stops:42.55pt list 74.25pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>как правило, проектирование цикла начинается с
анализа частного случая его работы на конкретной последовательности данных;</p>

<p class=a1 style='margin-left:74.25pt;text-indent:-18.0pt;mso-list:l1 level1 lfo3;
tab-stops:42.55pt list 74.25pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>на конкретном примере определяются составные
части цикла и из них составляется фрагмент циклической программы;</p>

<p class=a1 style='margin-left:74.25pt;text-indent:-18.0pt;mso-list:l1 level1 lfo3;
tab-stops:42.55pt list 74.25pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>определяется инвариант цикла;</p>

<p class=a1 style='margin-left:74.25pt;text-indent:-18.0pt;mso-list:l1 level1 lfo3;
tab-stops:42.55pt list 74.25pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>проверяется, во всех ли случаях сохраняется
инвариант при переходе от текущего шага к следующему, при необходимости в цикл
вводятся коррективы.</p>

<p class=a>При проектировании циклов часто встречаются два вида ошибок, которые
имеют прямое отношение к индуктивному принципу его построения:</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l4 level1 lfo4;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><b style='mso-bidi-font-weight:normal'><a name="m33">ошибка «первого
шага». </b>Первый шаг цикла всегда является особенным, и поведение цикла на
этом шаге нужно учитывать как при его проектировании, так и при проверке уже
написанной программы. Согласно ММИ шаг цикла получает инвариант от предыдущего
шага и сохраняет его с учетом текущего. Поскольку у первого шага нет
предыдущего, то это свойство либо следует установить явно и принудительно, либо
в теле цикла предусмотреть действия, выполняемые только на первом шаге;</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l4 level1 lfo4;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]><b style='mso-bidi-font-weight:normal'><a name="m34">ошибка «+/-
метр от столба». </b>При проектировании цикла легко ошибиться в терминологии
«предыдущий-текущий» и «текущий-следующий». Это приводит к тому, что выполняется
либо один лишный шаг, либо последний шаг цикла пропускается.</p>

<p class=a1 style='margin-left:53.45pt'><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
