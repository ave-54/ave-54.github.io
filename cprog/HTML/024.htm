<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="024.files/filelist.xml">
<link rel=Edit-Time-Data href="024.files/editdata.mso">
<link rel=OLE-Object-Data href="024.files/oledata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>2.4. Стандартные программные контексты</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Comp</o:Author>
  <o:Template>Книга.dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>754</o:TotalTime>
  <o:Created>2008-05-31T10:10:00Z</o:Created>
  <o:LastSaved>2008-05-31T10:10:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>5983</o:Words>
  <o:Characters>34104</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>284</o:Lines>
  <o:Paragraphs>80</o:Paragraphs>
  <o:CharactersWithSpaces>40007</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	mso-style-link:"текст Знак";
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	mso-style-link:"программа Знак";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:-18.0pt;
	mso-pagination:widow-orphan;
	mso-list:l0 level1 lfo4;
	tab-stops:list 36.0pt left 42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.3, li.3, div.3
	{mso-style-name:"заголовок 3";
	mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
span.a7
	{mso-style-name:"текст Знак";
	mso-style-locked:yes;
	mso-style-link:текст;
	mso-ansi-font-size:12.0pt;
	font-family:"Times New Roman CYR";
	mso-ascii-font-family:"Times New Roman CYR";
	mso-hansi-font-family:"Times New Roman CYR";
	mso-ansi-language:RU;
	mso-fareast-language:RU;
	mso-bidi-language:AR-SA;}
span.a8
	{mso-style-name:"программа Знак";
	mso-style-locked:yes;
	mso-style-link:программа;
	font-family:Arial;
	mso-ascii-font-family:Arial;
	mso-hansi-font-family:Arial;
	mso-ansi-language:RU;
	mso-fareast-language:RU;
	mso-bidi-language:AR-SA;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("024.files/header.htm") fs;
	mso-footnote-continuation-separator:url("024.files/header.htm") fcs;
	mso-endnote-separator:url("024.files/header.htm") es;
	mso-endnote-continuation-separator:url("024.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-header:url("024.files/header.htm") h1;
	mso-even-footer:url("024.files/header.htm") ef1;
	mso-footer:url("024.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:702052450;
	mso-list-type:hybrid;
	mso-list-template-ids:576097450 -1450833310 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-style-link:список;
	mso-level-text:\F0B7;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:1686395747;
	mso-list-type:simple;
	mso-list-template-ids:68747279;}
@list l1:level1
	{mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;}
@list l2
	{mso-list-id:2066757269;
	mso-list-type:simple;
	mso-list-template-ids:1876740736;}
@list l2:level1
	{mso-level-start-at:0;
	mso-level-text:%1;
	mso-level-tab-stop:313.5pt;
	mso-level-number-position:left;
	margin-left:313.5pt;
	text-indent:-150.0pt;}
@list l3
	{mso-list-id:2087025814;
	mso-list-type:simple;
	mso-list-template-ids:68747265;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
<!--[if gte mso 9]>
<xml><o:shapedefaults v:ext="edit" spidmax="1027"/>
</xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2>2.4. Стандартные программные контексты</h2>

<p class=a>Итак, логический анализ состоит в выделении из программы стандартных
фрагментов с известным результатом (смыслом). Затем путем логических
умозаключений формулируется результат их взаимодействия как единого целого. Очень
похоже на маленьких мальчиков, которые очень любят заниматься логическим
анализом игрушек, попросту говоря, ломают их, чтобы посмотреть, как они
устроены. Точно так же, как не всегда удается собрать игрушку обратно, не
всегда получается логически соединить полученные части в единое целое.<span
style='mso-bidi-font-weight:bold'> Тогда на помощь приходит «исторический»
анализ: можно рассмотреть взаимодействие этих частей во времени на каком-нибудь
примере и «увидеть» результат.<o:p></o:p></span></p>

<p class=a>Программист мыслит не конструкциями языка - словами, а скорее – фразами.
Конечно, в любой программе есть процент действительно оригинальных решений, но
чаще всего решение задачи сводится к комбинации уже известных. Поскольку<span
style='mso-bidi-font-weight:bold'> фрагменты не просто следуют друг за другом,
а бывают вложены друг в друга, «размазаны» по всей программе, так что результат
их работы не является простым объединением результатов каждого.<o:p></o:p></span></p>

<p class=a><span style='mso-bidi-font-weight:bold'>Введем для них рабочее
название - <span style='mso-spacerun:yes'> </span><b><a name="m1">стандартные программные
контексты (СПК). </b>Что касается их числа<span style='mso-spacerun:yes'> 
</span>-<span style='mso-spacerun:yes'>  </span>в каждой области
программирования есть свой набор таких общепринятых фраз. Но есть и
общеупотребительные, они встречаются практически везде. Например, такие
действия, связанные с изменением порядка следования данных как перенос, обмен,
сдвиг. Или такие, как проверка условий «существует» или «для любого» на
множестве объектов.</span></p>

<h3>Стандартные программные контексты присваивания</h3>

<p class=a>Наибольшим количеством интерпретаций и «смыслов» обладает
присваивание. Понимать его как простое запоминание результатов<span
style='mso-spacerun:yes'>  </span>– слишком примитивно. Ведь запоминать можно
не только данные, но и условия, события и обстоятельства работы программы, а
это имеет отношение к ее поведению. Программа может запомнить, что с ней было,
а потом, в определенных обстоятельствах, вспомнить. Этим она отличается от
других формальных систем «без памяти», например <b style='mso-bidi-font-weight:
normal'><a name="m2">конечных автоматов</b>. Следовательно, присваивание поднимает уровень
поведения программы от <b style='mso-bidi-font-weight:normal'><a name="m3">инстинктивного </b>до
<b style='mso-bidi-font-weight:normal'><a name="m4">рефлекторного</b>. Аналогия с животным
миром вполне уместна. Инстинктивное поведение – это воспроизведение заданной
последовательности действий, хоть и зависящих от внешних обстоятельств, но не
включающих в себя запоминания и, тем более, обучения.<span
style='mso-spacerun:yes'>  </span>Поэтому присваивание обеспечивает качественно
иной уровень поведения программы.</p>

<div style='mso-element:para-border-div;border:solid windowtext 1.5pt;
padding:1.0pt 1.0pt 1.0pt 1.0pt;margin-left:35.45pt;margin-right:32.9pt'>

<p class=a2 style='margin-top:12.0pt;margin-right:0cm;margin-bottom:12.0pt;
margin-left:0cm'>Присваивание – запоминание фактов и событий в истории работы
программы.</p>

</div>

<p class=a4><span style='mso-bidi-font-weight:bold'>Кроме того, такие действия
как обмен, сдвиг, перенос данных – это тоже интерпретации присваивания.<o:p></o:p></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m5">Перенос данных. </b>Присваивание
значения из одного массива (последовательности) в другой можно интерпретировать
как перенос данных, хотя само значение в исходной последовательности никуда не
теряется.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m6">Правило «трех стаканов». </b>Уже
из названия ясно: чтобы поменять содержимое двух стаканов, не смешивая,
необходим третий. Стакан – это переменная, жидкость – значение. </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Обмен значений<span style='mso-spacerun:yes'>  </span>переменных
<b style='mso-bidi-font-weight:normal'><a name="m7"><span lang=EN-US style='mso-ansi-language:
EN-US'>a</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>b</span></b> с использованием переменной <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>c</span><o:p></o:p></b></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>a</span>=5,<span
lang=EN-US style='mso-ansi-language:EN-US'>b</span>=6,<span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>;</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>c</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>a</span>;<span style='mso-tab-count:
2'>                  </span>// перелить содержимое первого стакана в пустой
(третий) стакан</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>a</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>b</span>;<span style='mso-tab-count:
2'>                  </span>// перелить второй в первый</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>b</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>;<span style='mso-tab-count:
2'>                  </span>// перелить третий во второй</p>

<p class=a0 style='text-indent:36.0pt'><o:p>&nbsp;</o:p></p>

<p class=a4><span style='mso-bidi-font-weight:bold'>Обратите внимание на слово
«не смешивая». Есть еще один вариант, в котором используется сложение и вычитание.<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Обмен значений<span style='mso-spacerun:yes'>  </span>переменных
<b style='mso-bidi-font-weight:normal'><a name="m8"><span lang=EN-US style='mso-ansi-language:
EN-US'>a</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>b</span></b> с использованием сложения и
вычитания<b style='mso-bidi-font-weight:normal'><a name="m9"><o:p></o:p></b></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>a</span>=5,<span
lang=EN-US style='mso-ansi-language:EN-US'>b</span>=6;</p>

<p class=a0>a=<span lang=EN-US style='mso-ansi-language:EN-US'>a</span>+<span
lang=EN-US style='mso-ansi-language:EN-US'>b</span>;<span style='mso-tab-count:
2'>              </span>// в переменной <b style='mso-bidi-font-weight:normal'><a name="m10"><span
lang=EN-US style='mso-ansi-language:EN-US'>a</span></b> сумма начальных
значений <b style='mso-bidi-font-weight:normal'><a name="m11"><span lang=EN-US
style='mso-ansi-language:EN-US'>a</span></b><span lang=EN-US> </span>и <b
style='mso-bidi-font-weight:normal'>b</b></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>b=a-b;<span
style='mso-tab-count:2'>               </span>// </span>в<span
style='mso-ansi-language:EN-US'> </span>переменной<span style='mso-ansi-language:
EN-US'> <b style='mso-bidi-font-weight:normal'><a name="m12"><span lang=EN-US>b<span
style='mso-spacerun:yes'>  </span>- (a+b)-b = a</span></b><span lang=EN-US><o:p></o:p></span></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>a=a-b;<span
style='mso-tab-count:2'>               </span>// </span>в<span
style='mso-ansi-language:EN-US'> </span>переменной<span style='mso-ansi-language:
EN-US'> <b style='mso-bidi-font-weight:normal'><a name="m13"><span lang=EN-US>a -<span
style='mso-spacerun:yes'>  </span>(a+b)-a = b</span></b><span lang=EN-US><o:p></o:p></span></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m14">Э</b>тот способ можно
применять, если известно, что такое сумма или разность переменных., то есть для
объектов, имеющих численную природу. В Си этот способ можно распространить,
например, на указатели, если рассматривать их как числа – адреса объектов в
памяти. Но уже со строками будут проблемы. Даже если рассматривать сложение
строк (конкатенацию) как их объединение, то эта операция не коммутативна, при
перестановке строк результат будет иным.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m15">Сдвиг элементов в массиве,
вставка, удаление. </b>Присваивание вида <b style='mso-bidi-font-weight:normal'><a name="m16"><span
lang=EN-US style='mso-ansi-language:EN-US'>A</span>[</b><b style='mso-bidi-font-weight:
normal'><a name="m17"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]=</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>+1] </b>интерпретируется как сдвиг элемента
массива (последовательности) на один влево, хотя формально он читается как
копирование следующего элемента в текущий. Операции вставки и удаления
элементов последовательности сопровождаются таким «массовым» сдвигом.
Рассмотрим несколько примеров.</p>

<p class=a>Из последовательности элементов в памяти (массиве) нужно удалить
заданный. Для устранения возникшего «пустого места» нужно все элементы справа
сдвинуть на одну позицию влево. Чтобы сдвинуть всю оставшуюся часть, нужен
цикл, перебирающий все пары слева – направо, начиная с удаляемого, внутри
которого происходит сдвиг влево (присваивание вида <b><a name="m18"><span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>]=<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>+1]</b>). Для вставки значения на
заданную позицию нужно сделать все наоборот <span style='mso-bidi-font-weight:
bold'>– раздвинуть элементы, перемещая их вправо. При этом цикл перебора пар
также будет двигаться в обратном направлении от последнего элемента к первому.</span></p>

<p class=a0></p>

<p class=a0>
<img border="0" src="Images/024-01.png" width="300" height="319" align="right"></p>
<p class=a0>&nbsp;</p>
<p class=a0>&nbsp;</p>
<p class=a0>&nbsp;</p>
<p class=a0>// Удаление k-го элемента последовательности</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int A[]={1,7,3,4,7,6,3,7,4,3},
n=10;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int k=2;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int vv=A[k];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int
i=k;i&lt;n-1;i++) A[i]=A[i+1];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>n</span>--;</p>

<p class=a0>//----Вставка k-го элемента в последовательность</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int A[20]={1,7,3,4,7,6,3,7,4,3},
n=10;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int k=2,vv=15;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int i=n-1;i&gt;=k;i--)
A[i+1]=A[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>]=<span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span>;</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>n</span>++;</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>&nbsp;</p>
<p class=a0>
<o:p>&nbsp;</o:p></p>

<p class=a4><!--[if gte vml 1]><v:shapetype id="_x0000_t75"
 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
 filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_s1037" type="#_x0000_t75" style='position:absolute;
 margin-left:0;margin-top:13.5pt;width:17.25pt;height:18pt;z-index:2;float:left'
 o:allowoverlap="f">
 <v:imagedata src="" o:title="smile"/>
</v:shape><![endif]--><span
style='mso-bidi-font-weight:bold'>А бывают ли случаи, когда при удалении
все-таки остается пустое место? Да, конечно. Представьте себе дантиста,
удаляющего зуб «со сдвигом всех оставшихся влево». А если серьезно, операция
сдвига является затратной, <span style='mso-spacerun:yes'> </span>поэтому,
например, в двоичных файлах предпочитают оставлять все на своих местах,
исключая элемент из последовательности <b><a name="m19">логически </b>и помечая особым
способом все удаленные элементы.<o:p></o:p></span></p>

<p class=a>Есть еще один оригинальный метод вставки, который вызывает
ассоциации с жонглированием. Если мы хотим включить значение <b
style='mso-bidi-font-weight:normal'>vv </b>на позицию <b style='mso-bidi-font-weight:
normal'><a name="m20">k,</b> то нам мешает это сделать находящееся там значение. Образно
говоря, «подбросим его вверх» в переменную <b style='mso-bidi-font-weight:normal'><a name="m21"><span
lang=EN-US style='mso-ansi-language:EN-US'>vv</span>1, </b>а на освободившееся
место запишем новое значение. Полученное «лишнее» значение <b style='mso-bidi-font-weight:
normal'><a name="m22">vv1</b> надо вставить на следующую позицию, т.е. повторить все, что
было, в цикле. И еще надо не забыть скопировать <b style='mso-bidi-font-weight:
normal'><a name="m23">vv1 </b>в <b style='mso-bidi-font-weight:normal'><a name="m24"><span lang=EN-US
style='mso-ansi-language:EN-US'>vv</span>, </b>чтобы следующий шаг начался при
тех же условиях. Образно говоря, пока «шарик» в воздухе, на его место
помещается новый.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//-----------------------------------------------------------------<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int A[20]={1,7,3,4,7,6,3,7,4,3},
n=10;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int k=2,vv=15,vv1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int
i=k;i&lt;=n;i++){<o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>vv</span>1=<span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>]; <span style='mso-tab-count:
2'>                       </span>// Текущий «подбросить вверх»</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]=<span
lang=EN-US style='mso-ansi-language:EN-US'>vv</span>;<span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:2'>                        </span>//
На его место поместить новый</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>vv</span>=<span lang=EN-US style='mso-ansi-language:EN-US'>vv</span>1; }<span
style='mso-tab-count:2'>                        </span>// «Подброшенный» будет
вставляться на следующую</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>n</span>++;<span
style='mso-tab-count:4'>                                         </span>//
позицию</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Качественно
ничего не изменится, если производить удаление или вставку нескольких
элементов. Просто перенос происходит не на один, а на несколько элементов
вперед или назад. Например, функция, удаляющая в строке слово с заданным
номером, после того, как она определит индексы его начала и конца, должна
выполнить процесс посимвольного перенесения «хвоста» строки. В нем вместо
индексов <b style='mso-bidi-font-weight:normal'><a name="m25"><span lang=EN-US
style='mso-ansi-language:EN-US'>j</span><span lang=EN-US> </span></b>и <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>+1 </b>нужно использовать индексы <b style='mso-bidi-font-weight:
normal'><a name="m26"><span lang=EN-US style='mso-ansi-language:EN-US'>j</span><span
lang=EN-US> </span></b>и <b style='mso-bidi-font-weight:normal'><a name="m27"><span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>+</b><b style='mso-bidi-font-weight:
normal'><a name="m28"><span lang=EN-US style='mso-ansi-language:EN-US'>m</span>, «</b>разнесенные»<b
style='mso-bidi-font-weight:normal'> </b>на длину слова <b style='mso-bidi-font-weight:
normal'><a name="m29"><span lang=EN-US style='mso-ansi-language:EN-US'>m</span></b>, либо
индексы начала и конца слова <b style='mso-bidi-font-weight:normal'><a name="m30"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span><span lang=EN-US> </span></b>и
<b style='mso-bidi-font-weight:normal'><a name="m31"><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span></b>.</p>

<p class=a align=right style='text-align:right'>
<b style='mso-bidi-font-weight:normal'><a name="m32"><span style='mso-tab-count:3'>                             </span></b><span
style='mso-spacerun:yes'>                        </span></p>

<p class=a0>//------------------------------------------------------24-01.cpp</p>

<p class=a0>//------ Удаление слова с заданным номером</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>CutWord</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>char</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>){<img border="0" src="Images/024-02.png" width="300" height="169" align="right"></p>

<p class=a0><span style='mso-spacerun:yes'> </span>int j=0;<span
style='mso-spacerun:yes'>                                   </span><span
style='mso-tab-count:2'>              </span>// j - индекс конца слова</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (j=0; c[j]!=0; j++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (c[j]!=' </span>' &amp;&amp; (<span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>j</span>+1]==' ' || <span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>+1]==0))</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
style='mso-spacerun:yes'>   </span>if (n--==0) break;<span
style='mso-spacerun:yes'>         </span><span style='mso-tab-count:1'> </span>//
Обнаружен конец n-го слова</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span style='mso-tab-count:
1'>           </span>if (n==-1 &amp;&amp; c[j]!=0){ <span style='mso-tab-count:
2'>                  </span>// Действительно был выход по концу слова</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for (int i=j; i&gt;=0 &amp;&amp; c[i]!=' </span>'; i--); <span
style='mso-tab-count:1'>   </span>// Поиск начала слова</p>

<p class=a0 style='text-indent:36.0pt'>i++;<span
style='mso-spacerun:yes'>                         </span><span
style='mso-tab-count:2'>                 </span>// Вернуться на первый символ
слова</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for(j++; c[j]!=0;
i++, j++)<span style='mso-spacerun:yes'>       </span><span style='mso-tab-count:
1'>      </span>// Перенос очередного символа</p>

<p class=a0><span style='mso-tab-count:1'>            </span>c[i]=c[j];<span
style='mso-spacerun:yes'>                              </span><span
style='mso-tab-count:1'>      </span>// ближе к началу</p>

<p class=a0><span style='mso-tab-count:1'>            </span>c[i]=0;<span
style='mso-spacerun:yes'>                     </span><span style='mso-tab-count:
2'>                  </span>// Сам конец строки не был перенесен</p>

<p class=a0>}}</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m33">Присваивание как запоминание
«истории» работы программы. </b>При присваивании можно сохранять не только
тривиально понимаемые «промежуточные результаты». Программа может запоминать
также значения собственных характеристик работы и параметры обрабатываемых
данных. В дальнейшем программа может использовать все это на последующих шагах
алгоритма. В связи с этим возникает несколько замечаний:</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>место (конструкция алгоритма), в котором
происходит запоминание, определяется условиями,<span style='mso-spacerun:yes'> 
</span>при которых программа туда попадает. Например, при обменной сортировке
место перестановки пары элементов запоминается в том фрагменте программы, где
эта перестановка происходит.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0 style='text-indent:35.45pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for (i=0; i&lt;n-1; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><b style='mso-bidi-font-weight:normal'><a name="m34">if
(A[i]&gt;A[i+1])<span style='mso-tab-count:3'>                           </span></b>//
</span>условие<span style='mso-ansi-language:EN-US'> </span>перестановки<b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></b></p>

<p class=a0><b style='mso-bidi-font-weight:normal'><a name="m35">
<span style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span></b><span
lang=EN-US style='mso-ansi-language:EN-US'>{<span style='mso-tab-count:3'>                                   </span>//
</span>перестановка<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>c=A[i]; A[i]=A[i+1];
A[i+1]=c;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span><b style='mso-bidi-font-weight:
normal'><a name="m36">b</b></span><b style='mso-bidi-font-weight:normal'><a name="m37">1=<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>;</b><span style='mso-tab-count:2'>                </span><span
style='mso-tab-count:1'>            </span>// Запоминание индекса <b
style='mso-bidi-font-weight:normal'>в момент </b>перестановки</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>запоминающая переменная имеет тот же самый<span
style='mso-spacerun:yes'>  </span><b style='mso-bidi-font-weight:normal'><a name="m38">смысл</b>,
(ту же самую смысловую интерпретацию), что и запоминаемая. Так, в предыдущем
примере, если переменная <b style='mso-bidi-font-weight:normal'><a name="m39"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span><span lang=EN-US> </span></b>является
индексом в массиве, то <b style='mso-bidi-font-weight:normal'><a name="m40"><span lang=EN-US
style='mso-ansi-language:EN-US'>b</span>1 </b>также имеет смысл индекса.</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>если запоминание производится в цикле, то по
окончании цикла<span style='mso-spacerun:yes'>  </span>будет сохранено значение
<b style='mso-bidi-font-weight:normal'><a name="m41">последнего из возможных. </b>Так в нашем
примере <b style='mso-bidi-font-weight:normal'><a name="m42"><span lang=EN-US
style='mso-ansi-language:EN-US'>b</span>1 – </b>это индекс <b style='mso-bidi-font-weight:
normal'><a name="m43">последней </b>перестановки<b style='mso-bidi-font-weight:normal'><a name="m44">. </b>Если
же требуется запомнить значение <b style='mso-bidi-font-weight:normal'><a name="m45">первого</b>
из возможных, то присваивание нужно сопроводить<span style='mso-spacerun:yes'> 
</span>альтернативным выходом из цикла через <b style='mso-bidi-font-weight:
normal'><a name="m46"><span lang=EN-US style='mso-ansi-language:EN-US'>break</span>. </b>Если
требуется запоминание максимального/минимального значения, то присваивание
нужно выполнить в контексте выбора минимума/максимума.</p>

<h3>Стандартные программные контексты переменных</h3>

<p class=a>Следующие контексты определяют наиболее распространенные смысловые
интерпретации переменных. Многие алгоритмы используются такие решения, как
подсчет количества, суммирование, определение минимального и т.п.. Каждому из
них соответствует свой контекст.</p>

<p class=a><b><a name="m47">Переменная – счетчик.</b> Переменная считает количество появлений
в программе того или иного события, количество элементов, удовлетворяющих тому
или иному условию. Фрагмент, определяющий смысл переменной-счетчика, выглядит
так<span style='font-family:"Times New Roman"'>:</span></p>

<p class=a0><b style='mso-bidi-font-weight:normal'><a name="m48"><span style='font-family:
"Times New Roman CYR";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></b></p>

<p class=a0>for (<span lang=EN-US style='mso-ansi-language:EN-US'>m</span>=0,...)
{ if (...удовлетворяет условию...) m++; }</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Логика данного фрагмента очевидна: переменная-счетчик увеличивает
свое значение на <b style='mso-bidi-font-weight:normal'><a name="m49">1</b> при каждом выполнении
проверяемого условия. Остается сформулировать только смысл самого условия. В
следующем примере переменная <b style='mso-bidi-font-weight:normal'><a name="m50">m</b>
подсчитывает количество положительных элементов в массиве.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0, m=0;
i&lt;n; i++) if(A[i]&gt;0) m++; <o:p></o:p></span></p>

<p class=a>Необходимо также обратить внимание на то, когда сбрасывается сам
счетчик. Если это делается однократно, то процесс подсчета происходит
однократно во всем фрагменте. Если же счетчик сбрасывается при каком-то
условии, то такой процесс подсчета сам является повторяющимся. В следующем
примере переменная-счетчик последовательно нумерует (считает) символы в каждом
слове строки, сбрасываясь по пробелу между словами.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for(m=0,i=0;
c[i]!=0; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (c[i]==’ ’) m=0; else m++;<o:p></o:p></span></p>

<p class=a><b><a name="m51">Переменная – накопитель. </b>Смысл накопительства – к тому, что
уже имеешь, добавляй то, что получаешь. Если эту фразу перевести на язык
программирования, а под накопленным значением подразумевать сумму или
произведение, то получим еще один контекст, определяющий накопление суммы и
смысл соответствующей переменной:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for
(s=0,...;...;...) { </span>получить<span lang=EN-US style='mso-ansi-language:
EN-US'> k; s=s+k; }<o:p></o:p></span></p>

<p class=a>Он дает переменной <b style='mso-bidi-font-weight:normal'><a name="m52"><span
lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:EN-US'>s</span><span lang=EN-US style='font-family:"Times New Roman"'>
</span></b>единственный смысл - переменная накапливает сумму значений <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>k</span>, </b>полученных на каждом из шагов выполнения
цикла. Этот факт достаточно очевиден и сам по себе – на каждом шаге к значению
переменной <b style='mso-bidi-font-weight:normal'><a name="m53"><span lang=EN-US
style='mso-ansi-language:EN-US'>s</span><span lang=EN-US> </span></b>добавляется
новое <b style='mso-bidi-font-weight:normal'><a name="m54"><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span><span lang=EN-US> </span></b>и результат запоминается оба том же
самом <b style='mso-bidi-font-weight:normal'><a name="m55"><span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>. </b>Для особо неверующих в качестве строгого доказательства
можно привлечь<b style='mso-bidi-font-weight:normal'><a name="m56"> </b>метод математической
индукции<span style='font-family:"Times New Roman"'>. </span>Действительно,
если на очередном шаге цикла <b style='mso-bidi-font-weight:normal'><a name="m57"><span
lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:EN-US'>s</span><span lang=EN-US style='font-family:"Times New Roman"'>
</span></b>содержит сумму, накопленную на предыдущих шагах, то после выполнения
<b style='mso-bidi-font-weight:normal'><a name="m58"><span lang=EN-US style='font-family:
"Times New Roman";mso-ansi-language:EN-US'>s</span></b><b style='mso-bidi-font-weight:
normal'><a name="m59"><span style='font-family:"Times New Roman"'>=</span></b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>s</span><span
style='font-family:"Times New Roman"'>+</span></b><b style='mso-bidi-font-weight:
normal'><a name="m60"><span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'>k</span></b><b style='mso-bidi-font-weight:normal'><a name="m61"><span lang=EN-US
style='font-family:"Times New Roman"'> </span></b>она будет содержать сумму уже
с учетом текущего шага. Кроме того, утверждение должно быть верно в самом
начале – этому соответствует обнуление переменной <b style='mso-bidi-font-weight:
normal'><a name="m62"><span lang=EN-US style='mso-ansi-language:EN-US'>s</span><span
lang=EN-US> </span></b>для суммы и установка ее в 1 для произведения<b
style='mso-bidi-font-weight:normal'>. </b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=0,i=0;
i&lt;10; i++) s=s+A[i]; <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=1,i=0;
i&lt;10; i++) s=s*A[i]; <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>Накопление может происходить в разных контекстах, но они не меняют
самого принципа. В приведенных них примерах накапливается сумма значений,
полученных разными способами и от разных источников<span style='font-family:
"Times New Roman"'>:<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=0,i=0;
i&lt;n; i++)<span style='mso-tab-count:3'>                             </span>//
</span>Сумма<span style='mso-ansi-language:EN-US'> </span>элементов<span
style='mso-ansi-language:EN-US'> </span>массива<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>s+=A[i];<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>for (s=0,i=0; i&lt;n &amp;&amp; A[i]&gt;=0; i++)<span
style='mso-tab-count:1'>            </span>//
Сумма элементов массива до первого</p>

<p class=a0><span style='mso-tab-count:1'>            </span>s+=A[i];<span
style='mso-tab-count:4'>                                    </span>//
отрицательного</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>for (s=0,i=0; i&lt;n; i++)<span style='mso-tab-count:3'>                             </span>//
Сумма положительный элементов </p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (A[i]&gt;0) s+=A[i];<span style='mso-tab-count:
2'>                      </span>// </span>массива<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0>for (s=0,x=0; x&lt;=1; x+=0.1)<span style='mso-tab-count:2'>                    </span>//
Сумма значений функции sin</p>

<p class=a0><span style='mso-tab-count:1'>            </span>s+=sin(x);<span
style='mso-tab-count:3'>                                 </span>// в диапазоне
0..1 с шагом 0.1</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m63">Переменная – минимум
(максимум).</b> Фрагмент, выполняющий поиск минимального или максимального
значения в последовательности встречается даже чаще, чем остальные, но почему-то
менее узнаваем в окружающем контексте. Следующая логическая схема дает
переменной <b style='mso-bidi-font-weight:normal'><a name="m64"><span lang=EN-US
style='font-family:"Times New Roman";mso-ansi-language:EN-US'>s</span><span lang=EN-US style='font-family:"Times New Roman"'>
</span></b>единственный смысл - переменная находит максимальное из<span
style='mso-spacerun:yes'>  </span>значений <b style='mso-bidi-font-weight:normal'><a name="m65"><span
lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:EN-US'>k</span>,
</b>полученных на каждом из шагов выполнения цикла.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=a0>for (s=меньше меньшего,...;...;...) { получить <span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>; <span lang=EN-US style='mso-ansi-language:
EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>k</span>&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>) <span lang=EN-US
style='mso-ansi-language:EN-US'>s</span>=<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>; }</p>

<p class=a4>Доказать это не сложнее, чем в случае с переменной-накопителем.
Фрагмент <b style='mso-bidi-font-weight:normal'><a name="m66">if (k&gt;s) s=k; </b>читается
буквально так: если новое значение больше, чем то, которое имеется у вас, вы
его запоминаете, иначе оставляете старое. То есть осуществляется обычный
принцип выбора «большего из двух зол». Формальное доказательство как
иллюстрация метода математической индукции уже было проведено в <b
style='mso-bidi-font-weight:normal'>2.3.</b> Типичный пример контекста -
нахождение максимального элемента массива.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=0,i=0;
i&lt;10; i++) if (A[i]&gt;s) s=A[i];<o:p></o:p></span></p>

<p class=a>Рассмотрим более сложные вариации на эту тему. Следующий фрагмент
запоминает не само значение максимума, а номер элемента в массиве, где оно
находится<span style='font-family:"Times New Roman"'>, что по сути не меняет
контекста: сочетание сравнения с присваиванием, только сравниваются значения, а
присваиваются индексы.</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=1,k=0;
i&lt;10; i++) if (A[i]&gt;A[k]) k=i;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-spacerun:yes; mso-ansi-language:EN-US' lang="EN-US"> </span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m67">Переменная – признак.</b> Признак
– это логическая переменная, принимающая значения 0 (ложь) или 1 (истина) в
зависимости от наступления какого-либо события в программе (событие наступило –
1 или не наступило - 0). В одной точке программы проверяется это условие и
устанавливается признак, в другой -<span style='mso-spacerun:yes'> 
</span>наличие или отсутствие признака оказывает влияние на логику работы<span
style='mso-spacerun:yes'>  </span>программы, в третьей - признак сбрасывается.
Простой пример -<span style='mso-spacerun:yes'>  </span>суммирование элементов
массива до первого отрицательного включительно.</p>

<p class=MsoNormal style='mso-list:skip'><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=0, k=0, i=0;
i&lt;n &amp;&amp; k==0; i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>s</span>+=<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>];</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&lt;0)
<span lang=EN-US style='mso-ansi-language:EN-US'>k</span>=1;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a4>В данном случае переменная-признак <b style='mso-bidi-font-weight:
normal'><a name="m68"><span lang=EN-US style='mso-ansi-language:EN-US'>k</span><span
lang=EN-US> </span></b>устанавливается в 1 после обнаружения и добавления к
сумме отрицательного элемента массива. Установка этого признака нарушает
условие продолжения и прекращает выполнение цикла. Эквивалентный вариант с
использованием <b style='mso-bidi-font-weight:normal'><a name="m69">break</b> позволяет
обойтись без такого признака.</p>

<p class=MsoNormal style='mso-list:skip'><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (s=0, i=0;
i&lt;n; i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>s+=A[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]&lt;0) <span lang=EN-US style='mso-ansi-language:EN-US'>break</span>;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a>Сложнее распознать роль признака при его многократной установке и
сбрасывании. Например, если признак устанавливается или сбрасывается на каждом
шаге цикла. Нужно учитывать тот факт, что установленное значение сохраняется
некоторое время, в данном случае – до следующего шага. То есть в начале шага
признак хранит свое значение, полученное на предыдущем.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0,s=0,k=0;
i&lt;10; i++)<o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>if (A[i]&lt;0) k=1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span>else</span></p>

<p class=a0 style='margin-left:36.0pt;text-indent:36.0pt'>{ <span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>==1) <span lang=EN-US style='mso-ansi-language:EN-US'>s</span>++;<span
style='mso-spacerun:yes'>  </span><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>=0; }<span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'><o:p></o:p></span></p>

<p class=a0 style='margin-left:36.0pt;text-indent:36.0pt'><o:p>&nbsp;</o:p></p>

<p class=a4>Несложно догадаться, что смысл переменной-признака <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>k</span><span
lang=EN-US style='font-family:"Times New Roman"'> </span></b><span
style='font-family:"Times New Roman"'>- </span>элемент массива является отрицательным,
причем в начале следующего шага признак сохраняет свое значение, полученное на
предыдущем. Счетчик <b style='mso-bidi-font-weight:normal'><a name="m70"><span lang=EN-US
style='mso-ansi-language:EN-US'>s</span><span lang=EN-US> </span></b>увеличивается,
если выполняется ветка <b style='mso-bidi-font-weight:normal'><a name="m71"><span lang=EN-US
style='font-family:"Times New Roman";mso-ansi-language:EN-US'>else</span><span lang=EN-US style='font-family:"Times New Roman"'>
</span></b><span style='font-family:"Times New Roman"'>- </span>текущий элемент
массива положителен, и в то же самое время условие <b style='mso-bidi-font-weight:
normal'><a name="m72"><span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'>k</span></b><b style='mso-bidi-font-weight:normal'><a name="m73"><span
style='font-family:"Times New Roman"'>==1 - </span></b>соответствует
отрицательному значению <b style='mso-bidi-font-weight:normal'><a name="m74">предыдущего </b>элемента
массива, поскольку его сброс в 0 происходит позже. Следовательно, фрагмент
подсчитывает количество пар элементов вида «отрицательный - положительный».<b
style='mso-bidi-font-weight:normal'><o:p></o:p></b></p>

<p class=a>Еще один пример - обнаружение комментариев в строке. Признак <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-family:"Times New Roman";
mso-ansi-language:EN-US'>com</span><span
lang=EN-US style='font-family:"Arial CYR";mso-bidi-font-family:"Times New Roman"'>
</span></b>устанавливается в 1, если программа находится «внутри комментария».
Процесс переписывания происходит при нулевом значении признака, то есть «вне
комментария»</p>

<p class=MsoNormal style='mso-list:skip'><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void copy(char
dst[], char src[])<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>{ int i,com=0,j=0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (com=0,i=0;
src[i]!=0; i++)<o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>com</span>==1){<span
style='mso-tab-count:3'>                               </span><span
style='mso-spacerun:yes'>  </span>
<span style='mso-tab-count:2; font-family:Courier New; mso-bidi-font-family:Times New Roman'>           </span>//
внутри комментария</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'><span style='mso-tab-count:1'>            </span>if</span>
(<span lang=EN-US style='mso-ansi-language:EN-US'>src</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>]==’*’ &amp;&amp; <span lang=EN-US
style='mso-ansi-language:EN-US'>src</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>+1]==’/’)</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>    </span>
<span style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                    </span>{ <span
lang=EN-US style='mso-ansi-language:EN-US'>com</span>=0; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++; }<span style='mso-tab-count:1'>  </span><span
style='mso-tab-count:2'>                        </span>// не в комментарии,
пропустить символ</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'><span style='mso-tab-count:1'>            </span>}<o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>else <span style='mso-tab-count:1'>     </span>{<span style='mso-tab-count:
3'>                                   </span><span style='mso-spacerun:yes'> 
</span><span style='mso-tab-count:1'>          </span><span style='mso-tab-count:
1'>            </span>// </span>вне<span style='mso-ansi-language:EN-US'> </span>комментария<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>if (src[i]==’/’
&amp;&amp; src[i+1]==’*’)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'>   
</span><span style='mso-tab-count:2'>                    </span></span>{ <span
lang=EN-US style='mso-ansi-language:EN-US'>com</span>=1; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++; }<span style='mso-tab-count:3'>                          </span>//
в комментарии, пропустить символ</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'><span style='mso-tab-count:1'>            </span>else<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'>   
</span><span style='mso-tab-count:2'>                    </span>dst</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>++] = <span lang=EN-US
style='mso-ansi-language:EN-US'>src</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>];<span style='mso-tab-count:1'> </span>// переписать символ в
выходную строку</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span
style='mso-spacerun:yes'>   </span>
<span style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">         </span>}</p>

<p class=a style='text-indent:0cm'>dst[j]=0; }<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a>Кстати, для исключения вложенных комментариев можно предложить
другую смысловую интепретацию переменной – уровень вложенности, увеличивая ее
на 1 при входе и уменьшая при выходе.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m75">Переменная – защелка. </b>Защелкой
называется переменная, которая меняет свое значение один раз за все время
работы программы или ее части (например, цикла) – «защелкивается». Защелкой
может быть также отдельное, отличное от других значение переменной. Характерный
пример использования значения-защелки – поиск минимума (максимума), когда он
проводится не на всем множестве элементов. Например, поиск минимального среди
положительных. Проблема здесь в том, что в операции сравнения фигурируют два
значения – текущее и минимальное. Минимальное же на первом шаге неизвестно. В
принципе, можно ввести дополнительный цикл, который пробегает
последовательность до первого элемента, удовлетворяющего условия, при котором
ищется минимум.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>=-1,<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>=0; <span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>&lt;<span lang=EN-US style='mso-ansi-language:EN-US'>n</span>
&amp;&amp; <span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&lt;0;<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++);<span style='mso-tab-count:2'>             </span>//
Пропуск до первого положительного</p>

<p class=a0>for (; i&lt;<span lang=EN-US style='mso-ansi-language:EN-US'>n</span>;
i++){<span style='mso-tab-count:4'>                                       </span>//
Цикл среди оставшихся </p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>if (A[i]&lt;0) continue;<span style='mso-tab-count:2'>                     </span>//
</span>Пропуск<span style='mso-ansi-language:EN-US'> </span>отрицательных<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&lt;<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>]) <span lang=EN-US style='mso-ansi-language:EN-US'>k</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>;<span style='mso-tab-count:
3'>                                    </span>// Сравнение «в пользу
минимального»</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Второй вариант использует значение индекса <b style='mso-bidi-font-weight:
normal'><a name="m76">-1</b> в качестве защелки. При появлении первого положительного
элемента срабатывает защелка, а сравнение происходит только для последующих.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>for (i=0,k=-1; i&lt;10; i++) {<span style='mso-tab-count:2'>             </span>//
k=-1 – защелка, не обнаружен положительный</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>if (A[i]&lt;0) continue;<span style='mso-tab-count:1'>         </span>//
</span>пропуск<span style='mso-ansi-language:EN-US'> </span>отрицательных<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span
style='mso-tab-count:1'>      </span>if</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>==-1) <span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>=<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>;<span style='mso-tab-count:2'>                 </span>// срабатывает
защелка на первом положительном</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>else</span><span style='mso-spacerun:yes'>  </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&lt;<span
lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>]) <span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>=<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>;<span
style='mso-tab-count:1'>    </span>// на втором и последующих - сравнение</p>

<h3>Стандартные программные контексты циклов</h3>

<p class=a>С циклами связано большое количество технологических приемов и
смысловых интерпретаций.</p>

<p class=a><b><a name="m77">Предыдущий, текущий, следующий.</b> Если имеется
последовательность адресуемых по номеру элементов, например, элементов массива,
то по отношению к <b style='mso-bidi-font-weight:normal'><a name="m78"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>-му </b>элементу, с которым программа
работает на текущем шаге цикла, <b style='mso-bidi-font-weight:normal'><a name="m79"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>-1 </b>будет предыдущим, а <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>+1 –</b> последующим. Так и следует, особенно не задумываясь,
переводить с формального на естественный язык и обратно.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int F(char c[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int nw=0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>[0]!=0) <span lang=EN-US
style='mso-ansi-language:EN-US'>nw</span>=1;<span style='mso-tab-count:3'>                                    </span>//
Строка начитается на с пробела – 1 слово</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=1; <span lang=EN-US
style='mso-ansi-language:EN-US'>c</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]!=0; <span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++)<span
style='mso-tab-count:3'>                           </span>// Сочетание не
пробел, а перед ним -пробел</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (c[i]!=’ ‘ &amp;&amp; c[i-1]==’ ‘) nw++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>nw</span>;}</p>

<p class=a4>Если <b style='mso-bidi-font-weight:normal'><a name="m80">текущий </b>символ
строки не является пробелом и одновременно <b style='mso-bidi-font-weight:normal'><a name="m81">предыдущий
</b>символ строки – пробел, то к счетчику добавляется 1. Сочетание «пробел – не
пробел», как нетрудно догадаться (а этого уже в программе не увидите), является
началом слова. Таким образом, программа подсчитывает количество слов строке,
реагируя на их начало. Если строка начинается со слова и перед ним нет пробела,
то такая ситуация отслеживается отдельно.</p>

<p class=a>Если же элементы последовательности прямо не адресуются по номерам,
то предыдущий и «более ранние» можно фиксировать «исторически». При переходе к
следующему шагу цикла данные о расположении текущего элемента (например,
указатель) можно запомнить в отдельной переменной, которая на следующем шаге
будет играть роль «предыдущей». Следующий фрагмент выводит числа, цифры которых
находятся в порядке возрастания. Для обнаружения этого условия в цикле,
раскладывающем число на цифры, необходимо помнить предыдущую. Поскольку цифры
получаются в обратном порядке, то нам необходимо установить факт убывания.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=a0>//---------------------------------------24-02.cpp</p>

<p class=a0>// Поиск чисел с возрастающими цифрами</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void main(){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int a=100000;
a&lt;200000; a++){<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>int n,k,kp=10,m=1;<span
style='mso-tab-count:2'>                     </span><span style='mso-tab-count:
1'>            </span>// m - признак убывания</p>

<p class=a0><span style='mso-tab-count:1'>            </span>for(n=a;n!=0;n=n/10){<span
style='mso-tab-count:1'>      </span><span style='mso-tab-count:2'>                        </span>//
kp - предыдущая цифра </p>

<p class=a0><span style='mso-tab-count:2'>                        </span>k=n%10;<span
style='mso-tab-count:2'>                       </span><span style='mso-tab-count:
1'>            </span>// k - очередная цифра</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(k&gt;=kp){ m=0; break; } <span style='mso-tab-count:1'>            </span>//
нет убывания - выход</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>kp=k;<span
style='mso-tab-count:4'>                                        </span>//
текущая стала предыдущей</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (m!=0)
printf(&quot;%d\n&quot;,a);<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>}}</p>

<p class=a>Аналогичные присваивания производятся в <b style='mso-bidi-font-weight:
normal'><a name="m82">итерационных циклах, </b>где каждый шаг характеризуется «текущим»
значением переменной, вычисляемой или выводимой из ее «предыдущих» значений,
точнее, значений на предыдущих шагах того же цикла. В них при переходе к
следующему шагу «текущее» значение становится «предыдущим», а иногда и
«вчерашнее» - «позавчерашним» (см. <b style='mso-bidi-font-weight:normal'><a name="m83">4.3</b>).
</p>

<p class=a><b><a name="m84"><span style='font-family:"Times New Roman"'>Равномерное и
неравномерное движение в цикле. </span></b>Многие программы, работающие с
массивами, осуществляют различные линейные перемещения по их элементам. При
этом по отношению к шагам цикла движение может быть равномерным, т.е. по одному
перемещению на каждый шаг, а значит безусловным, и неравномерным, т.е. происходящим
при выполнении каких-либо условий. В первом случае изменение индекса можно
вынести в заголовок цикла, во втором случае это недопустимо. Все иллюстрации –
в следующем контексте.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m85">Индексы как независимые
перемещения в цикле.</b> - Каждому независимому перемещению по массиву должен
соответствовать свой индекс. В механике это соответствует термину «степень
свободы». Аналогии с механикой здесь не только уместны, но и необходимы, ибо
являются частью образного представления программы. Выбирая индексы и задавая
способ их изменения, мы тем самым выбираем закон движения – последовательный,
равномерный, возвратно-поступательный, параллельный и т.д..</p>

<div style='mso-element:para-border-div;border:solid windowtext 1.5pt;
padding:1.0pt 1.0pt 1.0pt 1.0pt;margin-left:35.45pt;margin-right:32.9pt'>

<p class=a2 style='margin-top:12.0pt;margin-right:0cm;margin-bottom:12.0pt;
margin-left:0cm'>Количество индексов в программе соответствует количеству
независимых перемещений по массиву (степеней свободы).</p>

</div>

<p class=a>Часто встречающаяся ошибка - попытка «убить одним индексом двух
зайцев», то есть запрограммировать одним индексом несколько независимых
перемещений. Другое дело, что вариантов выделения «степеней свободы» в
программе может быть несколько. В каждом случае необходимо осмыслить траекторию
движения выделенных индексов и дать им необходимую словесную интерпретацию.</p>

<p class=a>Функция, «переворачивающая» строку, моделирует встречное движение
двух индексов по строке от концов к середине. По отношению к каждой паре
символов применяется «правило трех стаканов» для обмена их местами. Поскольку
оба перемещения равномерны, они могут быть смоделированы двумя независимыми индексами,
изменяемыми в заголовке цикла.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span><img border="0" src="Images/024-03.png" width="300" height="174" align="right"></p>

<p class=a0><span
lang=EN-US style='mso-ansi-language:EN-US'>//</span>--------------------------
«Переворачивание» строки</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>swap</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>char</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>[]){ </p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>int</span><span lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>,<span lang=EN-US style='mso-ansi-language:EN-US'>j</span>;</p>

<p class=a0 style='text-indent:36.0pt'>// Цикл поиска конца строки для <span
lang=EN-US style='mso-ansi-language:EN-US'>j</span></p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0;
<span lang=EN-US style='mso-ansi-language:EN-US'>c</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>] !='\0'; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++);<span
style='mso-spacerun:yes'>                  </span></p>

<p class=a0 style='text-indent:36.0pt'>// Цикл попарного обмена</p>

<p class=a0 style='text-indent:36.0pt'><span lang=EN-US style='mso-ansi-language:
EN-US'>for</span> (<span lang=EN-US style='mso-ansi-language:EN-US'>j</span>=0,<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>--<span lang=EN-US
style='mso-ansi-language:EN-US'>; i&gt;j; i--,j++)<span
style='mso-spacerun:yes'>          </span><span style='mso-tab-count:2'>                   </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span>{
char s; s=c[i]; c[i]=c[j]; c[j]=s; }}<o:p></o:p></span></p>

<p class=a align=right style='text-align:right'><b style='mso-bidi-font-weight:
normal'><a name="m86"><span style='mso-tab-count:3'>                                    </span></b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></b></p>

<p class=a><br
style='mso-ignore:vglayout' clear=ALL>
В примере <b style='mso-bidi-font-weight:normal'><a name="m87">слияния последовательностей</b>
мы видим в одном цикле целых три индекса с различными «динамическими»
свойствами. Слияние - это процесс соединения двух упорядоченных последовательностей
в одну общую, тоже упорядоченную. Каждый шаг слияния включает выбор
минимального из двух очередных элементов и переноса его в выходную
последовательность, после чего на место перенесенного элемента выступает
следующий. Каждая последовательность (массив) имеет собственный индекс, но
только индекс выходного массива меняется линейно, поскольку за один шаг
производится одно перемещение. Поскольку переход к следующему элементу во
входной последовательности происходит только в одной из них (где выбран минимальный
элемент), изменение индексов (неравномерное движение) производится внутри
условной конструкции. И последнее. Каждая из входных последовательностей может
закончиться раньше, чем противоположная, и это также необходимо отслеживать.</p>
<p class=a>&nbsp;</p>

<p class=a0></p>

<p class=a0><o:p>&nbsp;</o:p><img border="0" src="Images/024-04.png" width="400" height="208">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img border="0" src="Images/024-05.png" width="300" height="327"></p>
<p class=a0>&nbsp;</p>

<p class=a align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m88">Рис.24-</b><b style='mso-bidi-font-weight:normal'><a name="m89"><span lang=EN-US
style='mso-ansi-language:EN-US'>5</span>. Слияние и разделение</b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//-------------------------- Слияние упорядоченных
последовательностей</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>void</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>sleave</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>out</span>[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>1[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>in</span>2[], <span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>){</p>

<p class=a0><span style='mso-spacerun:yes'> </span>int i,j,k;<span
style='mso-spacerun:yes'>                  </span><span style='mso-tab-count:
2'>                  </span><span style='mso-tab-count:1'>            </span>//
Каждой последовательности - по индексу</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span lang=EN-US
style='mso-ansi-language:EN-US'>for (i=j=k=0; i&lt;2*n; i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (k==n) out[i]=in1[j++];<span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:1'>            </span>//
</span>Вторая<span style='mso-ansi-language:EN-US'> </span>кончилась<span
lang=EN-US style='mso-ansi-language:EN-US'> - </span>сливать<span
style='mso-ansi-language:EN-US'> </span>первую<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>else</p>

<p class=a0 style='text-indent:36.0pt'>if (j==n) out[i]=in2[k++]; <span style='mso-tab-count:1'>            </span>//
Первая кончилась - сливать вторую</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>else</span><span
style='mso-spacerun:yes'>                             </span><span style='mso-tab-count:1'>            </span>//
Сливать меньший из очередных</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (in1[j] &lt; in2[k]) out[i]=in1[j++];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>else out[i]=in2[k++]; }}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a4>Обратите внимание, что синтаксис …=<b style='mso-bidi-font-weight:
normal'><a name="m90"><span lang=EN-US style='mso-ansi-language:EN-US'>in</span>1[</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>++] </b>понимается как «взять очередной и переместиться к
следующему».</p>

<p class=a>Похожая картина имеет место в разделении. <b style='mso-bidi-font-weight:
normal'><a name="m91">Разделение -</b> это разбиение последовательности (массива) на две
части по принципу «меньше-больше» относительно некоторого среднего значения,
обычно называемого медианой. Пусть требуется произвести разделение содержимого
массива таким образом, чтобы в левой части выходного оказались значения,
меньшие медианы, а в правой - большего. Это легко можно сделать, заполняя
выходной массив с двух концов. Здесь также потребуется три индекса (на два
массива), причем только во входном он будет перемещаться равномерно.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//----</span>-------------------<span
style='mso-ansi-language:EN-US'> </span>Разделение<span style='mso-ansi-language:
EN-US'> </span>массива<span style='mso-ansi-language:EN-US'> </span>относительно<span
style='mso-ansi-language:EN-US'> </span>медианы<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int two(int in[], int out[], int n, int mid){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int i,j,k;<o:p></o:p></span></p>

<p class=a0><span style='mso-spacerun:yes' lang="EN-US"> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>=0,<span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>=0,<span lang=EN-US style='mso-ansi-language:EN-US'>k</span>=<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>-1; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>; <span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++){ <span
style='mso-tab-count:1'>                  </span>//
<span lang=EN-US style='mso-ansi-language:EN-US'>j</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span> - по концам выходного массива</p>

<p class=a0><span style='mso-spacerun:yes'> </span><span style='mso-tab-count:
1'>           </span><span lang=EN-US style='mso-ansi-language:EN-US'>if
(in[i]&lt;mid) out[j++]=in[i];<span style='mso-spacerun:yes'>      </span><span
style='mso-tab-count:1'>     </span>// Переписать в левую часть<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span>else</span><span
lang=EN-US> </span><span style='mso-tab-count:1'>     </span><span lang=EN-US
style='mso-ansi-language:EN-US'>out</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>--]=<span lang=EN-US style='mso-ansi-language:EN-US'>in</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>];<span
style='mso-spacerun:yes'>                </span><span style='mso-tab-count:
1'>  </span>// Переписать в правую часть</p>

<p class=a0 style='text-indent:36.0pt'>} <span lang=EN-US style='mso-ansi-language:
EN-US'>return</span><span lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>; }<span style='mso-spacerun:yes'>                        </span><span style='mso-tab-count:1'>         </span>//
Вернуть точку разделения</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a4>Еще один маленький нюанс. Индексы <b style='mso-bidi-font-weight:
normal'><a name="m92"><span lang=EN-US style='mso-ansi-language:EN-US'>j</span>,</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>k</span><span lang=EN-US> </span></b>указывают на <b style='mso-bidi-font-weight:
normal'><a name="m93">очередные свободные </b>позиции выходного массива, а синтаксис <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>out</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>j</span>++]=… </b>понимается как «записать
очередным и переместиться к следующему свободному».</p>

<p class=a><b><a name="m94">Результат цикла – место его остановки. </b>Как известно, тело
цикла представляет собой описание повторяющегося процесса, а заголовок –
параметры этого повторения. Можно представить себе «бестелесный<b
style='mso-bidi-font-weight:normal'>» </b>цикл. Тогда возникает резонный
вопрос: зачем он нужен? Ответ: результатом цикла является <b style='mso-bidi-font-weight:
normal'><a name="m95">место его остановки. </b>Оно, в свою очередь, определяется значениями
переменных, которые используются в заголовке цикла. Такие циклы либо вообще не
имеют тела (пустой оператор), либо содержат в теле проверки условий,
сопровождаемых альтернативными выходами через <b style='mso-bidi-font-weight:
normal'><a name="m96"><span lang=EN-US style='mso-ansi-language:EN-US'>break</span></b>.</p>

<p class=a>Характерный пример – вставка в упорядоченную последовательность с
сохранением порядка. Поиск места включения можно организовать по-разному.
Например, очередной элемент сравнивается подряд со всеми из последовательности
слева направо, <b style='mso-bidi-font-weight:normal'><a name="m97">пока не встретит первый<span
style='mso-tab-count:1'>        </span>, больший себя.</b><span
style='mso-spacerun:yes'>  </span>Другое, естественное условие остановки –
конец упорядоченной последовательности. В обоих случаях он должен
останавливаться на элементе, на место которого будет произведено включение. </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//-----------------------------Вставка с сохранением порядка</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void ins_sort(int A[],
int &amp;n, int v){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int j,k;<span
style='mso-spacerun:yes'>                     </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>=0; <span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span> &amp;&amp; <span lang=EN-US style='mso-ansi-language:EN-US'>v</span>&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>]; <span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>++)<b style='mso-bidi-font-weight:normal'><a name="m98">;</b><span
style='mso-tab-count:2'>                </span>// Цикл (пустой) останавливается
на месте включения</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>=n-1; <span lang=EN-US
style='mso-ansi-language:EN-US'>j</span>&gt;=<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>; <span lang=EN-US style='mso-ansi-language:EN-US'>j</span>--) <span
lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>j</span>+1]=<span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>j</span>];<span
style='mso-tab-count:1'>               </span>//
Вставка на позицию <span lang=EN-US style='mso-ansi-language:EN-US'>k</span> –
сдвиг влево</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>]=<span lang=EN-US
style='mso-ansi-language:EN-US'>v</span>;<span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>n</span>++;}</p>

<p class=a><b><a name="m99">Вложенные циклы и принцип относительности.</b> Наличие в
программе линейных независимых перемещений - не единственный случай. Часто эти
перемещения по массивам и последовательностям имеют возвратно-поступательный,
циклический или какой-нибудь другой сложный геометрический характер. Но такое
движение также раскладывается на линейные составляющие, другое дело, что в
процессе выполнения программы они, как минимум, складываются или вычитаются. В
этом случае образной модели помогает принцип относительности. Заключается он в
том, что при анализе процесса, проходящего во внутреннем цикле, внешний можно
считать «условно неподвижным». При этом нужно отказаться от попытки
«исторически» отследить выполнение программы с первого шага внешнего цикла, а считать
внутренний цикл выполняющимся в некотором его произвольном шаге.</p>

<span style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";mso-ansi-language:RU;mso-fareast-language:
RU;mso-bidi-language:AR-SA'><br clear=all style='page-break-before:always'>
</span>

<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p>
<img border="0" src="Images/024-06.png" width="300" height="317" align="right"></o:p></span><p class=a0><span
lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------24-03.cpp</span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//--- </span>Поиск<span
style='mso-ansi-language:EN-US'> </span>подстроки<span style='mso-ansi-language:
EN-US'> </span>в<span style='mso-ansi-language:EN-US'> </span>строке<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int search(char
c1[],char c2[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for ( int i=0;
c1[i] !='\0'; i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>for ( int j=0; c2[j] !='\0'; j++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span><span
style='mso-spacerun:yes'>   </span>if (c1[i+j] != c2[j]) break;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span>if (c2[j] =='\0') return i;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'> 
</span></span>} </p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>return -1;}</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int search2(char
c1[],char c2[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int i=0,j=0;
c1[i]!='\0'; i++,j++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (c2[j]==0) return i-j;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (c1[i]!=c2[j]) { i=i-j; j=-1; }<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>} </p>

<p class=a0>return -1;}</p>

<p class=a4><o:p>&nbsp;</o:p></p>

<p class=a>&nbsp;</p>
<p class=a>Анализ программы необходимо начать с внутреннего цикла, содержащего
суммируемый индекс <b style='mso-bidi-font-weight:normal'><a name="m100"><span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>+</b><b style='mso-bidi-font-weight:
normal'><a name="m101"><span lang=EN-US style='mso-ansi-language:EN-US'>j</span>. </b>Для его
восприятия необходимо зафиксировать внешний цикл, то есть производить
рассуждения, исходя из анализа тела внешнего цикла для произвольного <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>-го </b>символа. Тогда <b style='mso-bidi-font-weight:normal'><a name="m102"><span
lang=EN-US style='mso-ansi-language:EN-US'>c</span>1[</b><b style='mso-bidi-font-weight:
normal'><a name="m103"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>+</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>] </b>следует понимать как <b style='mso-bidi-font-weight:normal'><a name="m104"><span
lang=EN-US style='mso-ansi-language:EN-US'>j</span>-ый </b>символ относительно
текущего, на котором находится внешний цикл. Отсюда мы видим параллельное
движение с попарным сравнением символов по двум строкам, но вторая
рассматривается от начала, а первая, от <b style='mso-bidi-font-weight:normal'><a name="m105"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>-го </b>символа. Теперь,
определив характер процесса, можно анализировать условия его завершения.
Процесс попарного сравнения продолжается, пока не закончится вторая строка, и
пока фрагмент первой строки совпадает со второй (совпадение очередной пары
продолжает цикл). И, наконец то, что цикл завершился по концу второй строки,
свидетельствует о том, что вторая строка содержится в первой, начиная с <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>-го </b>символа. Обнаружение этого условия приводит<span
style='mso-spacerun:yes'>  </span>к тому, что функция завершается и возвращает
этот индекс в качестве результата.</p>

<p class=a>Анализ внешнего цикла тривиален. Он просто выполняет описанное выше
действие для каждого начального символа первой строки. Таким образом, функция
находит первое вхождение подстроки в строке.</p>

<p class=a>Второй вариант лишен всех этих сложностей, в нем индексы <b
style='mso-bidi-font-weight:normal'><span style='mso-spacerun:yes'> </span></b>совершают
сложное возвратно-поступательное движение в рамках одного цикла. Аналогично,
происходит попарное сравнение <b style='mso-bidi-font-weight:normal'><a name="m106"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>-го </b>и <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>-го </b>символов в строках. При их совпадении оба индекса
продвигаются вперед, пока не будет обнаружен конец второй строки. При
несовпадении второй индекс явно возвращается в начало, а первый – на <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>-1 </b>назад (<b style='mso-bidi-font-weight:normal'><a name="m107"><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=</b><b style='mso-bidi-font-weight:
normal'><a name="m108"><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>-</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>j</span>; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++</b> в заголовке цикла). Это
соответствует переход к попарному сравнению в первой строке на один символ
вперед. Основным недостатком этого варианта является отсутствие
структурированности – он не раскладывается на независимые циклы.</p>

<h3><b><a name="m109"><span style='mso-spacerun:yes'> </span></b>Свойства всеобщности и
существования<b><a name="m110"><o:p></o:p></b></h3>

<p class=a3 align=right style='margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:5.0cm;margin-bottom:.0001pt;text-align:right'>«Ваше кредо?
Всегда». </p>

<p class=a3 align=right style='margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:5.0cm;margin-bottom:.0001pt;text-align:right'><b
style='mso-bidi-font-weight:normal'>Ильф и Петров. «Двенадцать стульев».<o:p></o:p></b></p>

<p class=a3 align=right style='margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:5.0cm;margin-bottom:.0001pt;text-align:right'><span
style='mso-spacerun:yes'> </span>Из высказываний О.Бендера<b style='mso-bidi-font-weight:
normal'><a name="m111"><span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></b></p>

<p class=a>Проверка свойств «для всех» и «существует» довольно часто
производится программами и заслуживает отдельного рассмотрения. В
математической логике для этого существуют кванторы всеобщности (<b
style='mso-bidi-font-weight:normal'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol; font-family:Symbol; mso-ascii-font-family:Times New Roman CYR; mso-hansi-font-family:Times New Roman CYR'>&quot;</span></b>) и существования (<b
style='mso-bidi-font-weight:normal'><span style='mso-char-type:symbol;
mso-symbol-font-family:Symbol; font-family:Symbol; mso-ascii-font-family:Times New Roman CYR; mso-hansi-font-family:Times New Roman CYR'>$</span></b>). На самом деле они просто
являются сокращенным обозначением логических операций И (одновременности все) и
ИЛИ (хотя бы одно) над результатами проверки какого-либо условия над всеми
элементами множества.</p>

<p class=a5><span style='mso-ansi-language:RU;font-weight:normal'><o:p>&nbsp;</o:p></span></p>

<p class=a5><span lang=EN-US>A={ A<sub>1</sub>, A<sub>2</sub>,…,A<sub>n</sub>}</span></p>

<p class=a5>
<span style='mso-char-type:symbol;mso-symbol-font-family:
Symbol; font-family:Symbol; mso-ascii-font-family:Courier New; mso-hansi-font-family:Courier New' lang="EN-US">&quot;</span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A)= </span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A<sub>1</sub>)&amp; </span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A<sub>2</sub>)&amp; … &amp; </span><span style='mso-ansi-language:
RU'>усл</span><span lang=EN-US>(A<sub>n</sub>)</span></p>

<p class=a5>
<span style='mso-char-type:
symbol;mso-symbol-font-family:Symbol; font-family:Symbol; mso-ascii-font-family:Courier New; mso-hansi-font-family:Courier New; font-weight:normal' lang="EN-US">$</span><span style='mso-ansi-language:
RU'>усл</span><span lang=EN-US>(A)= </span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A<sub>1</sub>)| </span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A<sub>2</sub>)| … </span><span style='mso-ansi-language:RU'>| усл(</span><span
lang=EN-US>A<sub>n</sub></span><span style='mso-ansi-language:RU'>)<o:p></o:p></span></p>

<p class=a>Математические определения дают формальный способ проверки этих
свойств – одномоментное вычисление всех условий и выполнение логической
операции. В программе этому соответствует цикл последовательной проверки,
логика которого может включать такие контексты как счетчик, признак, место
остановки цикла.</p>

<p class=a>В самом простом случае можно подсчитать число элементов,
удовлетворяющих условию. По его значению можно судить о выполнении указанных
свойств.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//-------------- Проверка свойств «для всех» и «существует» при
помощи счетчика</p>

<p class=a0>int i,s=0;<span style='mso-tab-count:2'>                       </span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0;i&lt;n;i++)
if (A[i]&lt;0) s++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (s==0) «</span><b
style='mso-bidi-font-weight:normal'>все<span
lang=EN-US style='mso-ansi-language:EN-US'> &gt;=0</span></b><span lang=EN-US
style='mso-ansi-language:EN-US'>»<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>==<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>) «<b style='mso-bidi-font-weight:normal'><a name="m112">все
&lt;0</b>»</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>!=<span lang=EN-US
style='mso-ansi-language:EN-US'>0</span>)<span style='mso-ansi-language:EN-US'>
</span>«<b style='mso-bidi-font-weight:normal'><a name="m113">существуют &lt;0</b>»<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>!=<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>) «<b style='mso-bidi-font-weight:normal'><a name="m114">существуют
&gt;=0</b>»</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>На самом деле не всегда нужно выполнять проверку до конца. Если на
очередном шаге проверяемое условие не выполняется, то это означает нарушение
свойства «для всех», и дальнейшая проверка теряет смысл. Этот факт можно
зафиксировать отдельным признаком.</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//--------------- Проверка свойств «для всех» и «существует» с
помощью признака</p>

<p class=a0>int i,s=1;<span style='mso-tab-count:2'>                       </span>//
признак «оптимистически» установлен в значение «для всех»</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0;i&lt;n;i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]&lt;0) <span style='mso-tab-count:1'>          </span>// условие
всеобщности нарушается</p>

<p class=a0 style='margin-left:36.0pt'>{<span lang=EN-US style='mso-ansi-language:
EN-US'>s</span>=0; <span lang=EN-US style='mso-ansi-language:EN-US'>break</span>;
} <span style='mso-tab-count:1'>    </span>// сбросить признак и выйти</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (s==1) «</span><b
style='mso-bidi-font-weight:normal'>все<span
lang=EN-US style='mso-ansi-language:EN-US'> &gt;0</span></b><span lang=EN-US
style='mso-ansi-language:EN-US'>»</span></p>

<p class=a0>else «существуют <b style='mso-bidi-font-weight:normal'><a name="m115">&lt;=0</b>»</p>

<p class=a>Если же условие выполняется для очередного элемента, то на самом
деле ничего конкретного сказать пока нельзя, нужно продолжать проверку до конца.
И только по естественному завершению цикла и сохранении установленного признака
можно утверждать, что условие всеобщности выполняется.</p>

<p class=a>И,
наконец, можно отказаться от переменной-признака, сохранив логику работы цикла,
и судить о выполнении свойств всеобщности и существования косвенно по месту
остановки цикла – значению переменной цикла. В заголовке цикла записываются два
условия, объединенные по И: ограничение по размерности и проверяемой условие
всеобщности. Если свойство «для всех» выполняется, то цикл дойдет до конца,
иначе завершится на одном из предыдущих шагов цикла. 
<img border="0" src="Images/024-07.png" width="250" height="229" align="right"></p>

<p class=a><o:p>&nbsp;</o:p></p>

<p class=a0>//-------------- Проверка свойств «для всех» и «существует» по
месту остановки цикла</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span> &amp;&amp; <span lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&gt;0;<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++)<b style='mso-bidi-font-weight:normal'><a name="m116">;</b><span
style='mso-tab-count:1'>         </span>// «пустой» цикл с выходом по двум
условиям</p>

<p class=a0>if (<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>==<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>) «<b style='mso-bidi-font-weight:
normal'><a name="m117">все &gt;0</b>»<span style='mso-tab-count:2'>                      </span>//
был выход по окончании последовательности</p>

<p class=a0>else<span style='mso-tab-count:1'>      </span>«<b
style='mso-bidi-font-weight:normal'>существуют &lt;=0</b>»<span
style='mso-tab-count:1'>       </span>// был выход по обнаружению
неположительного</p>

<p class=a><o:p>&nbsp;</o:p></p>

<p class=a>Из формальной логики известно, что свойства всеобщности и
существования взаимосвязаны. Отрицание свойства «для всех» эквивалентно
свойству существования для обратного условия, и наоборот.</p>

<p class=a5><span style='mso-ansi-language:RU'><o:p>&nbsp;</o:p></span></p>

<p class=a5><span style='mso-ansi-language:RU'>!</span><span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol; font-family:Symbol; mso-ascii-font-family:Courier New; mso-hansi-font-family:Courier New' lang="EN-US">&quot;</span><span
style='mso-ansi-language:RU'>усл</span><span lang=EN-US>(A) <span
style='mso-spacerun:yes'> </span></span><span lang=EN-US style='mso-bidi-font-family:
"Times New Roman CYR"'>&#8801;</span><span lang=EN-US> </span>
<span
style='mso-char-type:symbol;mso-symbol-font-family:Symbol; font-family:Symbol; mso-ascii-font-family:Courier New; mso-hansi-font-family:Courier New' lang="EN-US">$</span><span
lang=EN-US>!</span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A)<span style='mso-tab-count:1'>  </span><span style='mso-tab-count:
1'>    </span>!</span><span style='mso-char-type:symbol;mso-symbol-font-family:
Symbol; font-family:Symbol; mso-ascii-font-family:Courier New; mso-hansi-font-family:Courier New' lang="EN-US">$</span><span style='mso-ansi-language:RU'>усл</span><span
lang=EN-US>(A)<span style='mso-spacerun:yes'>  </span></span><span lang=EN-US
style='mso-bidi-font-family:"Times New Roman CYR"'>&#8801;</span><span
lang=EN-US> </span>
<span style='mso-char-type:symbol;mso-symbol-font-family:
Symbol; font-family:Symbol; mso-ascii-font-family:Courier New; mso-hansi-font-family:Courier New' lang="EN-US">&quot;</span><span lang=EN-US>!</span><span style='mso-ansi-language:
RU'>усл</span><span lang=EN-US>(A)</span></p>

<p class=a>Пример. Свойство всеобщности проверяется при проверке, является ли
заданное число простым. Число простое, если оно делится только на 1 и на само
себя. Слово «<b style='mso-bidi-font-weight:normal'><a name="m118">только» </b>означает
исключительное выполнение условия для этих значений, на самом деле
сформулировать это условие нужно иначе: «для всех» чисел <b style='mso-bidi-font-weight:
normal'><a name="m119"><span lang=EN-US style='mso-ansi-language:EN-US'>k</span>=2</b>..<b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>m</span>-1</b> (<b style='mso-bidi-font-weight:normal'><a name="m120"><span lang=EN-US
style='mso-ansi-language:EN-US'>m</span></b> – само число) число <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>m</span><span lang=EN-US> </span></b>не делится на <b style='mso-bidi-font-weight:
normal'><a name="m121">k</b>. Этот факт можно установить путем анализа условий завершения
цикла проверки.</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//-----<span lang=EN-US style='mso-ansi-language:EN-US'>--------------</span>-------------------------------------------------24-04.cpp</p>

<p class=a0>//------- Поиск простых чисел - проверка всех делителей</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void F1(int val,
int A[], int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i,m,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0, m=2;
i&lt;n-1 &amp;&amp; m&lt;val; m++) {<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>for (k=2; k&lt;m &amp;&amp;
m%k!=0; k++);<span style='mso-tab-count:1'>                        </span>// Пустой цикл проверки делимости</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (<b
style='mso-bidi-font-weight:normal'>m==k</b>) A[i++]=m;<span style='mso-tab-count:
3'>                               </span>// Дошли до конца - на все НЕ ДЕЛИТСЯ</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0><span style='mso-spacerun:yes'> </span>A[i] = 0;}<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a>Более эффективный алгоритм не имеет ту же схему: проверяется
свойство «не делится» по отношению ко всем уже накопленным простым числам
(решето Эратосфена). Если в первом случае проверялось, дошло ли проверяемой
значение <b style='mso-bidi-font-weight:normal'><a name="m122"><span lang=EN-US
style='mso-ansi-language:EN-US'>k</span><span lang=EN-US> </span></b>до
проверяемого (<b style='mso-bidi-font-weight:normal'><a name="m123">k==<span lang=EN-US style='mso-ansi-language:
EN-US'>m</span>), </b>то<span style='mso-spacerun:yes'>  </span>во втором
случае – дошел ли индекс <b style='mso-bidi-font-weight:normal'><a name="m124"><span
lang=EN-US style='mso-ansi-language:EN-US'>k</span><span lang=EN-US> </span></b>до
конца последовательности накопленных простых чисел (<b style='mso-bidi-font-weight:
normal'><a name="m125"><span lang=EN-US style='mso-ansi-language:EN-US'>k</span>==</b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>i</span></b>).</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//--------------------------------------------------------------------24-04.cpp</p>

<p class=a0>//------- Поиск простых чисел - проверка деления на накопленные
простые</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void F2(int val,
int A[], int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int i,m,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0, m=2;
i&lt;n-1 &amp;&amp; m&lt;val; m++) {<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>for (k=0; k&lt;i &amp;&amp;
m%A[k]!=0; k++);<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (<b style='mso-bidi-font-weight:
normal'><a name="m126">k==i</b>) A[i++]=m;<span style='mso-tab-count:3'>                                 </span>//
Цикл дошел до конца массива простых - </p>

<p class=a0><span style='mso-tab-count:1'>            </span>}<span
style='mso-tab-count:5'>                                                           </span>//
на все НЕ ДЕЛИТСЯ</p>

<p class=a0><span style='mso-spacerun:yes'> </span>A[i] = 0;}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Все приведенные варианты отдают дань структурному программированию (<b
style='mso-bidi-font-weight:normal'>3.3</b>). Мы сначала проверяем свойство, а
в обоих случаях <b style='mso-bidi-font-weight:normal'><a name="m127">только потом </b><span
style='mso-spacerun:yes'> </span>выполняем связанные с ними действия, т.е. во
главу угла ставим <b style='mso-bidi-font-weight:normal'><a name="m128">последовательность: </b><span
style='mso-spacerun:yes'>  </span>проверка – реакция на результат. Можно слить
все воедино, но тогда не обойтись без <b style='mso-bidi-font-weight:normal'><a name="m129">go<span lang=EN-US style='mso-ansi-language:
EN-US'>t</span>o</b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----- Неструктурированный вариант проверки свойства «для всех»</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>;<span
style='mso-tab-count:2'>                  </span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0;<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>&lt;<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>;<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++)</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]&lt;0)
{ что-то делать с отрицательным… goto M; } </p>

<p class=a0>что-то делать, когда все положительны</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>M</span>: общее
продолжение…</p>

<p class=a>При проверке свойства «для всех» можно обойтись и без <b
style='mso-bidi-font-weight:normal'>goto</b>. Если вынести в заголовок цикла
проверку самого условия, а проверку конца последовательности делать в<span
style='mso-spacerun:yes'>  </span>теле цикла, то действие при обнаружении
свойства «для всех» можно запихнуть туда же. </p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----- Неструктурированный вариант проверки свойства «для всех»
без <span lang=EN-US style='mso-ansi-language:EN-US'>goto</span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>k</span>=2;</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>while</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>m</span>%2!=0){<span
style='mso-tab-count:3'>                          </span><span
style='mso-tab-count:1'>            </span>// пока нет делителей для n</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>k</span>++;</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>k</span>==<span lang=EN-US style='mso-ansi-language:EN-US'>m</span>){<span
style='mso-tab-count:3'>                                  </span>// просмотр
закончен – число простое</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>{ <span
lang=EN-US style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++]=<span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>;<span style='mso-spacerun:yes'>  </span><span lang=EN-US
style='mso-ansi-language:EN-US'>break</span>; } <span style='mso-tab-count:
1'>      </span>// сохранить простое и выйти</p>

<p class=a0 style='text-indent:36.0pt'>} </p>

<h3>Другие стандартные контексты </h3>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m130">Поиск – полный перебор. </b>Любой
алгоритм воспроизводит интеллект его разработчика. Алгоритмы поиска – не
исключение. Но не стоит забывать, что самым простым поисковым алгоритмом
является полный перебор всех возможных вариантов. Конечно алгоритмы целенаправленного
движения к результату являются более эффективными, но они требуют больших
затрат на проработку и, главное, доказательство того, что они действительно
находят нужный вариант. Поэтому если полный перебор устраивает нас по
быстродействию, можно ограничиться им. В разных задачах имеют место различные
множества допустимых вариантов и различные способы их перебора:</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>простой линейный перебор последовательности
элементов или значений какой-либо переменной;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>перебор возможных пар элементов (<b
style='mso-bidi-font-weight:normal'>4.6</b>);</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>рекурсивный комбинаторный перебор подмножеств,
сочетаний и т.п. (<b style='mso-bidi-font-weight:normal'><a name="m131">7.4</b>).</p>

<p class=a>Простейший пример, поиск наименьшего общего кратного: цикл просто
перебирает значения переменной в порядке возрастания, пока не получит
одновременного деления на два заданных числа.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>i<span lang=EN-US style='mso-ansi-language:EN-US'>nt</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>i</span>,<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>1,<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>2;<span style='mso-tab-count:1'>                                 </span>//
Первое деление <span style='mso-spacerun:yes'> </span>- общее кратное</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>i=n1;<span
style='mso-spacerun:yes'>  </span>while (1) if (i%n1==0 &amp;&amp; i%n2==0) break;<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a><b><a name="m132"><span style='font-family:"Times New Roman"'>Первый,<span
style='mso-spacerun:yes'>  </span>последний, максимальный, минимальный из
возможных. </span></b><span style='font-family:"Times New Roman";mso-bidi-font-weight:
bold'>В процессе полного перебора возможно </span>несколько логических схем сохранения
результата:</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>если программа перебирает множество и прерывает
цикл просмотра при обнаружении элемента, удовлетворяющего условию, то она
находит <b style='mso-bidi-font-weight:normal'><a name="m133">первый из возможных;<o:p></o:p></b></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>если программа запоминает элемент,
удовлетворяющий условию (его значение, индекс, адрес), то по окончании цикла
просмотра она обнаружит <b style='mso-bidi-font-weight:normal'><a name="m134">последний из
возможных;<o:p></o:p></b></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>для поиска<span style='mso-spacerun:yes'> 
</span>элемента с <b style='mso-bidi-font-weight:normal'><a name="m135">максимальным или
минимальным</b> значением необходимо перебрать все множество с использованием
соответствующего контекста;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>если программа просматривает множество в порядке
возрастания значений и прерывает цикл просмотра при обнаружении элемента,
удовлетворяющего условию, то она находит <b style='mso-bidi-font-weight:normal'><a name="m136">минимальный
из возможных;<o:p></o:p></b></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>тот же самый процесс в порядке убывания приводит
к обнаружению<b style='mso-bidi-font-weight:normal'><a name="m137"> максимального из
возможных.<o:p></o:p></b></p>

<p class=a4>Для сравнения приведем варианты поиска первого, последнего и
минимального положительного элемента в массиве.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int A[20]={...};</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>int i,k;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (k=-1,i=0; i&lt;20;
i++){<span style='mso-tab-count:2'>              </span>// </span>Первый<span
style='mso-ansi-language:EN-US'> </span>положительный<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (A[i]&lt;0) continue;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>k=i; break; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>=-1,<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>=0; <span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>&lt;20; <span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++){<span
style='mso-tab-count:2'>              </span>// Последний положительный</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (A[i]&lt;0) continue;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>k=i; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>k</span>=-1,<span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>=0; <span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>&lt;20; <span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++){<span
style='mso-tab-count:2'>              </span>// Минимальный положительный</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (A[i]&lt;0) continue;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (k==-1 || A[i] &lt; A[k]) k=i; </span>}<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a4>Оценить влияние направления поиска можно в примерах, находящий <b
style='mso-bidi-font-weight:normal'>наибольший </b>общий делитель<b
style='mso-bidi-font-weight:normal'> </b>(в процессе убывания)<b
style='mso-bidi-font-weight:normal'> </b>и <b style='mso-bidi-font-weight:normal'><a name="m138">наименьшее
</b>общее кратное (в процессе возрастания).</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>i<span lang=EN-US style='mso-ansi-language:EN-US'>nt i,n1,n2;<span
style='mso-spacerun:yes'>  </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>1-1; !(<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>1 % <span lang=EN-US style='mso-ansi-language:
EN-US'>i</span> ==0 &amp;&amp; <span lang=EN-US style='mso-ansi-language:EN-US'>n</span>2
% <span lang=EN-US style='mso-ansi-language:EN-US'>i</span> ==0); <span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>--);<span style='mso-tab-count:
2'>                    </span>// Первый общий делитель - наибольший</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>1; !(<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span> % <span lang=EN-US style='mso-ansi-language:EN-US'>n</span>1
==0 &amp;&amp; <span lang=EN-US style='mso-ansi-language:EN-US'>i</span> % <span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>2 ==0); <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>++);<span style='mso-tab-count:2'>                    </span>//
Первое общее кратное - наименьшее</p>

<p class=a><b><a name="m139">Житейский смысл логических операций. </b>Безусловно, нет нужды
повторять определение логических операций <b style='mso-bidi-font-weight:normal'><a name="m140">И,
ИЛИ, НЕ, </b>используемых в любом языке программирования. Уместно напомнить как
«переводятся» эти операции на естественный язык при чтении программ:<b><a name="m141"><o:p></o:p></b></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>содержательный смысл логической операции <b
style='mso-bidi-font-weight:normal'>И </b>передается фразой &quot;<b
style='mso-bidi-font-weight:normal'>одновременно оба...</b>&quot; и заключается
в совпадении условий;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>содержательный смысл логической операции <b
style='mso-bidi-font-weight:normal'>ИЛИ </b>передается фразой &quot;<b
style='mso-bidi-font-weight:normal'>хотя бы один...</b>&quot; и заключается в
объединении условий;</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>содержательный смысл логической операции <b
style='mso-bidi-font-weight:normal'>НЕ </b>передается фразой &quot;<b
style='mso-bidi-font-weight:normal'>хотя бы один...</b>&quot; и заключается в
проверке обратного условия.</p>

<p class=a4>Несколько замечаний можно сделать относительно эквивалентных
преобразований логических выражений, часто используемых в программах.</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>все условия, записанные в заголовках циклов Си-программ,
являются условиями <b style='mso-bidi-font-weight:normal'><a name="m142">продолжения цикла. </b>Если
программисту удобнее сформулировать условие завершения, то в заголовке цикла
его нужно записать, предварив операцией логической инверсии.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Цикл завершается при обнаружении пары &quot;меньше 0 - больше
0&quot; </p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=1; i&lt;20
&amp;&amp; !(A[i-1]&lt;0 &amp;&amp; A[i]&gt;0); i++);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span><o:p></o:p></span></p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>оператор прерывания цикла <b style='mso-bidi-font-weight:
normal'><a name="m143"><span lang=EN-US style='mso-ansi-language:EN-US'>break</span><span
lang=EN-US> </span></b>по условию, размещенный в начале тела цикла, может быть
вынесен в заголовок цикла в виде инвертированного условия продолжения цикла,
объединенного с имеющимся ранее по <b style='mso-bidi-font-weight:normal'><a name="m144">И;<o:p></o:p></b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (int i=0;
i&lt;20; i++){<span style='mso-tab-count:3'>                             </span>//
</span>До<span style='mso-ansi-language:EN-US'> </span>конца<span
style='mso-ansi-language:EN-US'> </span>массива<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]&lt;0) <span lang=EN-US style='mso-ansi-language:EN-US'>break</span>;<span
style='mso-tab-count:3'>                         </span>// Отрицательный -
выход</p>

<p class=a0 style='text-indent:36.0pt'>...}</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=0; <span lang=EN-US
style='mso-ansi-language:EN-US'>i</span>&lt;20 &amp;&amp; <span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>]=&gt;0){<span style='mso-tab-count:1'>                  </span>// Пока не кончился массив</p>

<p class=a0><span style='mso-tab-count:1'>            </span>...}<span
style='mso-tab-count:4'>                                            </span>// <b
style='mso-bidi-font-weight:normal'>И </b>элемент неотрицательный</p>

<p class=a1><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>инверсия условий, объединенных по <b
style='mso-bidi-font-weight:normal'>И, </b>раскрывается как объединение по <b
style='mso-bidi-font-weight:normal'>ИЛИ </b>обратных условий и наоборот.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Цикл прекращается, когда одновременно оба равны 0</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for</span> (<span
lang=EN-US style='mso-ansi-language:EN-US'>i</span>=1; !(<span lang=EN-US
style='mso-ansi-language:EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:
EN-US'>i</span>-1]==0 &amp;&amp; <span lang=EN-US style='mso-ansi-language:
EN-US'>A</span>[<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>]==0);
<span lang=EN-US style='mso-ansi-language:EN-US'>i</span>++)...</p>

<p class=a0>// Цикл продолжается, пока хотя бы один не равен 0</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=1;
A[i-1]!=0 || A[i]!=0; i++)...<o:p></o:p></span></p>

<p class=a><b><a name="m145"><span style='font-family:"Times New Roman"'>Стандартные контексты
в других областях программирования. </span></b><span style='font-family:"Times New Roman";
mso-bidi-font-weight:bold'>Каждая область программирования имеет свои контексты,
интерпретации и наработанные приемы. Например, при решении арифметических задач
остаток от деления на 10 интерпретируется как младшая десятичная цифра числа, а
последовательность остатков в цикле деления исходного числа на 10 дает нам
цифры числа в обратном порядке (<b><a name="m146">4.2</b>).<o:p></o:p></span></p>

</div>

</body>

</html>
