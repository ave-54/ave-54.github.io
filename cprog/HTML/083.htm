<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="083.files/editdata.mso">
<title>Романов Е.Л. Беседы о программировании</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>www.PHILka.RU</o:Author>
  <o:Template>Книга(шаблон).dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>301</o:TotalTime>
  <o:Created>2008-02-14T11:36:00Z</o:Created>
  <o:LastSaved>2008-02-14T11:36:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>3364</o:Words>
  <o:Characters>19180</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>159</o:Lines>
  <o:Paragraphs>44</o:Paragraphs>
  <o:CharactersWithSpaces>22500</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:AttachedTemplate HRef="C:\ForAll\Book2008\Книга(шаблон).dot"></w:AttachedTemplate>
  <w:DoNotHyphenateCaps/>
  <w:DrawingGridHorizontalSpacing>0,55 пт</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>0,55 пт</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DrawingGridVerticalOrigin>99,25 пт</w:DrawingGridVerticalOrigin>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial Narrow";
	panose-1:2 11 5 6 2 2 2 3 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.a, li.a, div.a
	{mso-style-name:текст;
	mso-style-link:"текст Знак";
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{mso-style-name:стихи;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.1, li.1, div.1
	{mso-style-name:эпиграф1;
	mso-style-parent:эпиграф;
	margin-top:0cm;
	margin-right:9.35pt;
	margin-bottom:0cm;
	margin-left:9.0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
span.a8
	{mso-style-name:"текст Знак";
	mso-style-locked:yes;
	mso-style-link:текст;
	mso-ansi-font-size:12.0pt;
	font-family:"Times New Roman CYR";
	mso-ascii-font-family:"Times New Roman CYR";
	mso-hansi-font-family:"Times New Roman CYR";
	mso-ansi-language:RU;
	mso-fareast-language:RU;
	mso-bidi-language:AR-SA;}
 /* Page Definitions */
 @page
	{mso-mirror-margins:yes;
	mso-footnote-separator:url("083.files/header.htm") fs;
	mso-footnote-continuation-separator:url("083.files/header.htm") fcs;
	mso-endnote-separator:url("083.files/header.htm") es;
	mso-endnote-continuation-separator:url("083.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.5pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-header:url("083.files/header.htm") h1;
	mso-even-footer:url("083.files/header.htm") ef1;
	mso-footer:url("083.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Сетка таблицы";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
  <o:regrouptable v:ext="edit">
   <o:entry new="1" old="0"/>
   <o:entry new="2" old="1"/>
   <o:entry new="3" old="0"/>
   <o:entry new="4" old="0"/>
   <o:entry new="5" old="0"/>
   <o:entry new="6" old="0"/>
   <o:entry new="7" old="0"/>
   <o:entry new="8" old="0"/>
   <o:entry new="9" old="0"/>
   <o:entry new="10" old="0"/>
   <o:entry new="11" old="0"/>
   <o:entry new="12" old="0"/>
  </o:regrouptable>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2><font face="Arial">8.3.<span style='mso-ansi-language:EN-US'> </span>Линейные структуры данных
на деревьях</font></h2>

<p class=a>Существуют задачи, где древовидные структуры являются элементом
внешнего представления, например, древовидная организация папок и файлов, документов,
объектов и т.п.. Любая свободно развивающаяся иерархическая система с
произвольным количеством уровней – и есть дерево. Мы будем рассматривать задачи
другого типа, где древовидная структура скрыта от внешнего пользователя, а
является технологическим приемом, обеспечивающим эффективное решение задачи.</p>

<p class=a>То есть пользователь дерева не видит и воспринимает структуру
данных, как будто она имеет обычную линейную природу, в виде
последовательности, каждый элемент которой имеет в ней собственный логический
(порядковый) номер. И здесь возникает вопрос: а каким образом нумеруются
вершины дерева и, следовательно, хранимые в них данные? Для этого
устанавливается способ или <b style='mso-bidi-font-weight:normal'><a name="m1">алгоритм
обхода. </b><span style='mso-spacerun:yes'> </span>Обычно он бывает
рекурсивным, как и само дерево. В<span lang=EN-US style='mso-ansi-language:
EN-US'>о</span>т несколько примеров: </p>

<p class=a1>- рекурсивная нумерация «сверху вниз»: рекурсивный алгоритм сначала
нумерует текущую вершину, а затем рекурсивно вершины в поддеревьях;</p>

<p class=a1>- рекурсивная нумерация «снизу вверх»: алгоритм сначала рекурсивно
нумерует вершины в поддеревьях, а затем текущую вершину;</p>

<p class=a1>- рекурсивная нумерация «справа налево» в дереве с двумя потомками
и единственным значением в вершине. В нем обход производится в
последовательности «левое поддерево, текущая вершина, правое поддерево»;</p>

<p class=a1>- при использовании вместо стека очереди вершин можно произвести
обход и, соответственно, нумерацию вершин «по горизонтали». </p>

<p class=a>Алгоритм нумерации <b style='mso-bidi-font-weight:normal'><a name="m2">линеаризует</b>
дерево, и создает внешнее представление о нем, как о линейной последовательности
данных. Соответственно, все остальные алгоритмы должны работать по правилам
этой «иллюзии». <span style='mso-bidi-font-weight:bold'>В информационных
технологиях для этого используется термин <b><a name="m3">логическое, </b>в отличие от
реального или <b><a name="m4">физического.</b> Иначе говоря, дерево – это физическое
представление данных, а его линеаризация – его логическое представление в виде
последовательности.</span></p>

<p class=a>Деревья обладают еще одним важным свойством. В массиве и списке одну
и ту же последовательность значений можно разместить одним единственным
способом. Но можно построить множество деревьев, в которых при общем правиле
обхода будет содержаться одна и та же последовательность. Опять же, выражаясь
терминологически точно, одному логическому представлению может соответствовать
множество физических, как это видно на рисунке.</p>

<p class=a4 style="text-align: center"><o:p>
<img border="0" src="Images/083-01.gif" width="554" height="272"></o:p></p>

<p class=a4 align=center style='text-align:center'><b><a name="m5">рис. <span
lang=EN-US style='mso-ansi-language:EN-US'>8</span>3.1. Деревья с обходом «сверху-вниз»<o:p></o:p></b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Функция обхода дерева «сверху-вниз» имеет три параметра: указатель
на текущую вершину, текущий уровень (глубина) дерева и логический номер,
передаваемый по ссылке. В данном случае по ссылке передается параметр, который
являются общим для всех вершин дерева в целом.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----------------------------------------------------------------------------------------------------------------83-02.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>// Полный рекурсивный обход дерева</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>s</span>truct <span
lang=EN-US style='mso-ansi-language:EN-US'>tree{<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int val;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>tree *l,*r;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>};<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void scan(tree *p,
int level, int &amp;ln){<span style='mso-tab-count:2'>                      </span>//
level<span style='mso-spacerun:yes'>  </span>– </span>уровень<span
style='mso-ansi-language:EN-US'> </span>вершины<span lang=EN-US
style='mso-ansi-language:EN-US'> (</span>длина<span style='mso-ansi-language:
EN-US'> </span>ветви<span lang=EN-US style='mso-ansi-language:EN-US'>)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if</span> (<span lang=EN-US
style='mso-ansi-language:EN-US'>p</span>==<span lang=EN-US style='mso-ansi-language:
EN-US'>NULL</span>) <span lang=EN-US style='mso-ansi-language:EN-US'>return</span>;<span
style='mso-tab-count:3'>                                </span>// <span
lang=EN-US style='mso-ansi-language:EN-US'>ln</span><span style='mso-tab-count:
1'>       </span>- общий счетчик логических номеров</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>printf</span>(&quot;%<span lang=EN-US
style='mso-ansi-language:EN-US'>d</span> %<span lang=EN-US style='mso-ansi-language:
EN-US'>d</span> %<span lang=EN-US style='mso-ansi-language:EN-US'>d</span>\<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>&quot;, <span lang=EN-US
style='mso-ansi-language:EN-US'>ln</span>, <span lang=EN-US style='mso-ansi-language:
EN-US'>level</span>, <span lang=EN-US style='mso-ansi-language:EN-US'>p</span>-&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>val</span>);<span style='mso-tab-count:
1'>     </span>// Сначала – вывод текущей вершины</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>ln++;</span><span style='mso-tab-count:5'>                                                     </span><span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>scan</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>p</span>-&gt;<span lang=EN-US style='mso-ansi-language:
EN-US'>l</span>, <span lang=EN-US style='mso-ansi-language:EN-US'>level</span>+1,<span
lang=EN-US style='mso-ansi-language:EN-US'>ln</span>);<span style='mso-tab-count:
3'>                             </span>// Затем рекурсивный обход потомков</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>scan(p-&gt;r, level+1,ln); }<o:p></o:p></span></p>

<h3><font face="Arial">Дерево с данными в концевых вершинах</font></h3>

<p class=a>Для начала разберем простой, не очень эффективный вариант. Пусть это
будет «учебное» дерево, на котором мы обсудим все проблемы, касающиеся реальных
деревьев. Итак, каждая вершина дерева имеет <b style='mso-bidi-font-weight:
normal'><a name="m6">двух потомков</b> – <b style='mso-bidi-font-weight:normal'><a name="m7">левого (<span lang=EN-US style='mso-ansi-language:
EN-US'>left</span>) и правого (<span
lang=EN-US style='mso-ansi-language:EN-US'>right</span>). </b>Данные хранятся
только в концевых вершинах, промежуточные вершины их не содержат.<span
style='mso-bidi-font-weight:bold'> На каждом следующем уровне число вершин
удваивается, т.е. на уровне <b><a name="m8">n </b>оно равно <b><a name="m9">2</b></span><b><a name="m10"><sup><span
style='font-size:14.0pt'>n</span></sup></b><span style='font-size:14.0pt;
mso-bidi-font-weight:bold'>. </span><span style='mso-bidi-font-size:12.0pt;
mso-bidi-font-weight:bold'>На всех предыдущих уровнях будет <b><a name="m11">1+2+4+…+2</b></span><b><a name="m12"><sup><span
style='font-size:14.0pt'>n-1 </span></sup><span style='mso-bidi-font-size:
12.0pt'>= 2</span><sup><span lang=EN-US style='font-size:14.0pt;
mso-ansi-language:EN-US'>n</span></sup><span style='mso-bidi-font-size:
12.0pt'>-1</span></b><span style='mso-bidi-font-size:12.0pt;mso-bidi-font-weight:
bold'>, т.е. на 1 меньше. Таким образом, получается эффективность </span><span
lang=EN-US style='mso-bidi-font-size:12.0pt;mso-ansi-language:EN-US;mso-bidi-font-weight:
bold'>около </span><span style='mso-bidi-font-size:12.0pt;mso-bidi-font-weight:
bold'>50%.<o:p></o:p></span></p>

<p class=a>Это видно на приведенном рисунке: 6 промежуточных и 7 оконечных
вершин. В таком дереве упрощаются процедуры нумерации (задания логических
номеров вершин), вставки и удаления. Именно ради простоты алгоритма вставки мы
идем на такие расходы. Заметим, что при вставке по заданному логическому номеру
требуется сначала найти вершину с таким номером. Сама вставка (замещение)
состоит в превращении найденной вершины в промежуточную, новое значение
включается левым потомком, а значение текущей вершины переносится в правого
потомка.</p>

<p class=a>Все это напоминает вставку в список в том смысле, что большинство
элементов остается на своих местах, а новые включаются за счет переустановки
связей. Но список растет «в длину», линейно, а дерево – «в глубину», за счет
ветвления.</p>

<p class=a4 style="text-align: center"><o:p>
<img border="0" src="Images/083-02.gif" width="436" height="288"></o:p></p>

<p class=a4 align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m13">рис. </b><b style='mso-bidi-font-weight:normal'><a name="m14"><span lang=EN-US
style='mso-ansi-language:EN-US'>8</span>3.2. Дерево с данными в концевых
вершинах<o:p></o:p></b></p>

<p class=a>Есть еще одно свойство. Как любят говорить студенты, «интуитивно
ясно», что у промежуточных вершин будут всегда два потомка, если учитывать
предложенный способ вставки. Еще проще будет добавление последним. Нужно найти
самую правую концевую вершину и сделать вставку «после»: превратить ее в
промежуточную, текущее значение передать левому потомку, а новое – правому.</p>

<p class=a4>Для поиска вершины с заданным логическим номером можно применить
тот же рекурсивный обход. Но будет все тот же линейный поиск. Более эффективный
алгоритм, основанный на ветвлении, <span style='mso-bidi-font-weight:bold'>можно
реализовать, если в каждую вершину добавить счетчик значений, хранимых в
поддереве (иначе говоря, счетчик концевых вершин). Чтобы значения счетчиков
были корректны, их нужно «накручивать» по всему пройденному пути при вставке и
добавлении и «скручивать» при удалении.<o:p></o:p></span></p>

<p class=a4><span
style='mso-bidi-font-weight:bold'>
<img border="0" src="Images/083-03.gif" width="241" height="108" align="left">Потомок выбирается просто: если логический
номер меньше количества значений в левом поддереве <b><a name="m15">n</b></span><b><a name="m16"><span
lang=EN-US style='mso-ansi-language:EN-US'>l</span></b><span style='mso-bidi-font-weight:
bold'>, то уходим туда с тем же самым номером, иначе выбираем правое поддерево,
нологический номер уменьшаем на это самое значение </span><b><a name="m17"><span lang=EN-US
style='mso-ansi-language:EN-US'>nl</span></b><span style='mso-bidi-font-weight:
bold'>. Ясно, что этот алгоритм индуктивно замыкается на всех вершинах,
поскольку сохраняет соотношение (инвариант), используемый при нумерации: в
любом дереве сначала нумеруют вершины левого потомка, а затем – правого.<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------83-01.cpp</p>

<p class=a0>// Линейная СД на основе дерева с двумя потомками</p>

<p class=a0>// и данными в концевых вершинах</p>

<p class=a0>struct tree2{</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int cnt;<span
style='mso-tab-count:2'>              </span>// Количество терминальных вершин
в дереве</p>

<p class=a0><span style='mso-tab-count:1'>            </span>char *s;<span
style='mso-tab-count:2'>             </span>// Данные - строка текста</p>

<p class=a0><span style='mso-tab-count:1'>            </span>tree2 *l,*r;<span
style='mso-tab-count:1'>          </span>// Левый и правый потомки</p>

<p class=a0><span style='mso-tab-count:1'>            </span>};<span
style='mso-tab-count:2'>                      </span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Создание терминальной вершины<span style='mso-tab-count:1'>      </span></p>

<p class=a0>tree2 *create(char *ss){</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>tree2 *q=new tree2;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>q-&gt;l = q-&gt;r = NULL;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>q-&gt;cnt = 1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>q-&gt;s = ss;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>return</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>q</span>; }</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Поиск вершины по логическому номеру</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>char *get_n(tree2
*p, int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (p==NULL) return NULL;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (n &gt;= p-&gt;cnt) return
NULL;<span style='mso-tab-count:2'>                   </span>// Проверка на
диапазон ЛН</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (p-&gt;cnt==1)
return p-&gt;s;<span style='mso-tab-count:2'>                       </span>//
Вершина концевая - найден</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int
ll=p-&gt;l-&gt;cnt;<span style='mso-tab-count:4'>                                      </span>//
ll - счетчик значений у левого потомка</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (n&lt;ll)
return get_n(p-&gt;l,n);<span style='mso-tab-count:2'>                     </span>//
ЛН меньше, чем у левого - идти в него</p>

<p class=a0><span style='mso-tab-count:1'>            </span>return
get_n(p-&gt;r,n-ll);<span style='mso-tab-count:3'>                             </span>//
Иначе -<span style='mso-spacerun:yes'>  </span>в правого потомка с вычетом ll</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Добавление последним</p>

<p class=a0>void add(tree2 *&amp;p, char *ss){</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (p==NULL) p=create(ss);<span
style='mso-tab-count:2'>                      </span>// </span>Для<span
style='mso-ansi-language:EN-US'> </span>пустого<span style='mso-ansi-language:
EN-US'> </span>дерева<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>else {<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>p-&gt;cnt++;<span
style='mso-tab-count:3'>                                  </span>// Накручивать
счетчики вершин</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(p-&gt;r==NULL){<span style='mso-tab-count:2'>             </span>// Вершина
концевая - </p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>p-&gt;l=create(p-&gt;s);<span
style='mso-tab-count:1'>          </span>// Значение текущей - левому потомку</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>p-&gt;r=create(ss);<span
style='mso-tab-count:2'>             </span>// Правому потомку<span
style='mso-spacerun:yes'>  </span>-новое</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>}</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>else
add(p-&gt;r,ss);<span style='mso-tab-count:2'>                       </span>//
Не концевая - направо</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Включение по логическому номеру</p>

<p class=a0>void insert(tree2 *&amp;p, int n, char *ss){</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (p == NULL) { p=create(ss); return; }<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (n &gt;= p-&gt;cnt)
return;<span style='mso-tab-count:3'>                            </span>//
Проверка на диапазон ЛН</p>

<p class=a0><span style='mso-tab-count:1'>            </span>p-&gt;cnt++;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(p-&gt;r==NULL){<span style='mso-tab-count:3'>                         </span>//
концевая вершина -</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>p-&gt;l=create(ss);<span
style='mso-tab-count:3'>                         </span>// сделать ее
промежуточной</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>p-&gt;r=create(p-&gt;s);<span
style='mso-tab-count:2'>                      </span>// текущие данные -
правому</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>return;<span
style='mso-tab-count:4'>                                       </span>//
потомку, новые - левому</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int
ll=p-&gt;l-&gt;cnt;<span style='mso-tab-count:4'>                                      </span>//
ll - вершин у левого потомка</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (n&lt;ll)
insert(p-&gt;l,n,ss);<span style='mso-tab-count:2'>              </span><span
style='mso-tab-count:1'>            </span>// ЛН в диапазоне левого</p>

<p class=a0><span style='mso-tab-count:1'>            </span>else insert(p-&gt;r,n-ll,ss);<span
style='mso-tab-count:1'>   </span>}<span style='mso-tab-count:2'>                       </span>//
Иначе - перейти в правый с остатком</p>

<p class=a>&nbsp;<p class="a"><br
style='mso-ignore:vglayout' clear=ALL>
Остается еще процедура удаления по логическому номеру.<span
style='mso-spacerun:yes'>  </span>При удалении происходят изменения у предка
той вершины, которая удаляется. Она должна «подтянуть к себе» оставшихся
потомков, чтобы заполнить освободившееся место. Тогда сохранятся правила
построения дерева. Здесь есть два варианта. Если оставшийся потомок – концевая вершина,
то он должен сам стать концевой вершиной. Если же промежуточная, то он должен
взять ее потомков себе.</p>
<p align="center">
<img border="0" src="Images/083-04.gif" width="307" height="288"></p>
</p>

<p class=a4 align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m18">рис. </b><b style='mso-bidi-font-weight:normal'><a name="m19"><span lang=EN-US
style='mso-ansi-language:EN-US'>8</span>3.3. Удаление по логическому номеру<o:p></o:p></b></p>

<p class=a>А как это будет выглядеть в программе? Ведь вершина не может «убить
себя». Хотя, по большому счету, это уже вопрос, касающийся программного кода. В
принципе, функция, получающая указатель на вершину (или даже ссылку на
указатель), может освободить указуемую память, а затем возвратиться из
рекурсивного вызова к предку. Более того, в объектно-ориентированном
программировании можно освободить память, занимаемую текущим объектом (<b
style='mso-bidi-font-weight:normal'>delete this</b>), если в текущем методе мы
не будем к нему больше обращаться. Но лучше не пилить сук, на котором сидишь.</p>

<p class=a>Но лучше сделать, чтобы текущая вершина была удалена предком. <span
style='mso-bidi-font-weight:bold'>Рекурсивный вызов, который работает с
концевой вершиной, возвращает предку логическое значение, указывающее, что ее
нужно удалить. Кроме того, не нужно забывать «скручивать» счетчики во всех
промежуточных вершинах.</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------83-01.cpp</p>

<p class=a0>// Удаление по логическому номеру</p>

<p class=a0>// результат - сообщение предку от концевой вершины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int remove(tree2
*p, int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>tree2 *q;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (p == NULL) return 0; <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (n &gt;= p-&gt;cnt) return 0;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>p-&gt;cnt--;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (p-&gt;cnt==0)
return 1;<span style='mso-tab-count:3'>                            </span>//
концевая вершина - &quot;убей меня&quot;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int
ll=p-&gt;l-&gt;cnt;<span style='mso-tab-count:4'>                                      </span>//
вершин у левого потомка</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (n&lt;ll) {</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(remove(p-&gt;l,n)){<span style='mso-tab-count:2'>                      </span>//
Левый потомок просит удалить себя</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>delete
p-&gt;l;<span style='mso-tab-count:2'>                    </span>// Удалить
левого потомка</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>q=p-&gt;r;<span
style='mso-tab-count:3'>                          </span>// Совместить правого</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>p-&gt;s=q-&gt;s;<span
style='mso-tab-count:2'>                    </span>// потомка с текущей</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>p-&gt;l=q-&gt;l;<span
style='mso-tab-count:2'>                      </span>// вершиной</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>p-&gt;r=q-&gt;r;</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span>delete
q;<span style='mso-ansi-language:EN-US'> </span>}</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>else<span
style='mso-tab-count:1'>      </span>{</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(remove(p-&gt;r,n-ll)){<span style='mso-tab-count:2'>                   </span>//
Аналогично - просит правый</p>

<p class=a0><span style='mso-tab-count:3'>                                    </span><span
lang=EN-US style='mso-ansi-language:EN-US'>delete p-&gt;r;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>q=p-&gt;l;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>p-&gt;s=q-&gt;s;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>p-&gt;l=q-&gt;l;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:3'>                                    </span>p-&gt;r=q-&gt;r;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:3; mso-ansi-language:EN-US' lang="EN-US">                                    </span>delete
q;}</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}<span
style='mso-tab-count:1'>           </span></p>

<p class=a0><span style='mso-tab-count:1'>            </span>return 0; }<span
style='mso-tab-count:2'>                      </span>// Промежуточная вершина
&quot;не просит удалить себя&quot;</p>

<p class=a>В приведенном фрагменте перетягиваются все данные из потомка,
смежного с удаляемым, независимо от того, конечный он или промежуточный. Можно
даже предложил просто копировать вершины, как структурированные переменные
(Замечание: с объектами такой способ был бы не совсем корректен).</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(remove(p-&gt;r,n-ll)){<span style='mso-tab-count:2'>                   </span>//
Аналогично - просит правый</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>delete p-&gt;r;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>q=p-&gt;l;<o:p></o:p></span></p>

<p class=a0><span style='mso-tab-count:2'>                        </span>*p=*q;<span
style='mso-tab-count:3'>                           </span>// ВОТ ТАК
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>delete
q;}</p>

<h3><font face="Arial">Еще раз о способах наведения порядка</font></h3>

<p class=a><span style='mso-bidi-font-weight:bold'>Т</span>еперь давайте
поговорим о трудоемкости. Общие выводы уже сделаны. Все алгоритмы «добираются»
до нужной концевой вершины с помощью ветвления, то есть в сбалансированном
дереве <b style='mso-bidi-font-weight:normal'><a name="m20"><span lang=EN-US
style='mso-ansi-language:EN-US'>T</span>=</b><b style='mso-bidi-font-weight:
normal'><a name="m21"><span lang=EN-US style='mso-ansi-language:EN-US'>log</span><sub>2</sub></b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>, </b><span style='mso-spacerun:yes'> </span>в вырожденном <b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='mso-ansi-language:
EN-US'>T</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>N</span>/2. </b>Кстати, добавление значения
последним создает именно такое дерево.<b style='mso-bidi-font-weight:normal'><a name="m22"> </b>Непосредственно
само добавление, вставка и удаление вершин затрагивает не более двух потомков,
т.е. эти действия имеют постоянную трудоемкость.</p>

<p class=a4 align=center style='text-align:center'><o:p>
<img border="0" src="Images/083-05.gif" width="259" height="245"></o:p></p>

<p class=a4 align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m23"><o:p>&nbsp;</o:p></b></p>

<p class=a4 align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m24">рис. 83.4. Дерево, созданное процедурой добавления<o:p></o:p></b></p>

<p class=a4>Можно разработать алгоритмы, сохраняющие сбалансированность дерева,
но они связаны с топологическим преобразованиями деревьев и пока нам не по
зубам. Существует другой, менее радикальный способ, связанный с периодическим
«наведением порядка». Очевидно, можно предложить процедуру наведения порядка –
балансировки, которая периодически выравнивает структуру данных. Это можно
сделать в рамках существующего дерева, «перебрасывая» данные из поддерева с
большим количеством вершин в поддерево с меньшим. Начиная, само собой, с корня
и повторяя рекурсивно для всех потомков. Значительно проще использовать
вспомогательную структуру данных, например, собрать все концевые вершины в массив
указателей, используя полный рекурсивный обход, а потом построить на нем
сбалансированное дерево методом деления пополам.</p>

<p class=a>Функция, строящая дерево, получает интервал в массиве указателей.
(первоначально он соответствует всему массиву). Она создает промежуточную
вершину, делит интервал пополам и раздает эти половины рекурсивным вызовам. Они
возвращают поддеревья, которые присоединяются к текущей вершине как потомки. Так
продолжается до тех пор, пока в интервале не останется одна вершина, она будет
концевой</p>

<p class=a>Кстати, трудоемкость такого алгоритма – линейна (рекуррентное
определение трудоемкости <b style='mso-bidi-font-weight:normal'><a name="m25"><span
lang=EN-US style='mso-ansi-language:EN-US'>T<sub>N</sub></span>=2<span lang=EN-US style='mso-ansi-language:
EN-US'>T<sub>N</sub></span><sub>/2</sub>+1, </b><span style='mso-bidi-font-weight:
bold'>окончательное</span><b style='mso-bidi-font-weight:normal'><a name="m26"><span
style='mso-spacerun:yes'>  </span><span
lang=EN-US style='mso-ansi-language:EN-US'>T</span>=2</b><b style='mso-bidi-font-weight:
normal'><a name="m27"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span><span
lang=EN-US> </span></b><span style='mso-bidi-font-weight:bold'>(см.7.1)). И </span>еще
одна мелочь. Промежуточные вершины в процессе сбора концевых вершин необходимо
уничтожать, а при построении дерева – создавать как динамические переменные.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------83-01.cpp</p>

<p class=a0>// Балансировка дерева</p>

<p class=a0>// Создание дерева из ДМУ на концевые вершины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>tree2
*balance(tree2 *pp[], int a, int b){<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>tree2 *q;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (a==b) {</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>q=pp[a];<span
style='mso-tab-count:3'>                                    </span>// В
интервале одна вершина</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>q-&gt;cnt=1;<span
style='mso-tab-count:3'>                                  </span>// Возвратить
ее как концевую</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>q-&gt;r=q-&gt;l=NULL;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>return q; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>q=new tree2;<span style='mso-tab-count:
4'>                                         </span>// </span>промежуточная<span
style='mso-ansi-language:EN-US'> </span>вершина<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>m</span>=(<span lang=EN-US
style='mso-ansi-language:EN-US'>a</span>+<span lang=EN-US style='mso-ansi-language:
EN-US'>b</span>)/2;<span style='mso-tab-count:3'>                            </span><span
style='mso-tab-count:1'>            </span>// середина интервала</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>q</span>-&gt;<span lang=EN-US style='mso-ansi-language:
EN-US'>l</span>=<span lang=EN-US style='mso-ansi-language:EN-US'>balance</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>pp</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>a</span>,<span lang=EN-US style='mso-ansi-language:
EN-US'>m</span>);<span style='mso-tab-count:1'>    </span><span
style='mso-tab-count:2'>                        </span>// создать поддеревья </p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>q</span>-&gt;<span lang=EN-US style='mso-ansi-language:
EN-US'>r</span>=<span lang=EN-US style='mso-ansi-language:EN-US'>balance</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>pp</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>m</span>+1,<span lang=EN-US style='mso-ansi-language:
EN-US'>b</span>);<span style='mso-tab-count:1'>                        </span>// на половинах интервала</p>

<p class=a0><span style='mso-tab-count:1'>            </span>q-&gt;cnt=b-a+1;<span
style='mso-tab-count:3'>                            </span><span
style='mso-tab-count:1'>            </span>// Сформировать новый счетчик</p>

<p class=a0><span style='mso-tab-count:1'>            </span>return q;<span
style='mso-tab-count:4'>                                                </span>//
Возвратить поддерево</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0>// Обход с заполнением ДМУ на концевые вершины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void create(tree2
*p, tree2 *pp[], int &amp;ln){<span style='mso-tab-count:2'>              </span>//
ln - </span>с<span lang=EN-US style='mso-ansi-language:EN-US'>сылка на текущий
ЛН<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (p==NULL) return;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (p-&gt;cnt==1) pp[ln++]=p;<span
style='mso-tab-count:1'>                       </span>//
Концевая вершина - запомнить</p>

<p class=a0><span style='mso-tab-count:2'>                        </span></p>

<p class=a0><span style='mso-tab-count:1'>            </span>else<span
style='mso-tab-count:1'>      </span>{</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>create(p-&gt;l,pp,ln);<span
style='mso-tab-count:1'>                       </span>//
Промежуточные - обход потомков</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>create</span>(<span lang=EN-US
style='mso-ansi-language:EN-US'>p</span>-&gt;<span lang=EN-US style='mso-ansi-language:
EN-US'>r</span>,<span lang=EN-US style='mso-ansi-language:EN-US'>pp</span>,<span
lang=EN-US style='mso-ansi-language:EN-US'>ln</span>);</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>delete</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>p</span>;<span style='mso-tab-count:
3'>                                    </span>// Промежуточные - удаляются</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}}</p>

<p class=a0>// Общая процедура балансировки</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>balance</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>tree</span>2 *&amp;<span lang=EN-US
style='mso-ansi-language:EN-US'>ph</span>){</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>ph</span>==<span lang=EN-US style='mso-ansi-language:EN-US'>NULL</span>)
<span lang=EN-US style='mso-ansi-language:EN-US'>return</span>;</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>int</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>sz=ph-&gt;cnt;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>tree2 **pp=new tree2*[sz];<span
style='mso-tab-count:2'>                      </span>// </span>с<span
lang=EN-US style='mso-ansi-language:EN-US'>оздать ДМУ<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>int i=0; create(ph,pp,i);<span
style='mso-tab-count:2'>               </span><span style='mso-tab-count:1'>            </span>//
собрать концевые вершины в ДМУ</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>ph</span>=<span lang=EN-US style='mso-ansi-language:
EN-US'>balance</span>(<span lang=EN-US style='mso-ansi-language:EN-US'>pp</span>,0,<span
lang=EN-US style='mso-ansi-language:EN-US'>sz</span>-1);<span style='mso-tab-count:
3'>                           </span>// построит дерево на ДМУ</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>delete pp;}</span><span style='mso-tab-count:
4'>                                             </span><span lang=EN-US
style='mso-ansi-language:EN-US'>// уничтожить ДМУ<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a>Желательно проверять программу на реальных данных, например,
загружая текстовые файлы большого объема. Еще бы желательно, чтобы программа
выводила характеристики дерева: количество вершин, степень сбалансированности.
Чтобы это оценить, можно измерить расстояния от корневой до каждой конечной
вершины и усреднить их. У сбалансированного дерева оно должно быть равно <b
style='mso-bidi-font-weight:normal'>log<sub>2</sub>N, </b>а для дерева, полученного
с помощью алгоритма добавления, получим <b style='mso-bidi-font-weight:normal'><a name="m28">L=(1+2+3+…<span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>-1+<span lang=EN-US
style='mso-ansi-language:EN-US'>N</span>-1)/</b><b style='mso-bidi-font-weight:
normal'><a name="m29"><span lang=EN-US style='mso-ansi-language:EN-US'>N</span><span
lang=EN-US> </span></b><b style='mso-bidi-font-weight:normal'><a name="m30"><span
style='mso-bidi-font-family:"Times New Roman CYR"'>&#8776; (</span>N<sup><span style='font-size:14.0pt'>2</span></sup>/2)/<span lang=EN-US style='mso-ansi-language:
EN-US'>N</span>=<span lang=EN-US
style='mso-ansi-language:EN-US'>N</span>/2</b>, т.е. линейная зависимость. <span
style='mso-bidi-font-weight:bold'>Для подсчета этого значения можно было бы
использовать функцию обхода, добавив в нее еще результат – сумму длин путей.</span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------83-01.cpp</p>

<p class=a0>// Обход дерева – выводит все вершины и возвращает сумму длин путей</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int scan(tree2 *p,
int level, int &amp;ln){<span style='mso-tab-count:1'>          </span>// level
– </span>текущая<span style='mso-ansi-language:EN-US'> </span>глубина<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (p==NULL) return 0;</span><span
style='mso-tab-count:2'>                 </span><span lang=EN-US
style='mso-ansi-language:EN-US'>// ln – логический </span>номер</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int L=0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (p-&gt;l==NULL){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>printf(&quot;l=%d n=%d
cnt=%d :%s\n&quot;, level, ln, p-&gt;cnt, p-&gt;s);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>ln++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>return level;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>else<span style='mso-tab-count:1'>      </span>{
printf(&quot;l=%d cnt=%d\n&quot;, level, p-&gt;cnt);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>return scan(p-&gt;l,
level+1,ln)+scan(p-&gt;r, level+1,ln);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>}}<o:p></o:p></span></p>

<h3><font face="Arial">Дерево с нумерацией вершин «сверху-вниз»</font></h3>

<p class=a>Давайте слегка усложним задачу. Дерево с двумя потомками теперь
будет содержать данные во всех вершинах. Нумеровать их будем «сверху-вниз»:
сначала нумеруется корневая вершина поддерева, потом вершины левого потомка, а
затем – правого. Аналогично, для реализации поиска по логическому номеру в
каждую вершину введем счетчик вершин в поддереве. </p>

<p class=a4><b><a name="m31"><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></b></p>

<p class=a4 style="text-align: center"><o:p>
<img border="0" src="Images/083-06.gif" width="370" height="287"></o:p></p>

<p class=a4 align=center style='text-align:center'><b style='mso-bidi-font-weight:
normal'><a name="m32">рис. </b><b style='mso-bidi-font-weight:normal'><a name="m33"><span lang=EN-US
style='mso-ansi-language:EN-US'>8</span>3.5. Дерево с нумерацией вершин
«сверху-вниз»<o:p></o:p></b></p>

<p class=a><span style='mso-bidi-font-weight:bold'>Некоторые алгоритмы просто корректируются
в соответствии с изменившимся порядком нумерации. </span>Функция, выполняющая
полный рекурсивный обход дерева, пронумеровывает вершины, используя общих для
всех вызовов счетчик, передаваемый по ссылке: сначала текущую вершину, затем
левое и правое поддеревья.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----------------------------------------------------------------------------------------------------------------83-02.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>// Полный рекурсивный обход дерева</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>scan</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>tree</span>2 *<span lang=EN-US
style='mso-ansi-language:EN-US'>p</span>, <span lang=EN-US style='mso-ansi-language:
EN-US'>int</span><span lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>level</span>, <span lang=EN-US style='mso-ansi-language:EN-US'>int</span>
&amp;<span lang=EN-US style='mso-ansi-language:EN-US'>ln</span>){<span
style='mso-tab-count:2'>                    </span>// <span lang=EN-US
style='mso-ansi-language:EN-US'>level</span><span style='mso-spacerun:yes'> 
</span>– уровень вершины (длина ветви)</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if</span> (<span lang=EN-US style='mso-ansi-language:
EN-US'>p</span>==<span lang=EN-US style='mso-ansi-language:EN-US'>NULL</span>) <span
lang=EN-US style='mso-ansi-language:EN-US'>return</span>;<span
style='mso-tab-count:3'>                                </span>// <span
lang=EN-US style='mso-ansi-language:EN-US'>ln</span><span style='mso-tab-count:
1'>       </span>- порядковый (логический) номер</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>printf(&quot;l=%d n=%d cnt=%d :%s\n&quot;,
level, ln, p-&gt;cnt, p-&gt;s);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>ln++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>scan(p-&gt;l, level+1,ln);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>scan(p-&gt;r, level+1,ln); }<o:p></o:p></span></p>

<p class=a>
<img border="0" src="Images/083-07.gif" width="263" height="84" align="right">Имея
в каждой вершине счетчики вершин поддерева, мы, тем самым, получаем диапазоны
логических номеров вершин (как текущей, так и каждого потомка), для которых
получается простой алгоритм ветвления:</p>
<p class=a>&nbsp;</p>

<p class=a1>- если текущий логический номер (ЛН) меньше количества вершин в
текущем поддереве, то вершины с таким ЛН не существует;</p>

<p class=a1>- если ЛН при входе в поддереве равен 0, то он соответствует
корневой вершине;</p>

<p class=a1>- иначе от ЛН отнимается единица и при наличии левого поддерева
проверяется вхождение ЛН в его диапазон. Если это так, то функция рекурсивно
вызывается для левого поддерева;</p>

<p class=a1>- иначе от ЛН отбрасывается количество вершин в левом поддереве и с
полученным остатком алгоритм выполняется для правого поддерева.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//--------------------------------------------------------------------------------------------------------------83-02.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>// Поиск значения по логическому номеру</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>char *get_n(tree2
*p, int n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (p==NULL) return NULL;<span
style='mso-tab-count:2'>                       </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (n &gt;= p-&gt;cnt) return NULL;<span
style='mso-tab-count:2'>                   </span>// </span>ЛН<span
style='mso-ansi-language:EN-US'> </span>вне<span style='mso-ansi-language:EN-US'>
</span>диапазона<span style='mso-ansi-language:EN-US'> </span>дерева<span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (n-- ==0) return p-&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>s</span>;<span style='mso-tab-count:
3'>                           </span>// ЛН = 0 для корневой вершины </p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (p-&gt;l!=NULL){<span
style='mso-tab-count:4'>                                      </span>// Если
есть левое поддерево</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>int
ll=p-&gt;l-&gt;cnt;<span style='mso-tab-count:3'>                          </span>//
и ЛН-1 попадает в его диапазон ll</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(n&lt;ll) <span lang=EN-US
style='mso-ansi-language:EN-US'>return</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>get</span>_<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>(<span lang=EN-US style='mso-ansi-language:
EN-US'>p</span>-&gt;<span lang=EN-US style='mso-ansi-language:EN-US'>l</span>,<span
lang=EN-US style='mso-ansi-language:EN-US'>n</span>);<span style='mso-tab-count:
1'>        </span>// Искать в нем с тем же ЛН-1</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>n-=ll;<span
style='mso-tab-count:4'>                                         </span>//
Иначе отбросить число вершин</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>}<span
style='mso-tab-count:4'>                                               </span>//
в левом поддереве и корень</p>

<p class=a0><span style='mso-tab-count:1'>            </span>return get_n(p-&gt;r,n);
}<span style='mso-tab-count:3'>                             </span>// и искать
остаток в правом поддереве</p>

<p class=a><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>При вставке новое значение «замещает» старое на его месте. Тогда по
отношению к «лишним» данным нужно выполнить тот же самый алгоритм вставки в
поддерево найденной вершины. Д<span style='mso-bidi-font-weight:bold'>анные
вытесняются из вершины,<span style='mso-spacerun:yes'>   </span>она, в свою очередь,
становится корневой вершиной дерева, тогда их нужно включить в левое поддерево «в
начало», т.е. с относительным логическим номером, равным 0.<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//--------------------------------------------------------------------------------------------------------------83-02.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>// Включение по логическому номеру</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>insert</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>tree</span>2 *&amp;<span lang=EN-US
style='mso-ansi-language:EN-US'>p</span>, <span lang=EN-US style='mso-ansi-language:
EN-US'>int</span><span lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:
EN-US'>n</span>, <span lang=EN-US style='mso-ansi-language:EN-US'>char</span> *<span
lang=EN-US style='mso-ansi-language:EN-US'>ss</span>){</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (p == NULL) { p=create(ss); return; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (n &gt;= p-&gt;cnt) return;<span
style='mso-tab-count:2'>                </span><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>p-&gt;cnt++;<span
style='mso-tab-count:4'>                                              </span>//
увеличивать счетчики в проходимых вершинах</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (n-- ==0)<span
style='mso-tab-count:4'>                                             </span>//
если текущий ЛН=0 - вершина найдена,</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>insert(p-&gt;l,0,p-&gt;s),p-&gt;s=ss;
<span style='mso-tab-count:1'>       </span>// данные из нее сносятся в левое
поддерево </p>

<p class=a0><span style='mso-tab-count:1'>            </span>else<span
style='mso-tab-count:5'>                                                      </span>//
с ЛН=0, а<span style='mso-spacerun:yes'>  </span>на их место помещаются новые</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(p-&gt;l!=NULL){<span style='mso-tab-count:4'>                                      </span>//
Иначе - рекурсивный вызов аналогично алгоритму</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>int
ll=p-&gt;l-&gt;cnt;<span style='mso-tab-count:3'>                          </span>//
поиска по ЛН</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (n&lt;ll) { insert(p-&gt;l,n,ss);
return; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>n-=ll; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>else insert(p-&gt;r,n,ss);} </span></p>

<p class=a>Обратите внимание, что здесь передается <b style='mso-bidi-font-weight:
normal'><a name="m34">ссылка на указатель </b><span style='mso-spacerun:yes'> </span>на
текущую вершину, т.е. «отображение» на то место, где хранится указатель на
текущую вершину. Это позволяет создавать новую вершину на свободной ветви, т.е.
когда мы ссылаемся на указатель, содержащий NULL. При удалении, похоже, можно
сделать «вытеснение наоборот», т.е. удалять найденную вершину, а на ее место
помещать одного из потомков. Если использовать ту же технику – <b
style='mso-bidi-font-weight:normal'>ссылка на указатель, </b>то под ссылку
нужно помещать указатель на «следующего» в порядке нумерации потомка.
Перечислим все возможные варианты.</p>

<p class=a>Если потомков нет, то NULL, если потомок один, то указатель на него.
А что делать, если потомков два? Ведь нельзя под одну ссылку поместить сразу
два указателя? А ведь потомки тоже могут быть промежуточными вершинами. В этом
случае надо отказаться от перемещения вершин и вспомнить, что мы делали с
«лишними» данными при вставке. И сделать наоборот, т.е. «занять» недостающие
данные, исключив их из левого поддерева с<span style='mso-spacerun:yes'> 
</span>логическим номером 0.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//--------------------------------------------------------------------------------------------------------------83-02.<span
lang=EN-US style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>// Удаление по логическому номеру</p>

<p class=a0>char *remove(tree2 *&amp;p, int n){<span style='mso-tab-count:2'>                 </span>//
ссылка на место размещения указателя</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>if (p == NULL) return NULL;<span
style='mso-tab-count:1'>         </span>// </span>удаляемой<span
style='mso-ansi-language:EN-US'> </span>вершины<span lang=EN-US
style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (n &gt;= p-&gt;cnt) return
NULL;<span style='mso-tab-count:1'>       </span>// Для удаляемой вершины
производится замещение</p>

<p class=a0><span style='mso-tab-count:1'>            </span>p-&gt;cnt--;<span
style='mso-tab-count:3'>                                    </span>// Если нет
потомков - удаляется</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (n-- ==0) {<span
style='mso-tab-count:3'>                               </span>// Если есть один
потомок - удаляется, на ее место</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>char
*ss = p-&gt;s;<span style='mso-tab-count:2'>             </span>// помещается
потомок</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>tree2
*q;<span style='mso-tab-count:2'>                        </span>// Иначе
замещается значением, удаляемым по ЛН=0</p>

<p class=a0><span style='mso-tab-count:5'>                                                            </span>//
из левого поддерева</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>if
(p-&gt;l==NULL &amp;&amp; p-&gt;r==NULL) { delete p; p=NULL; return ss;}</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (p-&gt;l==NULL) { q=p-&gt;r;
delete p; p=q; return ss;<span style='mso-spacerun:yes'>  </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>if (p-&gt;r==NULL) {
q=p-&gt;l; delete p; p=q; return ss;<span style='mso-spacerun:yes'>  </span>}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>p-&gt;s =
remove(p-&gt;l,0); return ss;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span>}</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if
(p-&gt;l!=NULL){<span style='mso-tab-count:3'>                          </span>//
Иначе - рекурсивный вызов аналогично алгоритму</p>

<p class=a0><span style='mso-tab-count:2'>                        </span>int
ll=p-&gt;l-&gt;cnt;<span style='mso-tab-count:2'>              </span>// поиска
по ЛН</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>if (n&lt;ll) return remove(p-&gt;l,n);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>n-=ll; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>else return remove(p-&gt;r,n); }</span></p>

<p class=a>Кстати, мы уже обсуждали, может ли вершина «убить себя».
Оказывается, что может. В нашем примере по ссылке на текущую вершину
производится ее уничтожение (освобождение памяти), а потом под эту ссылку
записывается указатель на выбранного потомка.</p>

<p class=a>Что касается балансировки, то здесь, отличия несущественные.
Собирать вершины в массив указателей можно обходом теперь уже всех вершин, а
строить дерево – в соответствии с правилом нумерации – первая вершина интервала
– корневая, а остаток, начиная со второй, аналогично разбивается на две равные
части.</p>

<p class=a>Здесь есть еще одна тонкость. В этом дереве возможны интервалы
нулевой длины. Допустим, создается дерево из 2 вершин. Первая становится
корневой, вторая – левым поддеревом, а интервал правого – нулевой длины. В этом
случае функция возвращает NULL-указатель.<b style='mso-bidi-font-weight:normal'><a name="m35"><o:p></o:p></b></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//----------------------------------------------------------------------------------------------------------------83-0<span
lang=EN-US style='mso-ansi-language:EN-US'>2</span>.<span lang=EN-US
style='mso-ansi-language:EN-US'>cpp</span></p>

<p class=a0>// Балансировка поддерева в диапазоне логических номеров [a...b]</p>

<p class=a0>// Функция формирует сбалансированное поддерево из вершин интервала</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>tree2
*balance(tree2 *pp[], int a, int b){<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>if (a&gt;b) return NULL;<span
style='mso-tab-count:2'>                   </span>// диапазон
&quot;стянулся&quot; в точку</p>

<p class=a0><span style='mso-tab-count:1'>            </span>tree2 *q;</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (a==b)<span
style='mso-tab-count:3'>                                    </span>// в
диапазоне - единственная вершина</p>

<p class=a0><span style='mso-tab-count:2'>                        </span><span
lang=EN-US style='mso-ansi-language:EN-US'>{ q=pp[a]; q-&gt;l=q-&gt;r=NULL;
q-&gt;cnt=1; return q; }<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>q=pp[a];<span
style='mso-tab-count:3'>                                    </span>// первая
вершина интервала - корневая</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int m=(a+b+1)/2;<span
style='mso-tab-count:2'>                        </span>// середина оставшегося
интервала</p>

<p class=a0><span style='mso-tab-count:1'>            </span>q-&gt;l=balance(pp,a+1,m-1);<span
style='mso-tab-count:1'>          </span>// левое и правое поддерево
сформировать</p>

<p class=a0><span style='mso-tab-count:1'>            </span>q-&gt;r=balance(pp,m,b);<span
style='mso-tab-count:2'>                </span>// рекурсивно из половинок
интервала</p>

<p class=a0><span style='mso-tab-count:1'>            </span>q-&gt;cnt=b-a+1;<span
style='mso-tab-count:3'>                            </span>// счетчик вершин в
поддереве - </p>

<p class=a0><span style='mso-tab-count:1'>            </span>return q;<span
style='mso-tab-count:3'>                                    </span>// ширина
интервала</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Обход дерева с заполнением массива указателей на вершины</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>set</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>tree</span>2 *<span lang=EN-US
style='mso-ansi-language:EN-US'>pp</span>[], <span lang=EN-US style='mso-ansi-language:
EN-US'>tree</span>2 *<span lang=EN-US style='mso-ansi-language:EN-US'>p</span>,
<span lang=EN-US style='mso-ansi-language:EN-US'>int</span> &amp;<span
lang=EN-US style='mso-ansi-language:EN-US'>ln</span>){</p>

<p class=a0><span style='mso-tab-count:1'>            </span>if (p==NULL)
return;<span style='mso-tab-count:2'>                    </span>// ln - порядковый
(логический) номер</p>

<p class=a0><span style='mso-tab-count:1'>            </span>pp[ln++]=p;<span
style='mso-tab-count:3'>                               </span>// запомнить
указатель на текущую вершину </p>

<p class=a0><span style='mso-tab-count:1'>            </span>set(pp,p-&gt;l,ln);<span
style='mso-tab-count:3'>                           </span>// рекурсивно
выполнить для поддеревьев</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>set</span>(<span lang=EN-US style='mso-ansi-language:
EN-US'>pp</span>,<span lang=EN-US style='mso-ansi-language:EN-US'>p</span>-&gt;<span
lang=EN-US style='mso-ansi-language:EN-US'>r</span>,<span lang=EN-US
style='mso-ansi-language:EN-US'>ln</span>); }</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>// Балансировка поддерева с использованием динамического массива
указателей</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>void</span><span
lang=EN-US> </span><span lang=EN-US style='mso-ansi-language:EN-US'>balance</span>(<span
lang=EN-US style='mso-ansi-language:EN-US'>tree</span>2 *&amp;<span lang=EN-US
style='mso-ansi-language:EN-US'>ph</span>){</p>

<p class=a0><span style='mso-tab-count:1'>            </span>int sz=ph-&gt;cnt;<span
style='mso-tab-count:3'>                          </span>// создать
динамический массив указателей</p>

<p class=a0><span style='mso-tab-count:1'>            </span><span lang=EN-US
style='mso-ansi-language:EN-US'>tree2 **pp=new tree2*[sz];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>int ln=0;<span style='mso-tab-count:
1'>            </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>set(pp,ph,ln);<span
style='mso-tab-count:3'>                             </span>// </span>заполнить<span
lang=EN-US style='mso-ansi-language:EN-US'> <o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>ph=balance(pp,0,sz-1);<span
style='mso-tab-count:2'>               </span>// вызвать рекурсивную функцию
балансировки</p>

<p class=a0><span style='mso-tab-count:1'>            </span>}<span
style='mso-tab-count:4'>                                               </span>//
для всего интервала</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a4><span style='mso-bidi-font-weight:bold'><o:p>&nbsp;</o:p></span></p>

</div>

</body>

</html>
