<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="038.files/editdata.mso">
<title>Романов Е.Л. Беседы о программировании</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>User</o:Author>
  <o:Template>Книга(шаблон).dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>777</o:TotalTime>
  <o:Created>2008-02-12T20:36:00Z</o:Created>
  <o:LastSaved>2008-02-12T20:36:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>3910</o:Words>
  <o:Characters>22291</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>185</o:Lines>
  <o:Paragraphs>52</o:Paragraphs>
  <o:CharactersWithSpaces>26149</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:AttachedTemplate HRef="U:\Романов\Книга(шаблон).dot"></w:AttachedTemplate>
  <w:DoNotHyphenateCaps/>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("038.files/header.htm") fs;
	mso-footnote-continuation-separator:url("038.files/header.htm") fcs;
	mso-endnote-separator:url("038.files/header.htm") es;
	mso-endnote-continuation-separator:url("038.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-even-header:url("038.files/header.htm") eh1;
	mso-header:url("038.files/header.htm") h1;
	mso-even-footer:url("038.files/header.htm") ef1;
	mso-footer:url("038.files/header.htm") f1;
	mso-first-header:url("038.files/header.htm") fh1;
	mso-first-footer:url("038.files/header.htm") ff1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:1115371258;
	mso-list-type:hybrid;
	mso-list-template-ids:-674477614 1227124434 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l0:level1
	{mso-level-start-at:2;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:53.45pt;
	mso-level-number-position:left;
	margin-left:53.45pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2><font face="Arial">3.8. Прописные истины<span lang=EN-US style='mso-ansi-language:EN-US'>
теории алгоритмов</span></font></h2>

<p class=a4><img border="0" src="Images/science.jpg" width="43" height="33">По
прочтении глав, касающихся анализа и проектирования программ, у читателя должно
сложиться мнение, что программирование – скорее <b style='mso-bidi-font-weight:
normal'><a name="m1">ремесло </b><span style='mso-spacerun:yes'> </span>с набором известных
рекомендаций и приемов, нежели точная наука. Формальные методы касаются<span
style='mso-spacerun:yes'>  </span>только некоторых частностей, например, оценки
производительности (трудоемкости), обоснования правильности программ. Тем не
менее, существует такая отрасль математики как <b style='mso-bidi-font-weight:
normal'><a name="m2">теория алгоритмов</b>, которая возникла еще до появления компьютеров.
Возникает резонный вопрос: какое отношение имеет теория алгоритмов к практике
программирования?</p>

<p class=a>Как это не странно, теория алгоритмов ничего не говорит о<span
style='mso-spacerun:yes'>  </span>том, как разрабатывать программы. Ее выводы
касаются, прежде всего, <b style='mso-bidi-font-weight:normal'><a name="m3">потенциальных
возможностей и ограничений, </b>которые заложены в привычном нам понятии
«компьютерная программа». Теория алгоритмов в свое время (как раз на заре
появления компьютеров, когда идеи программного управления, как говорится,
«носились в воздухе») обосновала основные свойства, а самое главное, границы
применения того, что сейчас называется компьютерной архитектурой (совместно с
исполняемой в ней программой), а в теории алгоритмов - <b><a name="m4">машиной Тьюринга
(МТ). </b><span style='mso-bidi-font-weight:bold'>Машина Тьюринга<b><a name="m5"> - </b></span>формальная
модель, удобная для проведения различных доказательств. Поэтому не стоит
относиться к ней снисходительно: она не инструмент программирования, а средство
доказательства. Свойства программ, полученные на ее основе, должны быть
очевидны для программиста так же, как закон постоянства скорости света для
физика. <span style='mso-spacerun:yes'> </span></p>

<p class=a4><i><img border="0" src="Images/smile.jpg" width="23" height="24">«Если
у Вас есть компьютер, займитесь прикладным программированием. Если же у Вас его
нет, займитесь теоретическим. Почаще рассуждайте: если бы у меня был компьютер,
то…» Перефразированная старая шутка из «Комсомольской правды».<o:p></o:p></i></p>

<p class=a>Основные выводы теории алгоритмов для программистов-практиков лежат
в области «само собой разумеющегося». Для начинающих, а тем более для
неспециалистов, самоучек и дилетантов такое незнание может быть основой для
заблуждений относительно возможностей компьютерных программ. В результате в
лучшем случае мы имеем напрасно потраченное время на решение заведомо неразрешимых
проблем, а в худшем случае – неосознанное введение в заблуждение общественного
мнения. Итак, наши задачи - низвести основные выводы теории алгоритмов «с небес
на грешную землю», а также дать «научную» интерпретацию с точки зрения теории
алгоритмов очевидных фактов, известных программистам-практикам.</p>

<h3><font face="Arial">Алгоритмически неразрешимые проблемы</font></h3>

<p class=a>Как говорят законы физики, изобретать вечный двигатель бессмысленно.
Периодически появляющиеся изобретатели вечных двигателей либо не знают физики,
либо просто отрицают ее законы. В теории алгоритмов аналогом вечного двигателя
являются <b style='mso-bidi-font-weight:normal'><a name="m6">алгоритмически неразрешимые
проблемы – </b>задачи, для которых доказана невозможность разработки алгоритма ее
решения (и, соответственно, создания программы). </p>

<p class=a><span style='mso-bidi-font-weight:bold'>Естественным источником
алгоритмически неразрешимых проблем является <b><a name="m7">самоприменимость алгоритмов, </b>т.е.
применение программ к анализу свойств других программ. </span>К
программированию имеют отношение самые неутешительные выводы теории алгоритмов.
Начинается все с проблемы остановки машины Тьюринга: невозможно создать МТ,
которая, получив на вход программу любой МТ, решает, останавливается она или
«зацикливается». В двух словах, доказательство базируется на том, что такая МТ
с некоторыми изменениями предъявляется на вход самой себе, что приводит к
противоречию. В переводе на «естественный язык» это означает, что нельзя
написать программу, которая по тексту другой программы (не исполняя ее)
определяет такое ее свойство. Научно выражаясь, это <b><a name="m8">алгоритмически
неразрешимо</b>.</p>

<h3><font face="Arial">Теорема Райса </font> </h3>

<p class=a>Далее, это утверждение развивается до того, что алгоритмически
неразрешимыми оказываются все нетривиальные утверждения о программах (теорема
Райса). Прагматическая интерпретация этого утверждения звучит довольно
пессимистично: по тексту программы (включая входные данные) формальными
методами нельзя определить, обладает ли она заданным свойством (например,
является программой сортировки).</p>

<p class=a>Сказанное не следует понимать буквально, что по тексту программы
нельзя ничего утверждать о ее поведении и свойствах. На самом деле нельзя
создать <b style='mso-bidi-font-weight:normal'><a name="m9">всеобщий алгоритм, </b>применимый
к <b style='mso-bidi-font-weight:normal'><a name="m10">любой </b>программе (ее тексту). То,
что такие задачи решаются, означает, что эти решения<span
style='mso-spacerun:yes'>  </span>справедливы только для <b style='mso-bidi-font-weight:
normal'><a name="m11">частных </b>случаев, либо основаны на неформальных (например,
интуитивных) подходах, которые не могут быть сформулированы в виде точных
алгоритмов. К сожалению (а с точки зрения перспектив человечества – к счастью)
основные этапы разработки программ приводят к алгоритмически неразрешимым
проблемам.</p>

<h3><font face="Arial">Анализ программ. Слово теории алгоритмов</font><span lang=EN-US style='mso-ansi-language:
EN-US'><o:p></o:p></span></h3>

<p class=a>Анализ программы состоит в определении того, что является ее
результатом. Это может быть сформулировано как содержательно (например,
программа «переворачивает» слова), так и формально, как свойства выходных
данных (например, программа сортировки создает упорядоченный массив, свойство
возрастания элементов в котором может быть определено формально). Опять же
результат программы является нетривиальным ее свойством, поэтому такая задача
является в общем виде алгоритмически неразрешимой.</p>

<p class=a>Тем не менее, мы уже рассматривали способы анализа программ:
«исторический» и логический, а также их комбинирование для анализа конкретных
программ. Здесь, как и везде, не существует общего метода: программист каждый
раз идет своим путем.</p>

<p class=a>Кроме того, логический анализ (разложение программы на фрагменты с
известным результатом) и «исторический» (временной) анализ, являются
предварительной фазой, дающей «пищу для ума». Далее в дело вступают опыт,
интуиция и тому подобные вещи:</p>

<p class=a1>- закономерности изменения данных, ведущих к результату можно
непосредственно уловить или «увидеть» в процессе «исторического анализа» при
непосредственном наблюдении за ходом выполнения программы (интуиция);</p>

<p class=a1>- подобные решения уже встречались в практике программирования,
возможно, в другом контексте, в других условиях, других структурах данных
(опыт, аналогия);</p>

<p class=a1>- возможно сделать предположение о результате работы программы,
либо область приложения ее результатов заранее известна (знание предметной
области, известных решений, опыт).</p>

<p class=a>Очевидно, что все таким образом сделанные предположения носят
гипотетический характер и нуждаются если не в доказательстве, то хотя бы в
обосновании. Обычно это делается полуформально: полученные при логическом
анализе<span style='mso-spacerun:yes'>  </span>фрагменты программы с известными
результатами при их «историческом» взаимодействии во времени должны
подтверждать или опровергать гипотезу.</p>

<div style='mso-element:para-border-div;border:solid windowtext 1.5pt;
padding:1.0pt 1.0pt 1.0pt 1.0pt;margin-left:35.45pt;margin-right:32.9pt'>

<p class=a2 style='margin-top:12.0pt;margin-right:0cm;margin-bottom:12.0pt;
margin-left:0cm'><font face="Arial" size="2">Фазы анализа: 1. сбор данных: логический и «исторический»
анализ 2. Гипотеза о результате 3. Обоснование или доказательство</font></p>

</div>

<p class=a>В технологии программирования известна обратная задача <b
style='mso-bidi-font-weight:normal'>верификации программ.</b> Для известного
результата, сформулированного в виде строгого формального утверждения, путем
ряда формальных преобразований доказывается правильность программы. Однако, в массовом
программировании это не нашло практического применения виду того, что сложность
доказательства многократно превосходит сложность самой программы. На практике
обычно довольствуются полуформальными методами и соблюдением общих рекомендаций
<span style='mso-spacerun:yes'> </span>для отдельных частей программы (см.,
например,<span style='mso-spacerun:yes'>  </span>инвариант цикла).</p>

<p class=a4><b
style='mso-bidi-font-weight:normal'>Утверждение. </b>Невозможно построить
алгоритм, который по тексту программы определяет что она делает.</p>

<p class=a4><b style='mso-bidi-font-weight:normal'><a name="m12">
<img border="0" src="Images/smile.jpg" width="23" height="24">Следствие. </b>По тексту
программы нельзя ничего сказать о характере программиста, ее написавшего.</p>

<h3><font face="Arial">Проектирование программ. Слово теории алгоритмов</font></h3>

<p class=a>Неутешительные выводы теории<span style='mso-spacerun:yes'> 
</span>алгоритмов касаются и процесса проектирования программ. Во-первых,
образная сторона<span style='mso-spacerun:yes'>  </span>процесса (образная
модель) является неформальной и неформализуемой областью деятельности. Во-вторых,
этапы выделения стандартных фрагментов и выстраивание из них программы
(собственно технология программирования) хотя и состоят из более-менее
формальных шагов, их выделение из образной модели и последовательность их
применения также не подчиняются алгоритмизации. </p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m13">Метод «мешка радиодеталей».</b>
Если невозможно разработать программу, создающую другие программы, то может
быть, подойти к проблеме с другой стороны: формальным образом генерировать все
возможные программы, а затем отделять нужные от ненужных, правильные от
неправильных. Ведь с точки зрения теории вероятностей существует вероятность
того, что при случайном перетряхивании мешка радиодеталей они сложатся в
цветной телевизор. Кстати, с точки зрения средств языков программирования это
можно сделать. Например, формальная грамматика как раз представляет собой
описание синтаксиса <b><a name="m14">всех возможных синтаксически правильных программ </b><span
style='mso-bidi-font-weight:bold'>на этом языке<b><a name="m15">.</b></span> Так вот, такая
идея не проходит не только с экономической точки зрения, но и с теоретической:
невозможно создать программный фильтр для отделения «овец от козлов», поскольку
«полезность» программы опять-таки является ее нетривиальным свойством.</p>

<h3><font face="Arial">Отладка программы. Слово теории алгоритмов</font></h3>

<p class=a>Если отлаженную программу можно считать «правильной», то каждая 
ошибка в ней может рассматриваться как вариант «неправильной» программы. 
Комбинации этих ошибок тоже дают «неправильные программы». Можно сказать, на 
одну «правильную» программу существует достаточно много<span
style='mso-spacerun:yes'>&nbsp; </span>«неправильных». Опять же, если 
рассматривать <b style='mso-bidi-font-weight:normal'><a name="m16">все возможные программы, </b>
то свойство «правильности» некоторых из них будет нетривиальным, а сама задача 
отладки - алгоритмически неразрешимой. Потому при отладке программ еще большее 
значение приобретают искусство (интуиция) и ремесло (навыки, общие 
технологические принципы). </p>

<p class=a>С учетом предложенного деления на «правильные» и «неправильные»
программы процесс отладки выглядит так: программист имеет в компьютере «неправильную»
программу, а у себя в голове – идеальный «правильный» вариант. Отладка
заключается в наблюдении за поведением программы (для этого существуют
отладчики, в сущности, одинаковые во всех системах программирования: пошаговое
или поэтапное выполнение программы со слежением за состоянием ее переменных). В
месте обнаружения отклонения результатов выполнения от «идеальных» находится
ошибка. Поэтому одним из основных этапов отладки является локализация ошибки.
Некоторые рекомендации по этому поводу:</p>

<p class=a1 style='margin-left:53.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:42.55pt list 53.45pt'><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><![endif]>сужение интервала поиска. Ошибка локализуется
последовательным сужением интервала между двумя точками программы, где она «еще
работает» и «уже не работает»;</p>

<p class=a1 style='margin-left:53.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:42.55pt list 53.45pt'><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><![endif]>исходные данные для отладки следует выбирать
настолько простыми и ограниченными по объему, чтобы их изменением ними можно
было отследить вручную. Однако они не должны быть «вырожденными», то есть они
должны содержать комбинации, существенные для логики работы программы;</p>

<p class=a1>- метод проб и ошибок предполагает проведение «экспериментов» над
программой с различными входными данными с целью установления закономерности
появления ошибки.</p>

<p class=a>С точки зрения «приближения к идеалу» ошибки можно разделить на
группы по степени их «влияния» на текст программы:</p>

<p class=a1 style='margin-left:53.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:42.55pt list 53.45pt'><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><![endif]>«очепятки» исправляются заменой имени переменной
(значения константы, операции) на правильную;</p>

<p class=a1 style='margin-left:53.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:42.55pt list 53.45pt'><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><![endif]>«недоразумения» предполагают, что программист не
учел некоторые нюансы или частные случаи (например, крайнюю ситуацию), что
исправляется локальной коррекцией логики работы фрагмента программы;</p>

<p class=a1 style='margin-left:53.45pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:42.55pt list 53.45pt'><![if !supportLists]>
<span style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><![endif]>«катастрофические» ошибки требуют кардинальной
переделки программы. Они говорят о том, что идеи, заложенные в программу, не
позволяют достигнуть цели, либо достигают ее в отдельных и частных случаях.</p>

<p class=a>И в заключение еще один парадокс отладки: если «правильная»
программа состоит обычно из частей, взаимодействующих по простым правилам,
которые устанавливает программист (инварианты, системные соглашения), то в
случае ошибки эта правила искажаются и усложняются. Поэтому <b><a name="m17">объяснить,
почему программа с ошибкой работает именно так, а не иначе, сложнее, чем ее
исправить.<o:p></o:p></b></p>

<p class=a4><b
style='mso-bidi-font-weight:normal'>
<img border="0" src="Images/smile.jpg" width="23" height="24">Резюме: </b>Перефразируя Евангелие: <b
style='mso-bidi-font-weight:normal'>Итак, отдайте же Богу богово, а процессору
– процессорово. </b>Все этапы программирования: анализ, разработка и отладка
программ сочетают в себе <b style='mso-bidi-font-weight:normal'><a name="m18">интуитивно-образный
</b>и <b style='mso-bidi-font-weight:normal'><a name="m19">формально-логический </b>подходы. Отдельные
частные проблемы могут быть алгоритмически разрешимы и программируемы. В общем
же виде решение таких задач является прерогативой человека, а не компьютера.</p>

<h3><font face="Arial">Эквивалентность языков программирования</font></h3>

<p class=a>По большому счету все языки программирования <b style='mso-bidi-font-weight:
normal'><a name="m20">равномощны </b><span style='mso-spacerun:yes'> </span>и обладают
одинаковой выразительной способностью. Различия касаются лишь частностей: интерфейсов,
взаимодействия с внешней средой, удобства представления алгоритма и данных.</p>

<p class=a>Об <span style='mso-spacerun:yes'> </span>эквивалентности языков
программирования свидетельствуют также <b style='mso-bidi-font-weight:normal'><a name="m21">трансляторы.
</b>Транслятор – это программа, которая позволяет системе, воспринимающей одни
язык программирования, воспринимать программу, написанную на другом. Непосредственное
восприятие и выполнение указанных в программе действий над внутренним
представлением данных называется <b style='mso-bidi-font-weight:normal'><a name="m22">интерпретацией.
</b>В соответствии с понятием интерпретации компьютерная архитектура – это
интерпретатор программы, алгоритм которой выражен в системе ее команд, а данные
соответствуют форматам их внутреннего представления в этой архитектуре. <b
style='mso-bidi-font-weight:normal'>Компилятором </b>называется программа, переводящая
исходный текст с одного языка программирования на другой. Компиляция программ
возможна как на машинный код (объектный код), так и на некоторый промежуточный
код, имеющий свойство языка и среды программирования. В таком случае для
полученного кода необходим интерпретатор, позволяющий выполнить полученный код
в требуемой компьютерной архитектуре. И, наконец, последнее. Сами трансляторы,
будучи программами, также пишутся на определенных языках программирования.
Аналогично, на языках программирования пишутся операционные системы, в рамках
которых функционирует исполняемый код и т.п.. </p>

<p class=a4><img border="0" src="Images/yan-in.jpg" width="34" height="31">Аналог
проблемы «яйцо-курица». Если компилятор с языка Си написан на самом Си, то для
получения его в машинном коде необходимо откомпилировать исходный текст Си-компилятора
при помощи компилятора, уже имеющегося в машинном коде, для получения которого…
необходим еще один компилятор и т.д. до бесконечности. Аналогично с
операционной системой. Если ядро операционной системы написано на Си, то к
замкнутому кругу Си-компиляторов добавляется условие работы этого компилятора в
среде операционной системы, которая еще не оттранслирована, и, следовательно,
не выполняется. К сожалению, объяснение проблем «раскрутки» и переноса
операционных систем и систем программирования выходит за рамки этой книги.</p>

<h3><font face="Arial">Программа = алгоритм + данные</font></h3>

<p class=a4><span
style='mso-bidi-font-weight:bold'>
<img border="0" src="Images/yan-in.jpg" width="34" height="31">Алгоритм и данные – это <b><a name="m23">«</b></span>Янь и
Инь» программирования. Это утверждение не притянуто<span
style='mso-spacerun:yes'>   </span>«за
уши», как может показаться. Во многих философских системах в качестве одного из
важнейших элементов устройства мироздания рассматривается единство и борьба
противоположных начал (диалектическое единство):</p>

<p class=a1 style='margin-left:42.55pt;text-indent:-7.1pt;mso-list:l0 level1 lfo1;
tab-stops:list 42.55pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span>
<![endif]>каждое
начало является отдельной независимой сущностью, но каждое из них не существует
без своей противоположности;</p>

<p class=a1 style='margin-left:42.55pt;text-indent:-7.1pt;mso-list:l0 level1 lfo1;
tab-stops:list 42.55pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span>
<![endif]>их
противоположность является причиной постоянного взаимопроникновения,
противоречия и борьбы;</p>

<p class=a1 style='margin-left:42.55pt;text-indent:-7.1pt;mso-list:l0 level1 lfo1;
tab-stops:list 42.55pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span>
<![endif]>тем
не менее, в каждом из начал присутствует его противоположность;</p>

<p class=a1 style='margin-left:42.55pt;text-indent:-7.1pt;mso-list:l0 level1 lfo1;
tab-stops:list 42.55pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Times New Roman'>-<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span>
<![endif]>борьба
противоположных начал обуславливает развитие, движение системы в целом.</p>

<p class=a>Символ древнекитайской философии «Янь и Инь» несет в себе всё перечисленное
(попробуйте найти самостоятельно).<span style='mso-spacerun:yes'>  </span>Попробуем
найти</p>

<p class=a4><b style='mso-bidi-font-weight:normal'><a name="m24">Единство данных и алгоритма.
</b>Алгоритм, не использующий данных, превращается в существенно более простую
систему – конечный автомат (см. ниже). Данные без алгоритма вообще становятся
статическим элементом, не изменяемым во времени. </p>

<p class=a4><b style='mso-bidi-font-weight:normal'><a name="m25">Поток команд, поток данных.
Связь через данные. </b>Процесс выполнения алгоритма создает последовательность
выполняемых действий, который называют <b style='mso-bidi-font-weight:normal'><a name="m26">поток
управления </b><span style='mso-spacerun:yes'> </span>или <b style='mso-bidi-font-weight:
normal'><a name="m27">поток команд.</b> Но это не единственный элемент, связующий части
программы в единое целое. Данные в программе также связаны цепочками
преобразований <b style='mso-bidi-font-weight:normal'><a name="m28">операнды – действие –
результат. </b>Поэтому наряду с потоком команд в программе существует еще и <b
style='mso-bidi-font-weight:normal'>поток данных. </b>Таким образом, отдельные,
внешне не связные части алгоритма оказываются логически связанными через данные
том смысле, что одна часть определяет значение переменной, а другая ее
использует. </p>

<p class=a4><b><a name="m29">Что первично? </b><span style='mso-bidi-font-weight:bold'>В
связке двух противоположных начал можно выделить ведущее (первичное) и ведомое
(вторичное). Как уже отмечалось, алгоритмическая компонента программы первична
уже в силу исторических причин: традиционная компьютерная архитектура
базируется на идее исполнения последовательности команд, содержащих адреса
данных (операндов). Аналогично в классическом (структурном) программировании
единицей программного кода является функция, а сущность технологии
программирования выражается фразой «программирование от функции к функции». При
этом данные, передаваемые от функции к функции, являются вторичным (ведомым)
элементом. Поэтому по тексту программы всегда легче отследить
последовательность выполняемых операций, нежели взаимосвязь различных данных
(переменных). <o:p></o:p></span></p>

<p class=a>Технология объектно-ориентированного программирования частично
уравняла алгоритм и данные, объединив их в рамках одного класса. Аналогично,
процесс выполнения программы выглядит как «объект-метод-объект…», в которой обе
противоположности чередуются.</p>

<p class=a4><b><a name="m30">Эквивалентность алгоритма и данных. Структурная и логика
программы и логик переменных состояния. </b><span style='mso-bidi-font-weight:
bold'>Алгоритмическая часть программы может быть уменьшена за счет данных, и
наоборот. В теории алгоритмов говорится, что возможны эквивалентные машины
Тьюринга с двумя командами и с двумя ячейками памяти. Конечно, до таких
крайностей в реальном программировании не доходят. Вряд ли кто-нибудь будет
сокращать число переменных, изобретая систему кодирования значений двух
переменных в одной. Реальное сокращение алгоритмической компоненты (упрощение
логики алгоритма) достигается введением переменных, имеющих отношение к
состоянию выполняемой программы: <b><a name="m31">признаков, счетчиков шагов, переменных
состояния программы, индикаторов событий, таблиц решений </b>и т.п.. Все это
делает алгоритмическую компоненту более регулярной, компактной и универсальной
(но зато и менее «читабельной»).<o:p></o:p></span></p>

<p class=a>Сокращение алгоритмической компоненты возможно не только в
прикладном программировании. Универсальность алгоритмической компоненты,
независимость ее от типов обрабатываемых данных (полиморфизм) и структур данных
– это технологические компоненты, встроенные в современные системы
программирования, которые обеспечивают тот же самый эффект за счет внутренней
организации систем программирования. Например, виртуальные (полиморфные)
методы, известные в технологии объектно-ориентированного программирования,
можно промоделировать в обычной технологии с помощью операторов-переключаетелей
(<span lang=EN-US style='mso-ansi-language:EN-US'>switch</span>). Реальный же
механизм базируется на массивах указателей на функции, т.е. на данных.</p>

<p class=a>Обратная тенденция – исключение переменных, отражающих внутреннее
состояние программы, приводит к разбуханию алгоритмической части. Тем не
менее,<span style='mso-spacerun:yes'>  </span>этому тоже можно найти
оправдание. Например, программа, которая обрабатывает последовательность,
заданную определенным <b style='mso-bidi-font-weight:normal'><a name="m32">форматом, </b>будет
содержать в явном (читабельном) виде структурные компоненты алгоритма,
соответствующие единицам формата: повторениям – циклы, альтернативам – условия,
индикаторам формата – переключатели и т.п..</p>

<p class=a>В системах программирования встречается удобный, но в целом
неэффективный способ универсализации алгоритмов по отношению к данным – <b
style='mso-bidi-font-weight:normal'>шаблоны. </b>Для каждого значения параметра
шаблона генерируется уникальный программный код.</p>

<p class=a4><b><a name="m33"><span style='mso-spacerun:yes'> </span>«Взаимозаменяемость»
алгоритма и данных. </b>Алгоритм и данные в какой-то степени аналогичны
также<span style='mso-spacerun:yes'>  </span>категориям времени и пространства.
Известное положение «выигрывая во времени, проигрываем в пространстве»
применимо и в программировании. Производительность алгоритма может быть
качественно увеличена при использовании дополнительных данных (дополнительной
памяти) (см. например, 8.7. Динамическое программирование). </p>

<h3><font face="Arial">Аналитическое решение и моделирование. Программирование как имитация</font></h3>

<p class=a>Все же наличие алгоритмически неразрешимых проблем не исключает
возможностей применения программных решений в этой области. Здесь уместно
вспомнить о моделировании и имитации, а также провести параллель с математикой:</p>

<p class=a1>- в математике в некоторых случаях невозможно получить
аналитическое решение задачи, например,<span style='mso-spacerun:yes'> 
</span>уравнения. Это является аналогом алгоритмически неразрешимой проблемы;</p>

<p class=a1>- аналитическое решение, полученное в виде <b style='mso-bidi-font-weight:
normal'><a name="m34">формулы, </b>является в математике аналогом компьютерной программы. Она
позволяет получить <b style='mso-bidi-font-weight:normal'><a name="m35">общее </b>решение для
всех случаев.</p>

<p class=a1>- в формуле аналитического решения «заключен интеллект» математика,
которой ее вывел;</p>

<p class=a1>- компьютерная программа аналогично дает решение для любого случая,
но в данном случае также работает не «интеллект» компьютера (программы), а «воспроизводится»
интеллект программиста, разработавшего соответствующий алгоритм.</p>

<div style='mso-element:para-border-div;border:solid windowtext 1.5pt;
padding:1.0pt 1.0pt 1.0pt 1.0pt;margin-left:35.45pt;margin-right:32.9pt'>

<p class=a2 style='margin-top:12.0pt;margin-right:0cm;margin-bottom:12.0pt;
margin-left:0cm'><font face="Arial" size="2">Особенность программы – «воспроизводство» интеллекта
программиста, заложенного в алгоритм.</font></p>

</div>

<p class=a>При невозможности решения проблемы в общем виде, можно попытаться
получить ряд частных решений, основываясь на моделирований или имитации тех
явлений, которые составляют суть проблемы. Например, <b style='mso-bidi-font-weight:
normal'><a name="m36">вычислительная математика (численные методы) –</b> область математики,
которая как раз занимается методами получения приближенных частных решений
математических проблем, обычно не разрешимых в общем виде. Основой таких
методов является имитация процесса получения решения путем манипулирования в
программе математическими объектами в соответствии с законами, заданными в
математической модели (например, уравнениями). </p>

<p class=a>Отсюда следует другой принцип применения программ: создание
программных моделей физических объектов (необязательно через математические
модели, возможно и прямое представление) с последующей имитацией
(моделированием) их поведения. Это позволяет получать частные решения тех
проблем, которые не могут быть разрешены в общем виде.</p>

<h3><font face="Arial">Программы и их место в иерархии формальных систем</font></h3>

<p class=a4 style='margin-top:0cm;margin-right:32.9pt;margin-bottom:0cm;
margin-left:5.0cm;margin-bottom:.0001pt'><span style='mso-bidi-font-style:italic'><i><span
style='mso-spacerun:yes'> </span>«Некоторые вещи нам непонятны не
потому, что понятия наши слабы, а потому что они не входят в круг наших
понятий».<font size="2"> </font> <b style='mso-bidi-font-weight:
normal'><a name="m37"><font size="2">Козьма Прутков</font></b></i></p>

<p class=a>Как мы видели, основное ограничение программ (на практике) и
алгоритмов (в теории алгоритмов) состоит в самоприменимости: насколько возможны
программы, анализирующие и производящие «программы вообще». На самом деле эта
проблема не только теории алгоритмов и, как следствие, программ. Она касается ограниченности
и замкнутости любой формальной системы: <b><a name="m38">никакая формальная система не может
содержать полное описание самой себя. </b>Более точно это сформулировано в
теоремах Гёделя о неполноте:</p>

<p class=a4><b><a name="m39">Теорема 1</b>. В любой замкнутой формальной системе (теории)
существует верная формула (утверждение), не доказуемая в этой теории.</p>

<p class=a4><b><a name="m40">Теорема 2</b>. Формула (утверждение), выражающая
непротиворечивость теории, не может быть доказана в этой теории: то есть любая
теория не может содержать непротиворечивое (полное) описание самой себя.</p>

<p class=a>Сказанное целиком и полностью относится к программам, которые тоже
представляют собой формальную систему. Но кроме программ (машин Тьюринга),
существуют более простые формальные системы, о существовании и<span
style='mso-spacerun:yes'>  </span>возможностях которых должен знать
программист: конечные автоматы, сети Петри, формальные грамматики, которые, на
самом деле являются частными случаями программных систем с теми или иными принципиальными
ограничениями.</p>

<p class=a>Любая из них имеет определенные границы применимости, выше которых
«ей не дано подняться» в силу ее собственной <span
style='mso-spacerun:yes'> </span>сложности. То есть определенные идеи в такой
формальной системе просто не представимы или не выразимы.<b><a name="m41"> </b>Это свойство системы
можно назвать <b><a name="m42">моделирующей способностью. </b>С другой стороны, для каждой
формальной системы существуют проблемы, которые разрешимы в них в общем виде: для
них существует алгоритм решения. Это свойство называется <b><a name="m43">разрешимостью. </b>Очевидно,
чем больше моделирующая способность системы, тем меньше в ней разрешимых
проблем, то есть тем меньше она может быть подвержена автоматизации и
программной реализации.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m44">Конечный автомат. </b>Самая
простая формальная система, которую можно определить как <b style='mso-bidi-font-weight:
normal'><a name="m45">алгоритм без данных. </b><span style='mso-spacerun:yes'> </span>Такая
система не содержит собственных данных, а реагирует только на текущее состояние
внешней среды (единственный элемент памяти хранит<span
style='mso-spacerun:yes'>  </span>текущее состояние алгоритма). Можно сказать,
что конечный автомат моделирует <b style='mso-bidi-font-weight:normal'><a name="m46">инстинктивное
поведение </b>без адаптации и обучения, основанных на запоминании.</p>

<p class=a>Конечные автоматы «горячо любимы» именно из-за их разрешимости:
существуют алгоритмы различного рода анализа и преобразований конечных
автоматов. Поэтому, если решаемую проблему можно сформулировать в этой
формализме, то соответствующими решениями можно будет воспользоваться.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m47">Формальная грамматика - </b><span
style='mso-spacerun:yes'> </span>формальная системы, поведение которой может
быть смоделировано сочетанием конечного автомата (алгоритмической компоненты) и
стековой памяти. В отличие от конечных автоматов, распознающих линейные
последовательности входных данных, формальные грамматики допускают наличие
неограниченной вложенности распознаваемых элементов. Например, синтаксис языков
программирования описывается формальной грамматикой. Вместе с тем, в формальные
грамматиках алгоритмически разрешимы многие проблемы, связанные с
автоматизацией процесса трансляции (синтаксического анализа). Для отдельных
классов грамматик существуют алгоритмы построения распознавателей
(синтаксических процессоров).</p>

<p class=a><span style='mso-spacerun:yes'> </span>Итак, программы (соответствующий
им формализм – машина Тьюринга) являются завершающим звеном в цепи более
простых формальных систем. Работа всех этих формальных систем<span
style='mso-spacerun:yes'>  </span>может быть описана при помощи программ
(смоделирована на компьютере). Чем проще формальная система, тем большее число
проблем в ней алгоритмически разрешимо, т.е. поддается программированию <b
style='mso-bidi-font-weight:normal'>для общего случая. </b>В самом же
программировании большинство задач, связанных с проектированием программ,
алгоритмически не разрешимо.</p>

<p class=MsoPlainText style='margin-left:7.1pt;text-indent:21.25pt'><o:p>&nbsp;</o:p></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=605
 style='width:16.0cm;margin-left:12.5pt;border-collapse:collapse;border:none;
 mso-border-alt:solid windowtext .5pt;mso-padding-alt:0cm 5.4pt 0cm 5.4pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=111 valign=top style='width:83.4pt;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4><b><a name="m48"><span style='font-size:11.0pt;mso-bidi-font-size:10.0pt;
  font-family:Arial'>Система<o:p></o:p></span></b></p>
  </td>
  <td width=163 valign=top style='width:122.15pt;border:solid windowtext 1.0pt;
  border-left:none;mso-border-left-alt:solid windowtext .5pt;mso-border-alt:
  solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4><b><a name="m49"><span style='font-size:11.0pt;mso-bidi-font-size:10.0pt;
  font-family:Arial'>Краткое определение<o:p></o:p></span></b></p>
  </td>
  <td width=331 valign=top style='width:248.05pt;border:solid windowtext 1.0pt;
  border-left:none;mso-border-left-alt:solid windowtext .5pt;mso-border-alt:
  solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4><b><a name="m50"><span style='font-size:11.0pt;mso-bidi-font-size:10.0pt;
  font-family:Arial'>Свойства, возможности<o:p></o:p></span></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td width=111 valign=top style='width:83.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Конечный автомат</p>
  </td>
  <td width=163 valign=top style='width:122.15pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Алгоритм «без данных»</p>
  </td>
  <td width=331 valign=top style='width:248.05pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>«Инстинктивное» поведение,
  распознавание последовательностей, неадаптивное поведение</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td width=111 valign=top style='width:83.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Формальная грамматика</p>
  </td>
  <td width=163 valign=top style='width:122.15pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Конечный автомат со стековой
  памятью</p>
  </td>
  <td width=331 valign=top style='width:248.05pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Распознавание вложенных
  последовательностей произвольной глубины</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td width=111 valign=top style='width:83.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'><span style='font-family:"Times New Roman"'>Сеть
  Петри<o:p></o:p></span></p>
  </td>
  <td width=163 valign=top style='width:122.15pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Система конечных автоматов</p>
  </td>
  <td width=331 valign=top style='width:248.05pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Поведение параллельных и
  независимых систем</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td width=111 valign=top style='width:83.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'><span style='font-family:"Times New Roman"'>Машина
  Тьюринга (программа</span>)</p>
  </td>
  <td width=163 valign=top style='width:122.15pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Конечный автомат с
  неограниченной памятью</p>
  </td>
  <td width=331 valign=top style='width:248.05pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4 align=left style='text-align:left'>Адаптивное поведение с
  элементами запоминания и обучения по заданной программе (правилам игры)</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td width=111 valign=top style='width:83.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4>Программист</p>
  </td>
  <td width=163 valign=top style='width:122.15pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4><b style='mso-bidi-font-weight:normal'><a name="m51">Неформальная система<o:p></o:p></b></p>
  </td>
  <td width=331 valign=top style='width:248.05pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a4>Разработка программ (правил игры)</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>