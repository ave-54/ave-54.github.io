<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=Edit-Time-Data href="056.files/editdata.mso">
<title>Романов Е.Л. Беседы о программировании</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>romanow</o:Author>
  <o:Template>Форматер.dot</o:Template>
  <o:LastAuthor>www.PHILka.RU</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>229</o:TotalTime>
  <o:LastPrinted>2004-12-25T10:56:00Z</o:LastPrinted>
  <o:Created>2008-02-29T12:33:00Z</o:Created>
  <o:LastSaved>2008-02-29T12:33:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>2680</o:Words>
  <o:Characters>15279</o:Characters>
  <o:Company>NSTU_VT</o:Company>
  <o:Bytes>11776</o:Bytes>
  <o:Lines>127</o:Lines>
  <o:Paragraphs>35</o:Paragraphs>
  <o:CharactersWithSpaces>17924</o:CharactersWithSpaces>
  <o:Version>11.6360</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotHyphenateCaps/>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>
  <w:UseMarginsForDrawingGridOrigin/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:WW6BorderRules/>
   <w:FootnoteLayoutLikeWW8/>
   <w:ShapeLayoutLikeWW8/>
   <w:AlignTablesRowByRow/>
   <w:ForgetLastTabAlignment/>
   <w:LayoutRawTableWidth/>
   <w:LayoutTableRowsApart/>
   <w:UseWord97LineBreakingRules/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"Times New Roman CYR";
	panose-1:2 2 6 3 5 4 5 2 3 4;
	mso-font-charset:204;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
@font-face
	{font-family:"Arial CYR";
	panose-1:2 11 6 4 2 2 2 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:536902279 -2147483648 8 0 511 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:14.0pt;
	mso-bidi-font-weight:normal;}
h2
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
h3
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-bidi-font-family:"Times New Roman";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 8.0cm right 16.0cm;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:EN-US;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin-top:0cm;
	margin-right:4.2pt;
	margin-bottom:0cm;
	margin-left:7.1pt;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:21.25pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a, li.a, div.a
	{mso-style-name:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:36.0pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a0, li.a0, div.a0
	{mso-style-name:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a1, li.a1, div.a1
	{mso-style-name:список;
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:18.45pt;
	margin-bottom:0cm;
	margin-left:35.45pt;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	tab-stops:42.55pt;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a2, li.a2, div.a2
	{mso-style-name:определение;
	mso-style-parent:текст;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:35.45pt;
	text-align:justify;
	text-indent:.55pt;
	mso-pagination:widow-orphan;
	border:none;
	mso-border-alt:solid windowtext 1.5pt;
	padding:0cm;
	mso-padding-alt:1.0pt 1.0pt 1.0pt 1.0pt;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a3, li.a3, div.a3
	{mso-style-name:эпиграф;
	margin-top:12.0pt;
	margin-right:32.9pt;
	margin-bottom:12.0pt;
	margin-left:5.0cm;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;
	mso-bidi-font-style:normal;}
p.a4, li.a4, div.a4
	{mso-style-name:"от края";
	mso-style-parent:текст;
	margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a5, li.a5, div.a5
	{mso-style-name:Формула;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:EN-US;
	layout-grid-mode:line;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.a6, li.a6, div.a6
	{mso-style-name:"без формата";
	mso-style-parent:программа;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.a7, li.a7, div.a7
	{mso-style-name:Готовый;
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:0cm 47.95pt 95.9pt 143.85pt 191.8pt 239.75pt 287.7pt 335.65pt 383.6pt 431.55pt 479.5pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	layout-grid-mode:line;}
p.2, li.2, div.2
	{mso-style-name:"заголовок 2";
	mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	font-size:12.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Arial CYR";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;
	mso-bidi-font-weight:normal;
	font-style:italic;
	mso-bidi-font-style:normal;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("056.files/header.htm") fs;
	mso-footnote-continuation-separator:url("056.files/header.htm") fcs;
	mso-endnote-separator:url("056.files/header.htm") es;
	mso-endnote-continuation-separator:url("056.files/header.htm") ecs;}
@page Section1
	{size:21.0cm 842.0pt;
	margin:33.45pt 42.55pt 72.0pt 89.85pt;
	mso-header-margin:14.2pt;
	mso-footer-margin:31.75pt;
	mso-header:url("056.files/header.htm") h1;
	mso-even-footer:url("056.files/header.htm") ef1;
	mso-footer:url("056.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:327908262;
	mso-list-type:simple;
	mso-list-template-ids:68747279;}
@list l0:level1
	{mso-level-tab-stop:18.0pt;
	mso-level-number-position:left;
	margin-left:18.0pt;
	text-indent:-18.0pt;}
@list l1
	{mso-list-id:984745997;
	mso-list-type:hybrid;
	mso-list-template-ids:575806708 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l2
	{mso-list-id:1123572091;
	mso-list-type:hybrid;
	mso-list-template-ids:491843498 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	margin-left:72.0pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l3
	{mso-list-id:1379428889;
	mso-list-type:hybrid;
	mso-list-template-ids:104337776 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l4
	{mso-list-id:1652559672;
	mso-list-type:hybrid;
	mso-list-template-ids:-71108208 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:71.45pt;
	mso-level-number-position:left;
	margin-left:71.45pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
@list l5
	{mso-list-id:1674842426;
	mso-list-template-ids:631377446;}
@list l5:level1
	{mso-level-start-at:11;
	mso-level-number-format:bullet;
	mso-level-text:-;
	mso-level-tab-stop:53.45pt;
	mso-level-number-position:left;
	margin-left:53.45pt;
	text-indent:-18.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@list l6
	{mso-list-id:1945652593;
	mso-list-type:hybrid;
	mso-list-template-ids:1722328900 68747265 68747267 68747269 68747265 68747267 68747269 68747265 68747267 68747269;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	margin-left:72.0pt;
	text-indent:-18.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman CYR";
	mso-bidi-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:36.0pt' background="back.gif">

<div class=Section1>

<h2><font face="Arial">5.6. Динамические переменные и массивы<br>
&nbsp;</font></h2>

<p class="a3" align="right" style="margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:1.0cm;margin-bottom:.0001pt;text-align:right">«Кофе в постель 
могу себе позволить,</p>
<p class="a3" align="right" style="margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:1.0cm;margin-bottom:.0001pt;text-align:right">но сначала нужно 
встать, одеться и сварить,</p>
<p class="a3" align="right" style="margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:1.0cm;margin-bottom:.0001pt;text-align:right">а потом раздеться, 
лечь и и выпить» </p>
<p class="a3" align="right" style="margin-top:0cm;margin-right:32.9pt;margin-bottom:
0cm;margin-left:1.0cm;margin-bottom:.0001pt;text-align:right"><b>
<span style="font-size: 10.0pt; font-family: Times New Roman CYR">М.Жванецкий
</span></b></p>

<h3><font face="Arial">Статический и динамический</font></h3>

<p class="a">Прежде всего, надо разобраться с терминологией <b><a name="m1">
статический/динамический </b>применительно к переменным<b><a name="m2">. </b>В самом широком 
смысле в языках программирования они имеют отношение к моменту <b><a name="m3">связывания </b>
свойств объектов программирования (типов данных, переменных, функций) с 
необходимыми для их существования элементами архитектуры компьютера (командами, 
адресами и т.п.). Связывание <b><a name="m4">статического </b>свойства объекта происходит при 
трансляции (компиляции) программы, свойство является <b><a name="m5">динамическим, </b>&nbsp;если 
связывание его происходит при выполнении программы (см. <b><a name="m6">1.7</b>).</p>
<p class="a">Процесс связывания свойств объекта программирования
(переменной), не является одномоментным. Одни свойства могут быть связаны
раньше, другие – позже. Даже одно свойство может связываться в течение
нескольких этапов. Например, связывание переменной с ее типом всегда происходит
при трансляции. Связывание в ней адреса памяти и значения может происходить в
разное время:</p>

<p class=a style='margin-left:72.0pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:list 72.0pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>глобальные (внешние) переменные размещаются в
общем сегменте данных и получают в нем свои адреса уже при трансляции.
Аналогично происходит их инициализация (присваивание начальных значений)<span
lang=EN-US style='mso-ansi-language:EN-US'>;</span></p>

<p class=a style='margin-left:72.0pt;text-indent:-18.0pt;mso-list:l2 level1 lfo4;
tab-stops:list 72.0pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>локальные переменные размещаются в стеке. Поскольку
данные в стеке адресуются относительно текущего положения указателя стека, то
при трансляции определяется <b style='mso-bidi-font-weight:normal'><a name="m7">смещение</b>
в текущем фрейме (кадре) стека, сформированном при вызове функции. Выделение
памяти и, соответственно, размещение локальных переменных, а также их
инициализация происходят во время выполнения при входе в функцию (продвижением
указателя стека). </p>

<p class=a>В Си имеет место некоторая путаница с термином <b style='mso-bidi-font-weight:
normal'><a name="m8">статическая переменная. </b>Если исходить из общего понимания термина
«статический», то <b style='mso-bidi-font-weight:normal'><a name="m9">все </b>известные нам
до настоящего времени виды переменных <span style='mso-spacerun:yes'> </span>(условно
называемые нами <b style='mso-bidi-font-weight:normal'><a name="m10">глобальные и локальные,</b>
см.<b style='mso-bidi-font-weight:normal'><a name="m11">1.6</b>) являются <b
style='mso-bidi-font-weight:normal'>статическими. </b>Это связано с общим для всех
переменных подходом: тип переменной и ее размерность определяются при
трансляции и в дальнейшем не меняются. Каждым тип данных имеет, аналогично,
фиксированную размерность. Таким образом, транслятором осуществляется <b
style='mso-bidi-font-weight:normal'>статическое распределение памяти</b> под
переменные программы, т.е. за переменными уже во время трансляции закрепляются
известные адреса (или относительные смещения) в соответствующих сегментах
памяти программы. </p>

<p class=a>Отдельного обсуждения требуют локальные переменные. Хотя они и
создаются в стеке уже при выполнении программы, их размерности, тем не менее,
не могут быть изменены (например, размерности локальных массивов тоже должны
быть константами). Поэтому это ничего не меняет в общем для всех <b
style='mso-bidi-font-weight:normal'>именованных </b>переменных тезисе: их
количество, размерности и суммарный объем известны уже при трансляции и не
могут быть изменены при выполнении программы.</p>

<p class=a>Но при написании многих программ заранее неизвестна размерность
обрабатываемых данных. При использовании обычных переменных в таких случаях
возможен единственный выход - определять размерность «по максимуму». В
ситуации, когда требуется обработать данные еще большей размерности, необходимо
внести изменения в текст программы и перетранслировать ее. Для таких целей
используется команда препроцессора <b style='mso-bidi-font-weight:normal'><a name="m12">#define</b>
с тем, чтобы не менять значение одной и той же константы в нескольких местах
программы.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//-------------------------------------------------------------------------------</p>

<p class=a0>// Модель стека в массиве ограниченной размерности</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>#define SZ<span
style='mso-tab-count:1'>         </span>1000<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int<span
style='mso-tab-count:1'>         </span>A[SZ],sp = -1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>int<span
style='mso-tab-count:1'>         </span>PUSH(int vv){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>if (sp==SZ) return 0;<o:p></o:p></span></p>

<p class=a0>
<span
style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">            </span>A[<span lang=EN-US
style='mso-ansi-language:EN-US'>++sp</span>]<span lang=EN-US style='mso-ansi-language:
EN-US'>=vv;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>return</span> 1;}</p>

<h3><font face="Arial">Динамические переменные</font></h3>

<p class=a>Назначение и механизм реализации динамических переменных нужно
воспринимать в свете только что сформулированного малоутешительного вывода: программа
не может превысить лимит памяти, запланированный при трансляции. В противном
случае ей потребуется <b style='mso-bidi-font-weight:normal'><a name="m13">дополнительная
память, </b>выделяемая во время выполнения программы.<b style='mso-bidi-font-weight:
normal'><a name="m14"> <o:p></o:p></b></p>

<p class=a>С этой целью на <span style='mso-spacerun:yes'> </span>уровне
библиотек в Си создан механизм порождения и уничтожения переменных самой работающей
программой. Такие переменные называются <b style='mso-bidi-font-weight:normal'><a name="m15">динамическими</b>,
а область памяти, в которой они создаются – <b style='mso-bidi-font-weight:
normal'><a name="m16">динамической<span style='mso-spacerun:yes'>  </span>памятью </b>или <b
style='mso-bidi-font-weight:normal'>«кучей»</b>. Куча организуется в одном или
нескольких дополнительных сегментах памяти, выделяется программе операционной
системой. Все в целом называется также системой <b style='mso-bidi-font-weight:
normal'><a name="m17">динамического распределения памяти (ДРП). </b>Перечислим основные
свойства динамических переменных: </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l3 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>динамические переменные создаются и уничтожаются
работающей программой путем выполнения специальных операторов или вызовов функций;
</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l3 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>количество и размерность динамических переменных
(массивов) может меняться в процессе работы программы. Это определяется числом
вызовов соответствующих функций их параметрами; </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l3 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>динамическая переменная не имеет имени, доступ к
ней возможен только через указатель; </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l3 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>функция создания динамической переменной ищет в
«куче» свободную память необходимого размера и возвращает указатель на нее
(адрес); </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l3 level1 lfo5;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>функция уничтожения динамической переменной получает
указатель на уничтожаемую переменную. </p>

<p class=a>
<img border="0" src="Images/056-01.jpg" width="257" height="146" align="left">Наиболее важным свойством динамической переменной является ее
«безымянность» и доступность по указателю. Кстати, это хорошо согласуется с
одним из названий операции <b style='mso-bidi-font-weight:normal'><a name="m18">*</b> -
разыменование указателя. Таким образом, динамическая переменная не может быть
доступна «сама по себе»,
а только опосредованно через другие переменные или обычные именованные
указатели. Динамическая переменная может, в свою очередь, содержать один или
несколько указателей на другие динамические переменные. В этом случае мы
получаем динамические структуры данных, в которых количество переменных и связи
между ними могут меняться в процессе работы программы (списки, деревья); </p>

<p class=a>Работа с динамическими переменными и системой ДРП имеет ряд
особенностей и сложностей. Они усугубляются еще и тем, что в Си в соответствии
с<span style='mso-spacerun:yes'>  </span>требованиями эффективности
программного кода, функции библиотеки минимально защищены от ошибок
программирования:</p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l4 level1 lfo6;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>если динамическая переменная создана, а
указатель на нее «потерян» программой, то такая переменная представляет собой
«вещь в себе» -существует, но недоступна для использования. Тем не менее,
занимаемая ею память остается за программой; </p>

<p class=a1 style='margin-left:71.45pt;text-indent:-18.0pt;mso-list:l4 level1 lfo6;
tab-stops:42.55pt list 71.45pt'><![if !supportLists]>
<span
style='mso-list:Ignore; font-family:Symbol; mso-fareast-font-family:Symbol; mso-bidi-font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>ошибки в процессе создания, уничтожения и работы
с динамическими переменными (повторная попытка уничтожения динамической
переменной, попытка уничтожения переменной, не являющейся динамической и т.д.),
приводят к непредсказуемым последствиям в работе программы. Причем программа
«валится» иногда не в том месте, где производятся ошибочные действия, при
последующих вывовах функций работы с библиотекой.</p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m19">Операторы управления
динамической памятью. </b>Операторы <b style='mso-bidi-font-weight:normal'><a name="m20"><span
lang=EN-US style='mso-ansi-language:EN-US'>new</span><span lang=EN-US> </span></b>и
<b style='mso-bidi-font-weight:normal'><a name="m21"><span lang=EN-US style='mso-ansi-language:
EN-US'>delete</span><span lang=EN-US> </span></b>используются для создания и
уничтожения динамических переменных. При создании динамической переменной в
операторе <b style='mso-bidi-font-weight:normal'><a name="m22"><span lang=EN-US
style='font-family:"Times New Roman";mso-ansi-language:EN-US'>new</span></b><span
lang=EN-US style='font-family:"Times New Roman"'> </span>указывается тип
создаваемой переменной, оператор имеет тип результата – указатель на
создаваемый тип, и значение – адрес (указатель) созданной переменной. <span
style='font-family:"Times New Roman"'>Оператор </span><b style='mso-bidi-font-weight:
normal'><a name="m23"><span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'>delete</span></b><b style='mso-bidi-font-weight:normal'><a name="m24"><span
lang=EN-US style='font-family:"Times New Roman"'> </span></b><span
style='font-family:"Times New Roman"'>получает указатель на уничтожаемую
переменную.<o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>double<span style='mso-tab-count:1'>   </span>*pd;<span style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">      </span><span
style='mso-tab-count:1'>            </span>
<span style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">                        </span></p>

<p class=a0>pd = new double<span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>;<span style='mso-tab-count:2'>           </span>//</span>
Обычная динамическая переменная <span style='mso-tab-count:1'>           </span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (pd !=NULL){<span
style='mso-tab-count:5'>                                                   </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>*pd = 5;<span style='mso-tab-count:
8'>                                                                                     </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>delete pd;}<span style='mso-tab-count:
4'>                                             </span><o:p></o:p></span></p>

<p class=a><b style='mso-bidi-font-weight:normal'><a name="m25">Функции управления динамической
памятью низкого уровня. </b>Работать с памятью на Си можно и на «низком»
уровне, рассматривая переменные как области памяти известной размерности,
используя операции <span lang=EN-US style='mso-ansi-language:EN-US'>sizeof</span>
для получения размерности переменных и преобразование типа указателя для
изменения «точки зрения» на содержимое памяти (см. <b style='mso-bidi-font-weight:
normal'><a name="m26">10.2</b>). Функции распределения памяти низкого уровня «не вникают» в
содержание создаваемых переменных, единственно важным для них является их
размерность, выраженная естественным для Си способом в байтах (при помощи
операции sizeof). Адрес выделенной области памяти также возвращается в виде
указателя типа <b style='mso-bidi-font-weight:normal'><a name="m27">void*</b> - абстрактный
адрес памяти без определения адресуемого типа данных.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>void<span style='mso-tab-count:1'>       </span>*malloc(int size);<span
style='mso-tab-count:1'>            </span>// выделить область памяти размером</p>

<p class=a0><span style='mso-tab-count:2'>                                                </span>// в size байтов и
возвратить адрес</p>

<p class=a0>void<span style='mso-tab-count:1'>       </span>free(void *p);<span
style='mso-tab-count:1'>                  </span>//
освободить область памяти,</p>

<p class=a0 style='margin-left:36.0pt;text-indent:36.0pt'><span
style='mso-tab-count:2'>                        </span>// выделенную по адресу
p</p>

<p class=a0>void<span style='mso-tab-count:1'>       </span>*realloc(void *p,
int size);</p>

<p class=a0><span style='mso-tab-count:2'>                                                </span>// расширить выделенную
область памяти</p>

<p class=a0 style='margin-left:36.0pt;text-indent:36.0pt'><span
style='mso-tab-count:2'>                        </span>// до размера size, при
изменении адреса</p>

<p class=a0><span style='mso-tab-count:2'>                                                </span>// переписать старое
содержимое блока</p>

<p class=a0>#<span lang=EN-US style='mso-ansi-language:EN-US'>include</span>
&lt;<span lang=EN-US style='mso-ansi-language:EN-US'>alloc</span>.<span
lang=EN-US style='mso-ansi-language:EN-US'>h</span>&gt;<span style='mso-tab-count:
1'>          </span><span style='mso-tab-count:1'>            </span>// библиотека
функций управления памятью</p>

<p class=a0>double *pd;<span style='mso-tab-count:2'>                    </span>//
Обычная динамическая переменная</p>

<p class=a0>pd = (<span lang=EN-US style='mso-ansi-language:EN-US'>double</span>*)malloc(sizeof(double));</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (pd !=NULL){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>*pd = 5;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span>free(pd); }<o:p></o:p></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=a><span style='mso-spacerun:yes'> </span>Обратите внимание, что оператор
<b style='mso-bidi-font-weight:normal'><a name="m28"><span lang=EN-US style='mso-ansi-language:
EN-US'>delete</span></b>, функции <b style='mso-bidi-font-weight:normal'><a name="m29">free</b>
и <b style='mso-bidi-font-weight:normal'><a name="m30">realloc</b> не содержат размерности
возвращаемой области памяти. Очевидно, что библиотека, управляющая динамической
памятью, должна сохранять информацию о размерности выделенных блоков. Обычно
размерность выделенной памяти размещается в первом слове блока, а программа
получает адрес памяти «вслед за ним» (см.<b style='mso-bidi-font-weight:normal'><a name="m31">10.2</b>).
<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a>В заключение следует сказать, что динамическим переменным «не
повезло»: несмотря на свое исключительное значение в деле представления данных
переменной размерности, они <b style='mso-bidi-font-weight:normal'><a name="m32">синтаксически
</b>поддерживаются библиотекой, а не транслятором, то есть по большому счету
«не входят в язык».</p>

<h3><font face="Arial">Динамические массивы</font></h3>

<p class=a>Адресная арифметика указателей и операторы выделения динамической
памяти позволяют создавать массивы динамических переменных, или <b
style='mso-bidi-font-weight:normal'>динамические массивы (ДМ), </b>синтаксически
не отличимые от обычных:</p>

<ul>
	<li>
	<p class=a1>любой указатель в Си по определению адресует массив элементов указуемого типа неограниченной размерности, при работе с ним можно использовать
стандартную операцию индексации <b style='mso-bidi-font-weight:normal'><a name="m33">[]</b> для
работы с памятью как с массивом;</p></li>
	<li>
	<p class=a1>функция <b
style='mso-bidi-font-weight:normal'>malloc </b>и оператор 
	<b style='mso-bidi-font-weight:
normal'><a name="m34">
	<span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'>new</span></b> могут выделять память под массивы переменных. Размерность
массива задается значением в квадратных скобках оператора 
	<b style='mso-bidi-font-weight:
normal'><a name="m35">
	<span lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:
EN-US'>new</span></b>. В функции <b style='mso-bidi-font-weight:normal'><a name="m36">
	<span
lang=EN-US style='font-family:"Times New Roman";mso-ansi-language:EN-US'>malloc</span><span lang=EN-US style='font-family:"Times New Roman"'>
	</span></b>объем требуемой памяти указывается как произведение размерности
элемента на их количество;</p></li>
	<li>
	<p class=a1>указанные действия <span
style='mso-spacerun:yes'> </span>происходят<span style='font-family:"Times New Roman"'>
	</span>во время работы программы и, следовательно, размерность массива может
меняться от одного выполнения программы к другому. </p></li>
</ul>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>#<span lang=EN-US style='mso-ansi-language:EN-US'>include</span>
&lt;m<span lang=EN-US style='mso-ansi-language:EN-US'>alloc</span>.<span
lang=EN-US style='mso-ansi-language:EN-US'>h</span>&gt;<span style='mso-tab-count:
1'>       </span><span style='mso-tab-count:1'>            </span>// Библиотека
функций управления памятью</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>double</span> *<span
lang=EN-US style='mso-ansi-language:EN-US'>pd</span>1,*<span lang=EN-US
style='mso-ansi-language:EN-US'>pd</span>2;<span style='mso-tab-count:2'>                       </span>//
Массивы динамических переменных<span lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>pd</span>1=<span
lang=EN-US style='mso-ansi-language:EN-US'>new</span><span lang=EN-US> </span><span
lang=EN-US style='mso-ansi-language:EN-US'>double</span>[<span lang=EN-US
style='mso-ansi-language:EN-US'>n</span>1];<span style='mso-tab-count:2'>                  </span>//
Выделение памяти под ДМ</p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>pd2 = (double*)malloc(n2*sizeof(double));<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>if (pd1 ==NULL ||
pd2==NULL) return;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0; i&lt;n1;
i++) pd1[i]=0;<span style='mso-tab-count:1'>        </span>// Работа с ДМ<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>for (i=0; i&lt;n2;
i++) pd2[i]=i;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>delete <b><a name="m37">[ ]</b>pd1;</span><span
style='mso-tab-count:3'>                                </span><span
lang=EN-US style='mso-ansi-language:EN-US'>// Освобождение памяти</span></p>

<p class=a0>free(pd<span lang=EN-US style='mso-ansi-language:EN-US'>2</span>); <span
lang=EN-US style='mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class="a0" align="justify"><font face="Times New Roman" size="3"><i>
Замечание: </i>функции динамического распределения памяти <b><a name="m38"><span lang="EN-US">
malloc</span>/<span lang="EN-US">free</span>/<span lang="EN-US">realloc </span>
</b>и соответствующие операции <b><a name="m39"><span lang="EN-US">new</span>/<span lang="EN-US">delete
</span></b>являются механизмами разных уровней и не сводятся один к другому. 
Функции <b><a name="m40"><span lang="EN-US">malloc</span>/<span lang="EN-US">free</span>/<span lang="EN-US">realloc
</span></b>представляют собой библиотеку «классического» Си и транслятором не 
контролируются. С их помощью можно работать с обычными переменными и их 
массивами, но никак не с объектами. Операции <b><a name="m41"><span lang="EN-US">new</span>/<span lang="EN-US">delete
</span></b>используют собственную систему контроля данных в динамической памяти, 
к тому же при работе с объектами необходимо использовать исключительно их. 
Отсюда рекомендации:</font></p>
<p class="a" style="margin-left: 42.55pt"><span style="font-family: Symbol">·<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>не применять для динамической переменной или динамического массива 
одновременно функции и операции управления динамической памятью;</p>
<p class="a" style="margin-left: 42.55pt"><span style="font-family: Symbol">·<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>при работе с объектами использовать только операции &nbsp;<b><a name="m42"><span lang="EN-US">new</span>/<span lang="EN-US">delete</span>;</b></p>
<p class="a" style="margin-left: 42.55pt"><span style="font-family: Symbol">·<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>при освобождении памяти из-под динамического массива 
«подсказывать» транслятору, что указатель ссылается именно на массив, записывая 
перед указателем пустые скобки: <b><a name="m43"><span lang="EN-US">delete</span> []
<span lang="EN-US">pd</span>1.</b></p>

<p class=a>Массивы, создаваемые в динамической памяти, называются <b
style='mso-bidi-font-weight:normal'>динамическими</b>. Свойства указателей
позволяют одинаковым образом обращаться как с динамическими, так и с обычными
массивами. Во многих языках интерпретирующего типа (например, Бейсик) подобный
механизм скрыт в самом трансляторе, поэтому массивы там «по своей природе»
могут быть переменной размерности.</p>

<p class=a>На самом деле возможность получить массив заданной размерности
проблемы не решает. Программа не всегда знает, сколько какой объем данных она
получит для обработки. Как можно поступить в таком случае<span
style='font-family:"Times New Roman"'>? Есть несколько вариантов:</span></p>

<ul>
	<li>
	<p class=a1>самый
неэффективный<span style='font-family:"Times New Roman"'>:</span> под каждый
вид данных резервировать память заранее «по максимуму». Применительно к массиву
это означает, что мы заранее выбираем такую размерность, которая никогда не
будет превышена. Тем не менее, такое «никогда» рано или поздно может случиться<span
style='font-family:"Times New Roman"'>, </span>поэтому процесс заполнения
массива лучше контролировать<span style='font-family:"Times New Roman"'>;<o:p></o:p></span></p>
	</li>
	<li>
	<p class=a1>приемлемый
вариант может быть реализован, если в какой-то момент времени выполнения
программа «узнает», какова в этот раз будет размерность обрабатываемых данных.
Тогда она может создать динамический массив такой размерности и работать с ним.
К сожалению, такое «знание» не всегда возможно<span style='font-family:"Times New Roman"'>;</span></p>
	</li>
	<li>
	<p class=a1>идеальный вариант заключается в создании такой структуры данных,
которая автоматически увеличивает свою размерность при ее заполнении. К
сожалению, в случае с массивом ни язык, ни библиотека здесь не помогут – его
можно реализовать только программно.<span style='font-family:Arial;mso-bidi-font-family:
"Times New Roman"'><o:p></o:p></span></p></li>
</ul>

<p class=a>Как известно, функция не может возвратить в качестве результата
массив, но она может создать динамический массив во время работы и возвратить
указатель на него. </p>

<p class=a0><span style='font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=a0>//------------------------------------------------------56-01.cpp<o:p></o:p></p>

<p class=a0>// Строка как динамический
массив - объединение строк<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>char<span style='mso-tab-count:1'>  </span>*twoToOne(char *p1, char
*p2){<span style='mso-tab-count:3'>                  </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>char<span style='mso-tab-count:1'>  </span>*out;<span style='mso-tab-count:
1'> </span>int<span style='mso-tab-count:1'>   </span>n1,n2;<o:p></o:p></span></p>

<p class=a0>for (n1=0; p1[n1]!='\0';
n1++);<span style='mso-tab-count:2'>           </span>// Длина первой строки<o:p></o:p></p>

<p class=a0>for (n2=0; p2[n2]!='\0';
n2++);<span style='mso-tab-count:2'>           </span>// Длина второй строки<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>if ((out = new char [n1+n2+1]) == NULL) <o:p></o:p></span></p>

<p class=a0><span style='mso-tab-count:1; mso-ansi-language:EN-US' lang="EN-US">      </span>return NULL;<span style='mso-tab-count:4'>                       &nbsp;&nbsp;&nbsp;&nbsp; </span>//
Выделить память под результат<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>for (n1=0; *p1!='\0';)<span style='mso-spacerun:yes'>  </span>out[n1++]
= *p1++;<o:p></o:p></span></p>

<p class=a0>while(*p2!=0) out[n1++] =
*p2++;<span style='mso-tab-count:2'>     </span>// Копировать строки<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>out[n1] = '\0';<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>return out; }<o:p></o:p></span></p>

<p class=a>В данном примере размерность выходной строки определяется
элементарно как сумма длин строк. Иногда для этого приходится два раза
выполнять одно и тор же действие. Например, при возвращении множителей числа в
первый раз разложение требуется провести для определения количества множителей,
а после выделения памяти во второй раз – для его заполнения.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0>//------------------------------------------------------56-01.cpp<o:p></o:p></p>

<p class=a0>//------ Динамический
массив простых множителей числа<o:p></o:p></p>

<p class=a0>//<span
style='mso-spacerun:yes'>       </span>Размерность массива определяется двойным
вычислением<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>int *mnog(long vv){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>long nn=vv;<o:p></o:p></span></p>

<p class=a0>for (int sz=0; vv!=1;
sz++){<span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:
1'> &nbsp;&nbsp; </span>// Цикл определения количества<o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
1'>      </span>for (int i=2; vv%i!=0; i++);<span style='mso-spacerun:yes'> &nbsp;&nbsp;&nbsp;&nbsp;
</span>// Определить очередной множитель<o:p></o:p></p>

<p class=a0><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span>vv
= vv / i; }<o:p></o:p></p>

<p class=a0>int *p=new int[sz+1];<span
style='mso-tab-count:3'>              &nbsp;&nbsp;&nbsp; </span>// Создать динамический массив<o:p></o:p></p>

<p class=a0>for (int k=0; nn!=1;
k++){<span style='mso-spacerun:yes'>        &nbsp;&nbsp;&nbsp;&nbsp; </span>// Повторный цикл заполнения <o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
1'>      </span>for (int i=2; nn%i!=0; i++);<span style='mso-spacerun:yes'> &nbsp;&nbsp;&nbsp;
</span>// Определить очередной множитель<o:p></o:p></p>

<p class=a0><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span>p[k]=i;<span
style='mso-spacerun:yes'>                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// Сохранить множитель в
массиве<o:p></o:p></p>

<p class=a0><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>      </span>nn
= nn / i; }<o:p></o:p></p>

<p class=a0>p[k]=0; return p;}<span
style='mso-spacerun:yes'>                </span><span style='mso-tab-count:
1'> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// Вернуть указатель на ДМ<o:p></o:p></p>

<p class=a0><span style='font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

<p class=a>Но наиболее универсальным и распространенным случаем является
перераспределение памяти при переполнении массива: создается новый массив
большей размерности, в который переписывается содержимое старого. После чего
старый уничтожается, а указатель на старый массив устанавливается на новый
(новый считается за старый). Все указанные действия можно выполнить
единственной функцией нижнего уровня <b style='mso-bidi-font-weight:normal'><a name="m44">realloc.<o:p></o:p></b></p>

<p class=a3 style='margin-left:1.0cm'>
<img border="0" src="Images/smile.jpg" width="23" height="24" align="left">«Кофе
в постель могу себе позволить, но сначала нужно встать, одеться, сварить, а
потом раздеться, лечь и выпить». М.Жванецкий. <span style='font-family:"Courier New"'><o:p></o:p></span></p>

<p class=a0>//------------------------------------------------------56-01.cpp<o:p></o:p></p>

<p class=a0>// Загрузка динамического
массива целых из файла<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>int *loadInt(char nm[],int &amp;n){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>FILE *fd=fopen(nm,&quot;r&quot;);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>int sz=10,*p</span><span style='mso-ansi-language:
EN-US'>=new int[sz]; n=0;</span></p>
<p class=a0>//-----------------<span style='mso-ansi-language:
EN-US'> или p</span><span lang=EN-US style='mso-ansi-language:
EN-US'>=(int*)malloc(sz*sizeof(int));<o:p></o:p></span></p>

<p class=a0>while(fscanf(fd,&quot;%d&quot;,&amp;p[n])==1){<span
style='mso-tab-count:1'>       </span>//
пока есть числа в файле<o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
1'>      </span>n++;<o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
1'>      </span>if (n==sz){<span style='mso-tab-count:5'>                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>//
массив заполнен<o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
2'>            </span>sz*=2;<span style='mso-tab-count:4'>                       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>//
удвоить размерность<o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
2'>            </span>int *q=new int[sz];<span style='mso-tab-count:2'>          &nbsp;&nbsp;&nbsp;&nbsp; </span>//
создать новый<o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
2'>            </span>for (int i=0;i&lt;n;i++)<span style='mso-tab-count:2'>        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>//
копировать старый в новый<span style='mso-tab-count:1'>  </span><o:p></o:p></p>

<p class=a0><span style='mso-tab-count:
4'>                        </span>
<span lang=EN-US style='mso-ansi-language:EN-US'>q[i]=p[i];<span style='mso-tab-count:
3'>              </span><o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'><span style='mso-tab-count:2'>            </span>delete p;<span
style='mso-tab-count:4'>                     </span> </span><span
style='mso-tab-count:4'><span style='mso-ansi-language:
EN-US'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span> </span>
<span lang=EN-US style='mso-ansi-language:
EN-US'>// </span>уничтожить<span style='mso-ansi-language:EN-US'> </span>старый<span
lang=EN-US style='font-family:"Courier New";mso-ansi-language:EN-US'><o:p></o:p></span></p>

<p class=a0><span style='mso-tab-count:2; mso-ansi-language:EN-US' lang="EN-US">            </span>p=q;<span style='mso-tab-count:5'>                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>//
считать новый за старый<o:p></o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'>//</span><span lang="en-us">---------------</span> или<span lang="en-us">
</span><span
lang=EN-US style='mso-ansi-language:EN-US'>p=(int*)realloc(p,sz*sizeof(int));<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:
EN-US'><span style='mso-tab-count:2'>            </span>}} </span>
<span lang=EN-US style='mso-ansi-language:
EN-US'>return p;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='font-family:"Courier New";mso-ansi-language:
EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=a>Отдельного обсуждения заслуживает вопрос, на сколько следует
увеличивать размерность нового массива. В нашем примере она удваивается, что
приводит к геометрической прогрессии или экспоненциальному росту <b
style='mso-bidi-font-weight:normal'>sz=sz0*2</b><b style='mso-bidi-font-weight:
normal'><a name="m45"><sup><span lang=EN-US style='mso-ansi-language:EN-US'>N</span></sup>. </b>На
это есть свои причины. При заранее неизвестной размерности программа должна
достигать этой размерности достаточно быстро (иначе возникнет эффект
«вычерпывания бочки чайной ложкой»). К<span style='mso-spacerun:yes'> 
</span>тому же операция перераспределения тоже является довольно затратной.
Можно еще оценить и эффективность использования памяти. Занятыми окажутся от
50% до 100% ячеек последнего выделенного массива (т.е. в среднем 75%).
Суммарный объем ранее выделенных массивов будет примерно равен размерности
последнего (<b style='mso-bidi-font-weight:normal'><a name="m46">sz0*(1+2+4+…2<sup>N-1</sup>)=<span lang=EN-US style='mso-ansi-language:
EN-US'>sz</span>0*(2<sup><span
lang=EN-US style='mso-ansi-language:EN-US'>N</span></sup>-1)</b>). Если они не
будут использованы другими динамическими структурами, то эффективность снизится
до <b style='mso-bidi-font-weight:normal'><a name="m47">37.5%.<o:p></o:p></b></p>

<p class=a4>Более изящно это перераспределение можно сделать с помощью функции
низкого уровня <b style='mso-bidi-font-weight:normal'><a name="m48"><span lang=EN-US
style='font-family:"Times New Roman";mso-ansi-language:EN-US'>realloc</span>, </b>которая
резервирует память новой размерности и переписывает в нее содержимое старой
области памяти (либо расширяет существующую)<span style='font-family:"Times New Roman"'>:<b
style='mso-bidi-font-weight:normal'><o:p></o:p></b></span></p>

<p class=a0><span style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'><o:p>&nbsp;</o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>p = (int*)
realloc(p,sizeof(int)*(i+1+N));<o:p></o:p></span></p>

<h3>Вопросы без ответов</h3>

<p class=a4>Определите содержательный смысл функции, назначение и способ
формирования динамического массива.</p>

<p class=a0><o:p>&nbsp;</o:p></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//------------------------------------------------------</span><span style='mso-ansi-language:EN-US'>56</span><span lang=EN-US style='mso-ansi-language:EN-US'>-0</span><span style='mso-ansi-language:EN-US'>2</span><span lang=EN-US style='mso-ansi-language:EN-US'>.cpp<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'>//-----------------------------------------------------
1<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>char *F1(char *s)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ char *p,*q; int n;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (n=0; s[n] !='\0'; n++);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>p = new char[n+1];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (q=p; n &gt;=0; n--) *q++ = *s++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return p; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
2<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int *F2()<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int n,i,*p;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>scanf(&quot;%d&quot;,&amp;n);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>p=new int[n+1];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (p[0]=n, i=0; i&lt;n; i++)
scanf(&quot;&amp;d&quot;,&amp;p[i+1]);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return p; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
3<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int *F3()<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int n,i,*p;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>scanf(&quot;%d&quot;,&amp;n);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>p=new int[n+1];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (i=0; i&lt;n; i++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>{ scanf(&quot;&amp;d&quot;,&amp;p[i]); if
(p[i]&lt;0) break; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>p[i]=-1;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return p; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
4<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>char *F4(char *p, char *q)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int n1, n2;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (n1=0; p[n1]!=0; n1++);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (n2=0; p[n2]!=0; n2++);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>char *s,*v;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>s=v=new char[n1+n2+1];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>while(*p!=0) *s++ = *p++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>while(*q!=0) *s++ = *q++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>*s=0;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return v; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
5<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>double *F5(int n, double v[]){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>double *p=new double[n+1];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>p[0]=n;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (int i=0; i&lt;n; i++) p[i+1]=v[i];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return p; }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
6<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int *F6()<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int *p, n=10,i;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>p=(int*)malloc(n*sizeof(int));<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>for (i=0;;i++){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>           </span>if (i==n) { n=n*2;
p=(int*)realloc(p,sizeof(int)*n); }<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>scanf(&quot;&amp;d&quot;,&amp;p[i]);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>if (p[i]==0) break;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return p;} <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
7 <o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>void *F7(void *p, int n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ char *pp, *qq, *ss;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>qq = ss = new char [n];<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>for (pp= (char*)p; n!=0; n--) *pp++ = *qq++;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return ss;}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>//-------------------------------------------------------
8<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>int *F8(int n)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>{ int s,i,m,k,*p;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>s = 10; </span><span lang=EN-US style='mso-ansi-language:EN-US'>
(int*)malloc(s*sizeof(int));<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>for (i=2, m=0; i&lt;n; i++) {<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>for (k=0; k&lt;m; k++)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'>  
</span>if (i % p[k]==0) break;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'>      </span>if (k==m)<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:1'>            </span><span style='mso-spacerun:yes'>  
</span>{ p[m++] = i;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>if (m==s){<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>s=s*2;<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>p= (int*) realloc( (void*)
p,sizeof(int)*s);<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-tab-count:2'>                        </span>}}}<o:p></o:p></span></p>

<p class=a0><span lang=EN-US style='mso-ansi-language:EN-US'><span
style='mso-spacerun:yes'> </span>return p; }<o:p></o:p></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
